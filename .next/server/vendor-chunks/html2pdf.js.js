"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/html2pdf.js";
exports.ids = ["vendor-chunks/html2pdf.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/html2pdf.js/dist/html2pdf.js":
/*!***************************************************!*\
  !*** ./node_modules/html2pdf.js/dist/html2pdf.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*!\n * html2pdf.js v0.10.3\n * Copyright (c) 2025 Erik Koopmans\n * Released under the MIT License.\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! jspdf */ \"(ssr)/./node_modules/jspdf/dist/jspdf.es.min.js\"), __webpack_require__(/*! html2canvas */ \"(ssr)/./node_modules/html2canvas/dist/html2canvas.esm.js\"));\n    else {}\n})(self, function(__WEBPACK_EXTERNAL_MODULE_jspdf__, __WEBPACK_EXTERNAL_MODULE_html2canvas__) {\n    return /******/ function() {\n        /******/ var __webpack_modules__ = {\n            /***/ \"./src/plugin/hyperlinks.js\": /*!**********************************!*\\\n  !*** ./src/plugin/hyperlinks.js ***!\n  \\**********************************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1035__) {\n                \"use strict\";\n                __nested_webpack_require_1035__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1035__(/*! core-js/modules/web.dom-collections.for-each.js */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_1035__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_string_link_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1035__(/*! core-js/modules/es.string.link.js */ \"./node_modules/core-js/modules/es.string.link.js\");\n                /* harmony import */ var core_js_modules_es_string_link_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_1035__.n(core_js_modules_es_string_link_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1035__(/*! ../worker.js */ \"./src/worker.js\");\n                /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1035__(/*! ../utils.js */ \"./src/utils.js\");\n                // Add hyperlink functionality to the PDF creation.\n                // Main link array, and refs to original functions.\n                var linkInfo = [];\n                var orig = {\n                    toContainer: _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toContainer,\n                    toPdf: _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toPdf\n                };\n                _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toContainer = function toContainer() {\n                    return orig.toContainer.call(this).then(function toContainer_hyperlink() {\n                        // Retrieve hyperlink info if the option is enabled.\n                        if (this.opt.enableLinks) {\n                            // Find all anchor tags and get the container's bounds for reference.\n                            var container = this.prop.container;\n                            var links = container.querySelectorAll(\"a\");\n                            var containerRect = (0, _utils_js__WEBPACK_IMPORTED_MODULE_3__.unitConvert)(container.getBoundingClientRect(), this.prop.pageSize.k);\n                            linkInfo = []; // Loop through each anchor tag.\n                            Array.prototype.forEach.call(links, function(link) {\n                                // Treat each client rect as a separate link (for text-wrapping).\n                                var clientRects = link.getClientRects();\n                                for(var i = 0; i < clientRects.length; i++){\n                                    var clientRect = (0, _utils_js__WEBPACK_IMPORTED_MODULE_3__.unitConvert)(clientRects[i], this.prop.pageSize.k);\n                                    clientRect.left -= containerRect.left;\n                                    clientRect.top -= containerRect.top;\n                                    var page = Math.floor(clientRect.top / this.prop.pageSize.inner.height) + 1;\n                                    var top = this.opt.margin[0] + clientRect.top % this.prop.pageSize.inner.height;\n                                    var left = this.opt.margin[1] + clientRect.left;\n                                    linkInfo.push({\n                                        page: page,\n                                        top: top,\n                                        left: left,\n                                        clientRect: clientRect,\n                                        link: link\n                                    });\n                                }\n                            }, this);\n                        }\n                    });\n                };\n                _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toPdf = function toPdf() {\n                    return orig.toPdf.call(this).then(function toPdf_hyperlink() {\n                        // Add hyperlinks if the option is enabled.\n                        if (this.opt.enableLinks) {\n                            // Attach each anchor tag based on info from toContainer().\n                            linkInfo.forEach(function(l) {\n                                this.prop.pdf.setPage(l.page);\n                                this.prop.pdf.link(l.left, l.top, l.clientRect.width, l.clientRect.height, {\n                                    url: l.link.href\n                                });\n                            }, this); // Reset the active page of the PDF to the final page.\n                            var nPages = this.prop.pdf.internal.getNumberOfPages();\n                            this.prop.pdf.setPage(nPages);\n                        }\n                    });\n                };\n            /***/ },\n            /***/ \"./src/plugin/jspdf-plugin.js\": /*!************************************!*\\\n  !*** ./src/plugin/jspdf-plugin.js ***!\n  \\************************************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_6312__) {\n                \"use strict\";\n                __nested_webpack_require_6312__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_6312__(/*! core-js/modules/es.symbol.js */ \"./node_modules/core-js/modules/es.symbol.js\");\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_6312__(/*! core-js/modules/es.symbol.description.js */ \"./node_modules/core-js/modules/es.symbol.description.js\");\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_6312__(/*! core-js/modules/es.object.to-string.js */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_6312__(/*! core-js/modules/es.symbol.iterator.js */ \"./node_modules/core-js/modules/es.symbol.iterator.js\");\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_6312__(/*! core-js/modules/es.array.iterator.js */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_6312__(/*! core-js/modules/es.string.iterator.js */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5__);\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_6312__(/*! core-js/modules/web.dom-collections.iterator.js */ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__);\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_6312__(/*! jspdf */ \"jspdf\");\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(jspdf__WEBPACK_IMPORTED_MODULE_7__);\n                function _typeof(obj) {\n                    \"@babel/helpers - typeof\";\n                    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                        _typeof = function _typeof(obj) {\n                            return typeof obj;\n                        };\n                    } else {\n                        _typeof = function _typeof(obj) {\n                            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                        };\n                    }\n                    return _typeof(obj);\n                }\n                // Import dependencies.\n                // Get dimensions of a PDF page, as determined by jsPDF.\n                jspdf__WEBPACK_IMPORTED_MODULE_7__.jsPDF.getPageSize = function(orientation, unit, format) {\n                    // Decode options object\n                    if (_typeof(orientation) === \"object\") {\n                        var options = orientation;\n                        orientation = options.orientation;\n                        unit = options.unit || unit;\n                        format = options.format || format;\n                    } // Default options\n                    unit = unit || \"mm\";\n                    format = format || \"a4\";\n                    orientation = (\"\" + (orientation || \"P\")).toLowerCase();\n                    var format_as_string = (\"\" + format).toLowerCase(); // Size in pt of various paper formats\n                    var pageFormats = {\n                        \"a0\": [\n                            2383.94,\n                            3370.39\n                        ],\n                        \"a1\": [\n                            1683.78,\n                            2383.94\n                        ],\n                        \"a2\": [\n                            1190.55,\n                            1683.78\n                        ],\n                        \"a3\": [\n                            841.89,\n                            1190.55\n                        ],\n                        \"a4\": [\n                            595.28,\n                            841.89\n                        ],\n                        \"a5\": [\n                            419.53,\n                            595.28\n                        ],\n                        \"a6\": [\n                            297.64,\n                            419.53\n                        ],\n                        \"a7\": [\n                            209.76,\n                            297.64\n                        ],\n                        \"a8\": [\n                            147.40,\n                            209.76\n                        ],\n                        \"a9\": [\n                            104.88,\n                            147.40\n                        ],\n                        \"a10\": [\n                            73.70,\n                            104.88\n                        ],\n                        \"b0\": [\n                            2834.65,\n                            4008.19\n                        ],\n                        \"b1\": [\n                            2004.09,\n                            2834.65\n                        ],\n                        \"b2\": [\n                            1417.32,\n                            2004.09\n                        ],\n                        \"b3\": [\n                            1000.63,\n                            1417.32\n                        ],\n                        \"b4\": [\n                            708.66,\n                            1000.63\n                        ],\n                        \"b5\": [\n                            498.90,\n                            708.66\n                        ],\n                        \"b6\": [\n                            354.33,\n                            498.90\n                        ],\n                        \"b7\": [\n                            249.45,\n                            354.33\n                        ],\n                        \"b8\": [\n                            175.75,\n                            249.45\n                        ],\n                        \"b9\": [\n                            124.72,\n                            175.75\n                        ],\n                        \"b10\": [\n                            87.87,\n                            124.72\n                        ],\n                        \"c0\": [\n                            2599.37,\n                            3676.54\n                        ],\n                        \"c1\": [\n                            1836.85,\n                            2599.37\n                        ],\n                        \"c2\": [\n                            1298.27,\n                            1836.85\n                        ],\n                        \"c3\": [\n                            918.43,\n                            1298.27\n                        ],\n                        \"c4\": [\n                            649.13,\n                            918.43\n                        ],\n                        \"c5\": [\n                            459.21,\n                            649.13\n                        ],\n                        \"c6\": [\n                            323.15,\n                            459.21\n                        ],\n                        \"c7\": [\n                            229.61,\n                            323.15\n                        ],\n                        \"c8\": [\n                            161.57,\n                            229.61\n                        ],\n                        \"c9\": [\n                            113.39,\n                            161.57\n                        ],\n                        \"c10\": [\n                            79.37,\n                            113.39\n                        ],\n                        \"dl\": [\n                            311.81,\n                            623.62\n                        ],\n                        \"letter\": [\n                            612,\n                            792\n                        ],\n                        \"government-letter\": [\n                            576,\n                            756\n                        ],\n                        \"legal\": [\n                            612,\n                            1008\n                        ],\n                        \"junior-legal\": [\n                            576,\n                            360\n                        ],\n                        \"ledger\": [\n                            1224,\n                            792\n                        ],\n                        \"tabloid\": [\n                            792,\n                            1224\n                        ],\n                        \"credit-card\": [\n                            153,\n                            243\n                        ]\n                    }; // Unit conversion\n                    switch(unit){\n                        case \"pt\":\n                            var k = 1;\n                            break;\n                        case \"mm\":\n                            var k = 72 / 25.4;\n                            break;\n                        case \"cm\":\n                            var k = 72 / 2.54;\n                            break;\n                        case \"in\":\n                            var k = 72;\n                            break;\n                        case \"px\":\n                            var k = 72 / 96;\n                            break;\n                        case \"pc\":\n                            var k = 12;\n                            break;\n                        case \"em\":\n                            var k = 12;\n                            break;\n                        case \"ex\":\n                            var k = 6;\n                            break;\n                        default:\n                            throw \"Invalid unit: \" + unit;\n                    } // Dimensions are stored as user units and converted to points on output\n                    if (pageFormats.hasOwnProperty(format_as_string)) {\n                        var pageHeight = pageFormats[format_as_string][1] / k;\n                        var pageWidth = pageFormats[format_as_string][0] / k;\n                    } else {\n                        try {\n                            var pageHeight = format[1];\n                            var pageWidth = format[0];\n                        } catch (err) {\n                            throw new Error(\"Invalid format: \" + format);\n                        }\n                    } // Handle page orientation\n                    if (orientation === \"p\" || orientation === \"portrait\") {\n                        orientation = \"p\";\n                        if (pageWidth > pageHeight) {\n                            var tmp = pageWidth;\n                            pageWidth = pageHeight;\n                            pageHeight = tmp;\n                        }\n                    } else if (orientation === \"l\" || orientation === \"landscape\") {\n                        orientation = \"l\";\n                        if (pageHeight > pageWidth) {\n                            var tmp = pageWidth;\n                            pageWidth = pageHeight;\n                            pageHeight = tmp;\n                        }\n                    } else {\n                        throw \"Invalid orientation: \" + orientation;\n                    } // Return information (k is the unit conversion ratio from pts)\n                    var info = {\n                        \"width\": pageWidth,\n                        \"height\": pageHeight,\n                        \"unit\": unit,\n                        \"k\": k\n                    };\n                    return info;\n                };\n                /* harmony default export */ __nested_webpack_exports__[\"default\"] = jspdf__WEBPACK_IMPORTED_MODULE_7__.jsPDF;\n            /***/ },\n            /***/ \"./src/plugin/pagebreaks.js\": /*!**********************************!*\\\n  !*** ./src/plugin/pagebreaks.js ***!\n  \\**********************************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_20111__) {\n                \"use strict\";\n                __nested_webpack_require_20111__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_20111__(/*! core-js/modules/es.array.concat.js */ \"./node_modules/core-js/modules/es.array.concat.js\");\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_20111__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_20111__(/*! core-js/modules/es.array.slice.js */ \"./node_modules/core-js/modules/es.array.slice.js\");\n                /* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_20111__.n(core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_20111__(/*! core-js/modules/es.array.join.js */ \"./node_modules/core-js/modules/es.array.join.js\");\n                /* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_20111__.n(core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_20111__(/*! core-js/modules/web.dom-collections.for-each.js */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_20111__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_20111__(/*! core-js/modules/es.object.keys.js */ \"./node_modules/core-js/modules/es.object.keys.js\");\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_20111__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_20111__(/*! ../worker.js */ \"./src/worker.js\");\n                /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_20111__(/*! ../utils.js */ \"./src/utils.js\");\n                /* Pagebreak plugin:\n\n    Adds page-break functionality to the html2pdf library. Page-breaks can be\n    enabled by CSS styles, set on individual elements using selectors, or\n    avoided from breaking inside all elements.\n\n    Options on the `opt.pagebreak` object:\n\n    mode:   String or array of strings: 'avoid-all', 'css', and/or 'legacy'\n            Default: ['css', 'legacy']\n\n    before: String or array of CSS selectors for which to add page-breaks\n            before each element. Can be a specific element with an ID\n            ('#myID'), all elements of a type (e.g. 'img'), all of a class\n            ('.myClass'), or even '*' to match every element.\n\n    after:  Like 'before', but adds a page-break immediately after the element.\n\n    avoid:  Like 'before', but avoids page-breaks on these elements. You can\n            enable this feature on every element using the 'avoid-all' mode.\n*/ // Refs to original functions.\n                var orig = {\n                    toContainer: _worker_js__WEBPACK_IMPORTED_MODULE_5__.default.prototype.toContainer\n                }; // Add pagebreak default options to the Worker template.\n                _worker_js__WEBPACK_IMPORTED_MODULE_5__.default.template.opt.pagebreak = {\n                    mode: [\n                        \"css\",\n                        \"legacy\"\n                    ],\n                    before: [],\n                    after: [],\n                    avoid: []\n                };\n                _worker_js__WEBPACK_IMPORTED_MODULE_5__.default.prototype.toContainer = function toContainer() {\n                    return orig.toContainer.call(this).then(function toContainer_pagebreak() {\n                        // Setup root element and inner page height.\n                        var root = this.prop.container;\n                        var pxPageHeight = this.prop.pageSize.inner.px.height; // Check all requested modes.\n                        var modeSrc = [].concat(this.opt.pagebreak.mode);\n                        var mode = {\n                            avoidAll: modeSrc.indexOf(\"avoid-all\") !== -1,\n                            css: modeSrc.indexOf(\"css\") !== -1,\n                            legacy: modeSrc.indexOf(\"legacy\") !== -1\n                        }; // Get arrays of all explicitly requested elements.\n                        var select = {};\n                        var self1 = this;\n                        [\n                            \"before\",\n                            \"after\",\n                            \"avoid\"\n                        ].forEach(function(key) {\n                            var all = mode.avoidAll && key === \"avoid\";\n                            select[key] = all ? [] : [].concat(self1.opt.pagebreak[key] || []);\n                            if (select[key].length > 0) {\n                                select[key] = Array.prototype.slice.call(root.querySelectorAll(select[key].join(\", \")));\n                            }\n                        }); // Get all legacy page-break elements.\n                        var legacyEls = root.querySelectorAll(\".html2pdf__page-break\");\n                        legacyEls = Array.prototype.slice.call(legacyEls); // Loop through all elements.\n                        var els = root.querySelectorAll(\"*\");\n                        Array.prototype.forEach.call(els, function pagebreak_loop(el) {\n                            // Setup pagebreak rules based on legacy and avoidAll modes.\n                            var rules = {\n                                before: false,\n                                after: mode.legacy && legacyEls.indexOf(el) !== -1,\n                                avoid: mode.avoidAll\n                            }; // Add rules for css mode.\n                            if (mode.css) {\n                                // TODO: Check if this is valid with iFrames.\n                                var style = window.getComputedStyle(el); // TODO: Handle 'left' and 'right' correctly.\n                                // TODO: Add support for 'avoid' on breakBefore/After.\n                                var breakOpt = [\n                                    \"always\",\n                                    \"page\",\n                                    \"left\",\n                                    \"right\"\n                                ];\n                                var avoidOpt = [\n                                    \"avoid\",\n                                    \"avoid-page\"\n                                ];\n                                rules = {\n                                    before: rules.before || breakOpt.indexOf(style.breakBefore || style.pageBreakBefore) !== -1,\n                                    after: rules.after || breakOpt.indexOf(style.breakAfter || style.pageBreakAfter) !== -1,\n                                    avoid: rules.avoid || avoidOpt.indexOf(style.breakInside || style.pageBreakInside) !== -1\n                                };\n                            } // Add rules for explicit requests.\n                            Object.keys(rules).forEach(function(key) {\n                                rules[key] = rules[key] || select[key].indexOf(el) !== -1;\n                            }); // Get element position on the screen.\n                            // TODO: Subtract the top of the container from clientRect.top/bottom?\n                            var clientRect = el.getBoundingClientRect(); // Avoid: Check if a break happens mid-element.\n                            if (rules.avoid && !rules.before) {\n                                var startPage = Math.floor(clientRect.top / pxPageHeight);\n                                var endPage = Math.floor(clientRect.bottom / pxPageHeight);\n                                var nPages = Math.abs(clientRect.bottom - clientRect.top) / pxPageHeight; // Turn on rules.before if the el is broken and is at most one page long.\n                                if (endPage !== startPage && nPages <= 1) {\n                                    rules.before = true;\n                                }\n                            } // Before: Create a padding div to push the element to the next page.\n                            if (rules.before) {\n                                var pad = (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.createElement)(\"div\", {\n                                    style: {\n                                        display: \"block\",\n                                        height: pxPageHeight - clientRect.top % pxPageHeight + \"px\"\n                                    }\n                                });\n                                el.parentNode.insertBefore(pad, el);\n                            } // After: Create a padding div to fill the remaining page.\n                            if (rules.after) {\n                                var pad = (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.createElement)(\"div\", {\n                                    style: {\n                                        display: \"block\",\n                                        height: pxPageHeight - clientRect.bottom % pxPageHeight + \"px\"\n                                    }\n                                });\n                                el.parentNode.insertBefore(pad, el.nextSibling);\n                            }\n                        });\n                    });\n                };\n            /***/ },\n            /***/ \"./src/utils.js\": /*!**********************!*\\\n  !*** ./src/utils.js ***!\n  \\**********************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_30346__) {\n                \"use strict\";\n                __nested_webpack_require_30346__.r(__nested_webpack_exports__);\n                /* harmony export */ __nested_webpack_require_30346__.d(__nested_webpack_exports__, {\n                    /* harmony export */ \"objType\": function() {\n                        return /* binding */ objType;\n                    },\n                    /* harmony export */ \"createElement\": function() {\n                        return /* binding */ createElement;\n                    },\n                    /* harmony export */ \"cloneNode\": function() {\n                        return /* binding */ cloneNode;\n                    },\n                    /* harmony export */ \"unitConvert\": function() {\n                        return /* binding */ unitConvert;\n                    },\n                    /* harmony export */ \"toPx\": function() {\n                        return /* binding */ toPx;\n                    }\n                });\n                /* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_30346__(/*! core-js/modules/es.number.constructor.js */ \"./node_modules/core-js/modules/es.number.constructor.js\");\n                /* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_30346__(/*! core-js/modules/es.symbol.js */ \"./node_modules/core-js/modules/es.symbol.js\");\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_30346__(/*! core-js/modules/es.symbol.description.js */ \"./node_modules/core-js/modules/es.symbol.description.js\");\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_30346__(/*! core-js/modules/es.object.to-string.js */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_30346__(/*! core-js/modules/es.symbol.iterator.js */ \"./node_modules/core-js/modules/es.symbol.iterator.js\");\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_30346__(/*! core-js/modules/es.array.iterator.js */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5__);\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_30346__(/*! core-js/modules/es.string.iterator.js */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_6__);\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_30346__(/*! core-js/modules/web.dom-collections.iterator.js */ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_7__);\n                function _typeof(obj) {\n                    \"@babel/helpers - typeof\";\n                    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                        _typeof = function _typeof(obj) {\n                            return typeof obj;\n                        };\n                    } else {\n                        _typeof = function _typeof(obj) {\n                            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                        };\n                    }\n                    return _typeof(obj);\n                }\n                // Determine the type of a variable/object.\n                var objType = function objType(obj) {\n                    var type = _typeof(obj);\n                    if (type === \"undefined\") return \"undefined\";\n                    else if (type === \"string\" || obj instanceof String) return \"string\";\n                    else if (type === \"number\" || obj instanceof Number) return \"number\";\n                    else if (type === \"function\" || obj instanceof Function) return \"function\";\n                    else if (!!obj && obj.constructor === Array) return \"array\";\n                    else if (obj && obj.nodeType === 1) return \"element\";\n                    else if (type === \"object\") return \"object\";\n                    else return \"unknown\";\n                }; // Create an HTML element with optional className, innerHTML, and style.\n                var createElement = function createElement(tagName, opt) {\n                    var el = document.createElement(tagName);\n                    if (opt.className) el.className = opt.className;\n                    if (opt.innerHTML) {\n                        el.innerHTML = opt.innerHTML;\n                        var scripts = el.getElementsByTagName(\"script\");\n                        for(var i = scripts.length; i-- > 0; null){\n                            scripts[i].parentNode.removeChild(scripts[i]);\n                        }\n                    }\n                    for(var key in opt.style){\n                        el.style[key] = opt.style[key];\n                    }\n                    return el;\n                }; // Deep-clone a node and preserve contents/properties.\n                var cloneNode = function cloneNode(node, javascriptEnabled) {\n                    // Recursively clone the node.\n                    var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);\n                    for(var child = node.firstChild; child; child = child.nextSibling){\n                        if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== \"SCRIPT\") {\n                            clone.appendChild(cloneNode(child, javascriptEnabled));\n                        }\n                    }\n                    if (node.nodeType === 1) {\n                        // Preserve contents/properties of special nodes.\n                        if (node.nodeName === \"CANVAS\") {\n                            clone.width = node.width;\n                            clone.height = node.height;\n                            clone.getContext(\"2d\").drawImage(node, 0, 0);\n                        } else if (node.nodeName === \"TEXTAREA\" || node.nodeName === \"SELECT\") {\n                            clone.value = node.value;\n                        } // Preserve the node's scroll position when it loads.\n                        clone.addEventListener(\"load\", function() {\n                            clone.scrollTop = node.scrollTop;\n                            clone.scrollLeft = node.scrollLeft;\n                        }, true);\n                    } // Return the cloned node.\n                    return clone;\n                }; // Convert units from px using the conversion value 'k' from jsPDF.\n                var unitConvert = function unitConvert(obj, k) {\n                    if (objType(obj) === \"number\") {\n                        return obj * 72 / 96 / k;\n                    } else {\n                        var newObj = {};\n                        for(var key in obj){\n                            newObj[key] = obj[key] * 72 / 96 / k;\n                        }\n                        return newObj;\n                    }\n                }; // Convert units to px using the conversion value 'k' from jsPDF.\n                var toPx = function toPx(val, k) {\n                    return Math.floor(val * k / 72 * 96);\n                };\n            /***/ },\n            /***/ \"./src/worker.js\": /*!***********************!*\\\n  !*** ./src/worker.js ***!\n  \\***********************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_39704__) {\n                \"use strict\";\n                __nested_webpack_require_39704__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_39704__(/*! core-js/modules/es.object.assign.js */ \"./node_modules/core-js/modules/es.object.assign.js\");\n                /* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_39704__(/*! core-js/modules/es.array.map.js */ \"./node_modules/core-js/modules/es.array.map.js\");\n                /* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_39704__(/*! core-js/modules/es.object.keys.js */ \"./node_modules/core-js/modules/es.object.keys.js\");\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_39704__(/*! core-js/modules/es.array.concat.js */ \"./node_modules/core-js/modules/es.array.concat.js\");\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_39704__(/*! core-js/modules/es.object.to-string.js */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_39704__(/*! core-js/modules/es.regexp.to-string.js */ \"./node_modules/core-js/modules/es.regexp.to-string.js\");\n                /* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5__);\n                /* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_39704__(/*! core-js/modules/es.function.name.js */ \"./node_modules/core-js/modules/es.function.name.js\");\n                /* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_6__);\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_39704__(/*! core-js/modules/web.dom-collections.for-each.js */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7__);\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_39704__(/*! jspdf */ \"jspdf\");\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(jspdf__WEBPACK_IMPORTED_MODULE_8__);\n                /* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_39704__(/*! html2canvas */ \"html2canvas\");\n                /* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(html2canvas__WEBPACK_IMPORTED_MODULE_9__);\n                /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_39704__(/*! ./utils.js */ \"./src/utils.js\");\n                /* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_39704__(/*! es6-promise */ \"./node_modules/es6-promise/dist/es6-promise.js\");\n                /* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(es6_promise__WEBPACK_IMPORTED_MODULE_11__);\n                var Promise = es6_promise__WEBPACK_IMPORTED_MODULE_11___default().Promise;\n                /* ----- CONSTRUCTOR ----- */ var Worker = function Worker(opt) {\n                    // Create the root parent for the proto chain, and the starting Worker.\n                    var root = Object.assign(Worker.convert(Promise.resolve()), JSON.parse(JSON.stringify(Worker.template)));\n                    var self1 = Worker.convert(Promise.resolve(), root); // Set progress, optional settings, and return.\n                    self1 = self1.setProgress(1, Worker, 1, [\n                        Worker\n                    ]);\n                    self1 = self1.set(opt);\n                    return self1;\n                }; // Boilerplate for subclassing Promise.\n                Worker.prototype = Object.create(Promise.prototype);\n                Worker.prototype.constructor = Worker; // Converts/casts promises into Workers.\n                Worker.convert = function convert(promise, inherit) {\n                    // Uses prototypal inheritance to receive changes made to ancestors' properties.\n                    promise.__proto__ = inherit || Worker.prototype;\n                    return promise;\n                };\n                Worker.template = {\n                    prop: {\n                        src: null,\n                        container: null,\n                        overlay: null,\n                        canvas: null,\n                        img: null,\n                        pdf: null,\n                        pageSize: null\n                    },\n                    progress: {\n                        val: 0,\n                        state: null,\n                        n: 0,\n                        stack: []\n                    },\n                    opt: {\n                        filename: \"file.pdf\",\n                        margin: [\n                            0,\n                            0,\n                            0,\n                            0\n                        ],\n                        image: {\n                            type: \"jpeg\",\n                            quality: 0.95\n                        },\n                        enableLinks: true,\n                        html2canvas: {},\n                        jsPDF: {}\n                    }\n                };\n                /* ----- FROM / TO ----- */ Worker.prototype.from = function from(src, type) {\n                    function getType(src) {\n                        switch((0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.objType)(src)){\n                            case \"string\":\n                                return \"string\";\n                            case \"element\":\n                                return src.nodeName.toLowerCase && src.nodeName.toLowerCase() === \"canvas\" ? \"canvas\" : \"element\";\n                            default:\n                                return \"unknown\";\n                        }\n                    }\n                    return this.then(function from_main() {\n                        type = type || getType(src);\n                        switch(type){\n                            case \"string\":\n                                return this.set({\n                                    src: (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.createElement)(\"div\", {\n                                        innerHTML: src\n                                    })\n                                });\n                            case \"element\":\n                                return this.set({\n                                    src: src\n                                });\n                            case \"canvas\":\n                                return this.set({\n                                    canvas: src\n                                });\n                            case \"img\":\n                                return this.set({\n                                    img: src\n                                });\n                            default:\n                                return this.error(\"Unknown source type.\");\n                        }\n                    });\n                };\n                Worker.prototype.to = function to(target) {\n                    // Route the 'to' request to the appropriate method.\n                    switch(target){\n                        case \"container\":\n                            return this.toContainer();\n                        case \"canvas\":\n                            return this.toCanvas();\n                        case \"img\":\n                            return this.toImg();\n                        case \"pdf\":\n                            return this.toPdf();\n                        default:\n                            return this.error(\"Invalid target.\");\n                    }\n                };\n                Worker.prototype.toContainer = function toContainer() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkSrc() {\n                            return this.prop.src || this.error(\"Cannot duplicate - no source HTML.\");\n                        },\n                        function checkPageSize() {\n                            return this.prop.pageSize || this.setPageSize();\n                        }\n                    ];\n                    return this.thenList(prereqs).then(function toContainer_main() {\n                        // Define the CSS styles for the container and its overlay parent.\n                        var overlayCSS = {\n                            position: \"fixed\",\n                            overflow: \"hidden\",\n                            zIndex: 1000,\n                            left: 0,\n                            right: 0,\n                            bottom: 0,\n                            top: 0,\n                            backgroundColor: \"rgba(0,0,0,0.8)\"\n                        };\n                        var containerCSS = {\n                            position: \"absolute\",\n                            width: this.prop.pageSize.inner.width + this.prop.pageSize.unit,\n                            left: 0,\n                            right: 0,\n                            top: 0,\n                            height: \"auto\",\n                            margin: \"auto\",\n                            backgroundColor: \"white\"\n                        }; // Set the overlay to hidden (could be changed in the future to provide a print preview).\n                        overlayCSS.opacity = 0; // Create and attach the elements.\n                        var source = (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.cloneNode)(this.prop.src, this.opt.html2canvas.javascriptEnabled);\n                        this.prop.overlay = (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.createElement)(\"div\", {\n                            className: \"html2pdf__overlay\",\n                            style: overlayCSS\n                        });\n                        this.prop.container = (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.createElement)(\"div\", {\n                            className: \"html2pdf__container\",\n                            style: containerCSS\n                        });\n                        this.prop.container.appendChild(source);\n                        this.prop.overlay.appendChild(this.prop.container);\n                        document.body.appendChild(this.prop.overlay);\n                    });\n                };\n                Worker.prototype.toCanvas = function toCanvas() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkContainer() {\n                            return document.body.contains(this.prop.container) || this.toContainer();\n                        }\n                    ]; // Fulfill prereqs then create the canvas.\n                    return this.thenList(prereqs).then(function toCanvas_main() {\n                        // Handle old-fashioned 'onrendered' argument.\n                        var options = Object.assign({}, this.opt.html2canvas);\n                        delete options.onrendered;\n                        return html2canvas__WEBPACK_IMPORTED_MODULE_9__(this.prop.container, options);\n                    }).then(function toCanvas_post(canvas) {\n                        // Handle old-fashioned 'onrendered' argument.\n                        var onRendered = this.opt.html2canvas.onrendered || function() {};\n                        onRendered(canvas);\n                        this.prop.canvas = canvas;\n                        document.body.removeChild(this.prop.overlay);\n                    });\n                };\n                Worker.prototype.toImg = function toImg() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkCanvas() {\n                            return this.prop.canvas || this.toCanvas();\n                        }\n                    ]; // Fulfill prereqs then create the image.\n                    return this.thenList(prereqs).then(function toImg_main() {\n                        var imgData = this.prop.canvas.toDataURL(\"image/\" + this.opt.image.type, this.opt.image.quality);\n                        this.prop.img = document.createElement(\"img\");\n                        this.prop.img.src = imgData;\n                    });\n                };\n                Worker.prototype.toPdf = function toPdf() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkCanvas() {\n                            return this.prop.canvas || this.toCanvas();\n                        },\n                        function checkPageSize() {\n                            return this.prop.pageSize || this.setPageSize();\n                        }\n                    ]; // Fulfill prereqs then create the image.\n                    return this.thenList(prereqs).then(function toPdf_main() {\n                        // Create local copies of frequently used properties.\n                        var canvas = this.prop.canvas;\n                        var opt = this.opt; // Calculate the number of pages.\n                        var pxFullHeight = canvas.height;\n                        var pxPageHeight = Math.floor(canvas.width * this.prop.pageSize.inner.ratio);\n                        var nPages = Math.ceil(pxFullHeight / pxPageHeight); // Define pageHeight separately so it can be trimmed on the final page.\n                        var pageHeight = this.prop.pageSize.inner.height; // Create a one-page canvas to split up the full image.\n                        var pageCanvas = document.createElement(\"canvas\");\n                        var pageCtx = pageCanvas.getContext(\"2d\");\n                        pageCanvas.width = canvas.width;\n                        pageCanvas.height = pxPageHeight; // Initialize the PDF.\n                        this.prop.pdf = this.prop.pdf || new jspdf__WEBPACK_IMPORTED_MODULE_8__.jsPDF(opt.jsPDF);\n                        for(var page = 0; page < nPages; page++){\n                            // Trim the final page to reduce file size.\n                            if (page === nPages - 1 && pxFullHeight % pxPageHeight !== 0) {\n                                pageCanvas.height = pxFullHeight % pxPageHeight;\n                                pageHeight = pageCanvas.height * this.prop.pageSize.inner.width / pageCanvas.width;\n                            } // Display the page.\n                            var w = pageCanvas.width;\n                            var h = pageCanvas.height;\n                            pageCtx.fillStyle = \"white\";\n                            pageCtx.fillRect(0, 0, w, h);\n                            pageCtx.drawImage(canvas, 0, page * pxPageHeight, w, h, 0, 0, w, h); // Add the page to the PDF.\n                            if (page) this.prop.pdf.addPage();\n                            var imgData = pageCanvas.toDataURL(\"image/\" + opt.image.type, opt.image.quality);\n                            this.prop.pdf.addImage(imgData, opt.image.type, opt.margin[1], opt.margin[0], this.prop.pageSize.inner.width, pageHeight);\n                        }\n                    });\n                };\n                /* ----- OUTPUT / SAVE ----- */ Worker.prototype.output = function output(type, options, src) {\n                    // Redirect requests to the correct function (outputPdf / outputImg).\n                    src = src || \"pdf\";\n                    if (src.toLowerCase() === \"img\" || src.toLowerCase() === \"image\") {\n                        return this.outputImg(type, options);\n                    } else {\n                        return this.outputPdf(type, options);\n                    }\n                };\n                Worker.prototype.outputPdf = function outputPdf(type, options) {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkPdf() {\n                            return this.prop.pdf || this.toPdf();\n                        }\n                    ]; // Fulfill prereqs then perform the appropriate output.\n                    return this.thenList(prereqs).then(function outputPdf_main() {\n                        /* Currently implemented output types:\n     *    https://rawgit.com/MrRio/jsPDF/master/docs/jspdf.js.html#line992\n     *  save(options), arraybuffer, blob, bloburi/bloburl,\n     *  datauristring/dataurlstring, dataurlnewwindow, datauri/dataurl\n     */ return this.prop.pdf.output(type, options);\n                    });\n                };\n                Worker.prototype.outputImg = function outputImg(type, options) {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkImg() {\n                            return this.prop.img || this.toImg();\n                        }\n                    ]; // Fulfill prereqs then perform the appropriate output.\n                    return this.thenList(prereqs).then(function outputImg_main() {\n                        switch(type){\n                            case undefined:\n                            case \"img\":\n                                return this.prop.img;\n                            case \"datauristring\":\n                            case \"dataurlstring\":\n                                return this.prop.img.src;\n                            case \"datauri\":\n                            case \"dataurl\":\n                                return document.location.href = this.prop.img.src;\n                            default:\n                                throw 'Image output type \"' + type + '\" is not supported.';\n                        }\n                    });\n                };\n                Worker.prototype.save = function save(filename) {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkPdf() {\n                            return this.prop.pdf || this.toPdf();\n                        }\n                    ]; // Fulfill prereqs, update the filename (if provided), and save the PDF.\n                    return this.thenList(prereqs).set(filename ? {\n                        filename: filename\n                    } : null).then(function save_main() {\n                        this.prop.pdf.save(this.opt.filename);\n                    });\n                };\n                /* ----- SET / GET ----- */ Worker.prototype.set = function set(opt) {\n                    // TODO: Implement ordered pairs?\n                    // Silently ignore invalid or empty input.\n                    if ((0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.objType)(opt) !== \"object\") {\n                        return this;\n                    } // Build an array of setter functions to queue.\n                    var fns = Object.keys(opt || {}).map(function(key) {\n                        switch(key){\n                            case \"margin\":\n                                return this.setMargin.bind(this, opt.margin);\n                            case \"jsPDF\":\n                                return function set_jsPDF() {\n                                    this.opt.jsPDF = opt.jsPDF;\n                                    return this.setPageSize();\n                                };\n                            case \"pageSize\":\n                                return this.setPageSize.bind(this, opt.pageSize);\n                            default:\n                                if (key in Worker.template.prop) {\n                                    // Set pre-defined properties in prop.\n                                    return function set_prop() {\n                                        this.prop[key] = opt[key];\n                                    };\n                                } else {\n                                    // Set any other properties in opt.\n                                    return function set_opt() {\n                                        this.opt[key] = opt[key];\n                                    };\n                                }\n                        }\n                    }, this); // Set properties within the promise chain.\n                    return this.then(function set_main() {\n                        return this.thenList(fns);\n                    });\n                };\n                Worker.prototype.get = function get(key, cbk) {\n                    return this.then(function get_main() {\n                        // Fetch the requested property, either as a predefined prop or in opt.\n                        var val = key in Worker.template.prop ? this.prop[key] : this.opt[key];\n                        return cbk ? cbk(val) : val;\n                    });\n                };\n                Worker.prototype.setMargin = function setMargin(margin) {\n                    return this.then(function setMargin_main() {\n                        // Parse the margin property: [top, left, bottom, right].\n                        switch((0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.objType)(margin)){\n                            case \"number\":\n                                margin = [\n                                    margin,\n                                    margin,\n                                    margin,\n                                    margin\n                                ];\n                            case \"array\":\n                                if (margin.length === 2) {\n                                    margin = [\n                                        margin[0],\n                                        margin[1],\n                                        margin[0],\n                                        margin[1]\n                                    ];\n                                }\n                                if (margin.length === 4) {\n                                    break;\n                                }\n                            default:\n                                return this.error(\"Invalid margin array.\");\n                        } // Set the margin property, then update pageSize.\n                        this.opt.margin = margin;\n                    }).then(this.setPageSize);\n                };\n                Worker.prototype.setPageSize = function setPageSize(pageSize) {\n                    return this.then(function setPageSize_main() {\n                        // Retrieve page-size based on jsPDF settings, if not explicitly provided.\n                        pageSize = pageSize || jspdf__WEBPACK_IMPORTED_MODULE_8__.jsPDF.getPageSize(this.opt.jsPDF); // Add 'inner' field if not present.\n                        if (!pageSize.hasOwnProperty(\"inner\")) {\n                            pageSize.inner = {\n                                width: pageSize.width - this.opt.margin[1] - this.opt.margin[3],\n                                height: pageSize.height - this.opt.margin[0] - this.opt.margin[2]\n                            };\n                            pageSize.inner.px = {\n                                width: (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.toPx)(pageSize.inner.width, pageSize.k),\n                                height: (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.toPx)(pageSize.inner.height, pageSize.k)\n                            };\n                            pageSize.inner.ratio = pageSize.inner.height / pageSize.inner.width;\n                        } // Attach pageSize to this.\n                        this.prop.pageSize = pageSize;\n                    });\n                };\n                Worker.prototype.setProgress = function setProgress(val, state, n, stack) {\n                    // Immediately update all progress values.\n                    if (val != null) this.progress.val = val;\n                    if (state != null) this.progress.state = state;\n                    if (n != null) this.progress.n = n;\n                    if (stack != null) this.progress.stack = stack;\n                    this.progress.ratio = this.progress.val / this.progress.state; // Return this for command chaining.\n                    return this;\n                };\n                Worker.prototype.updateProgress = function updateProgress(val, state, n, stack) {\n                    // Immediately update all progress values, using setProgress.\n                    return this.setProgress(val ? this.progress.val + val : null, state ? state : null, n ? this.progress.n + n : null, stack ? this.progress.stack.concat(stack) : null);\n                };\n                /* ----- PROMISE MAPPING ----- */ Worker.prototype.then = function then(onFulfilled, onRejected) {\n                    // Wrap `this` for encapsulation.\n                    var self1 = this;\n                    return this.thenCore(onFulfilled, onRejected, function then_main(onFulfilled, onRejected) {\n                        // Update progress while queuing, calling, and resolving `then`.\n                        self1.updateProgress(null, null, 1, [\n                            onFulfilled\n                        ]);\n                        return Promise.prototype.then.call(this, function then_pre(val) {\n                            self1.updateProgress(null, onFulfilled);\n                            return val;\n                        }).then(onFulfilled, onRejected).then(function then_post(val) {\n                            self1.updateProgress(1);\n                            return val;\n                        });\n                    });\n                };\n                Worker.prototype.thenCore = function thenCore(onFulfilled, onRejected, thenBase) {\n                    // Handle optional thenBase parameter.\n                    thenBase = thenBase || Promise.prototype.then; // Wrap `this` for encapsulation and bind it to the promise handlers.\n                    var self1 = this;\n                    if (onFulfilled) {\n                        onFulfilled = onFulfilled.bind(self1);\n                    }\n                    if (onRejected) {\n                        onRejected = onRejected.bind(self1);\n                    } // Cast self into a Promise to avoid polyfills recursively defining `then`.\n                    var isNative = Promise.toString().indexOf(\"[native code]\") !== -1 && Promise.name === \"Promise\";\n                    var selfPromise = isNative ? self1 : Worker.convert(Object.assign({}, self1), Promise.prototype); // Return the promise, after casting it into a Worker and preserving props.\n                    var returnVal = thenBase.call(selfPromise, onFulfilled, onRejected);\n                    return Worker.convert(returnVal, self1.__proto__);\n                };\n                Worker.prototype.thenExternal = function thenExternal(onFulfilled, onRejected) {\n                    // Call `then` and return a standard promise (exits the Worker chain).\n                    return Promise.prototype.then.call(this, onFulfilled, onRejected);\n                };\n                Worker.prototype.thenList = function thenList(fns) {\n                    // Queue a series of promise 'factories' into the promise chain.\n                    var self1 = this;\n                    fns.forEach(function thenList_forEach(fn) {\n                        self1 = self1.thenCore(fn);\n                    });\n                    return self1;\n                };\n                Worker.prototype[\"catch\"] = function(onRejected) {\n                    // Bind `this` to the promise handler, call `catch`, and return a Worker.\n                    if (onRejected) {\n                        onRejected = onRejected.bind(this);\n                    }\n                    var returnVal = Promise.prototype[\"catch\"].call(this, onRejected);\n                    return Worker.convert(returnVal, this);\n                };\n                Worker.prototype.catchExternal = function catchExternal(onRejected) {\n                    // Call `catch` and return a standard promise (exits the Worker chain).\n                    return Promise.prototype[\"catch\"].call(this, onRejected);\n                };\n                Worker.prototype.error = function error(msg) {\n                    // Throw the error in the Promise chain.\n                    return this.then(function error_main() {\n                        throw new Error(msg);\n                    });\n                };\n                /* ----- ALIASES ----- */ Worker.prototype.using = Worker.prototype.set;\n                Worker.prototype.saveAs = Worker.prototype.save;\n                Worker.prototype.export = Worker.prototype.output;\n                Worker.prototype.run = Worker.prototype.then;\n                /* ----- FINISHING ----- */ // Expose the Worker class.\n                /* harmony default export */ __nested_webpack_exports__[\"default\"] = Worker;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/a-function.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/a-function.js ***!\n  \\******************************************************/ /***/ function(module1) {\n                module1.exports = function(it) {\n                    if (typeof it != \"function\") {\n                        throw TypeError(String(it) + \" is not a function\");\n                    }\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/a-possible-prototype.js\": /*!****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!\n  \\****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_71246__) {\n                var isObject = __nested_webpack_require_71246__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                module1.exports = function(it) {\n                    if (!isObject(it) && it !== null) {\n                        throw TypeError(\"Can't set \" + String(it) + \" as a prototype\");\n                    }\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/add-to-unscopables.js\": /*!**************************************************************!*\\\n  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!\n  \\**************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_72015__) {\n                var wellKnownSymbol = __nested_webpack_require_72015__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var create = __nested_webpack_require_72015__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var definePropertyModule = __nested_webpack_require_72015__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var UNSCOPABLES = wellKnownSymbol(\"unscopables\");\n                var ArrayPrototype = Array.prototype;\n                // Array.prototype[@@unscopables]\n                // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n                if (ArrayPrototype[UNSCOPABLES] == undefined) {\n                    definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\n                        configurable: true,\n                        value: create(null)\n                    });\n                }\n                // add a key to Array.prototype[@@unscopables]\n                module1.exports = function(key) {\n                    ArrayPrototype[UNSCOPABLES][key] = true;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/an-object.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/an-object.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_73521__) {\n                var isObject = __nested_webpack_require_73521__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                module1.exports = function(it) {\n                    if (!isObject(it)) {\n                        throw TypeError(String(it) + \" is not an object\");\n                    }\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-for-each.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-for-each.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_74246__) {\n                \"use strict\";\n                var $forEach = __nested_webpack_require_74246__(/*! ../internals/array-iteration */ \"./node_modules/core-js/internals/array-iteration.js\").forEach;\n                var arrayMethodIsStrict = __nested_webpack_require_74246__(/*! ../internals/array-method-is-strict */ \"./node_modules/core-js/internals/array-method-is-strict.js\");\n                var STRICT_METHOD = arrayMethodIsStrict(\"forEach\");\n                // `Array.prototype.forEach` method implementation\n                // https://tc39.es/ecma262/#sec-array.prototype.foreach\n                module1.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */ ) {\n                    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n                // eslint-disable-next-line es/no-array-prototype-foreach -- safe\n                } : [].forEach;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-includes.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-includes.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_75476__) {\n                var toIndexedObject = __nested_webpack_require_75476__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var toLength = __nested_webpack_require_75476__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var toAbsoluteIndex = __nested_webpack_require_75476__(/*! ../internals/to-absolute-index */ \"./node_modules/core-js/internals/to-absolute-index.js\");\n                // `Array.prototype.{ indexOf, includes }` methods implementation\n                var createMethod = function(IS_INCLUDES) {\n                    return function($this, el, fromIndex) {\n                        var O = toIndexedObject($this);\n                        var length = toLength(O.length);\n                        var index = toAbsoluteIndex(fromIndex, length);\n                        var value;\n                        // Array#includes uses SameValueZero equality algorithm\n                        // eslint-disable-next-line no-self-compare -- NaN check\n                        if (IS_INCLUDES && el != el) while(length > index){\n                            value = O[index++];\n                            // eslint-disable-next-line no-self-compare -- NaN check\n                            if (value != value) return true;\n                        // Array#indexOf ignores holes, Array#includes - not\n                        }\n                        else for(; length > index; index++){\n                            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n                        }\n                        return !IS_INCLUDES && -1;\n                    };\n                };\n                module1.exports = {\n                    // `Array.prototype.includes` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.includes\n                    includes: createMethod(true),\n                    // `Array.prototype.indexOf` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.indexof\n                    indexOf: createMethod(false)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-iteration.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-iteration.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_77945__) {\n                var bind = __nested_webpack_require_77945__(/*! ../internals/function-bind-context */ \"./node_modules/core-js/internals/function-bind-context.js\");\n                var IndexedObject = __nested_webpack_require_77945__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                var toObject = __nested_webpack_require_77945__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var toLength = __nested_webpack_require_77945__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var arraySpeciesCreate = __nested_webpack_require_77945__(/*! ../internals/array-species-create */ \"./node_modules/core-js/internals/array-species-create.js\");\n                var push = [].push;\n                // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\n                var createMethod = function(TYPE) {\n                    var IS_MAP = TYPE == 1;\n                    var IS_FILTER = TYPE == 2;\n                    var IS_SOME = TYPE == 3;\n                    var IS_EVERY = TYPE == 4;\n                    var IS_FIND_INDEX = TYPE == 6;\n                    var IS_FILTER_REJECT = TYPE == 7;\n                    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n                    return function($this, callbackfn, that, specificCreate) {\n                        var O = toObject($this);\n                        var self1 = IndexedObject(O);\n                        var boundFunction = bind(callbackfn, that, 3);\n                        var length = toLength(self1.length);\n                        var index = 0;\n                        var create = specificCreate || arraySpeciesCreate;\n                        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n                        var value, result;\n                        for(; length > index; index++)if (NO_HOLES || index in self1) {\n                            value = self1[index];\n                            result = boundFunction(value, index, O);\n                            if (TYPE) {\n                                if (IS_MAP) target[index] = result; // map\n                                else if (result) switch(TYPE){\n                                    case 3:\n                                        return true; // some\n                                    case 5:\n                                        return value; // find\n                                    case 6:\n                                        return index; // findIndex\n                                    case 2:\n                                        push.call(target, value); // filter\n                                }\n                                else switch(TYPE){\n                                    case 4:\n                                        return false; // every\n                                    case 7:\n                                        push.call(target, value); // filterReject\n                                }\n                            }\n                        }\n                        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n                    };\n                };\n                module1.exports = {\n                    // `Array.prototype.forEach` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.foreach\n                    forEach: createMethod(0),\n                    // `Array.prototype.map` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.map\n                    map: createMethod(1),\n                    // `Array.prototype.filter` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.filter\n                    filter: createMethod(2),\n                    // `Array.prototype.some` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.some\n                    some: createMethod(3),\n                    // `Array.prototype.every` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.every\n                    every: createMethod(4),\n                    // `Array.prototype.find` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.find\n                    find: createMethod(5),\n                    // `Array.prototype.findIndex` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n                    findIndex: createMethod(6),\n                    // `Array.prototype.filterReject` method\n                    // https://github.com/tc39/proposal-array-filtering\n                    filterReject: createMethod(7)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-method-has-species-support.js\": /*!****************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!\n  \\****************************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_83087__) {\n                var fails = __nested_webpack_require_83087__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var wellKnownSymbol = __nested_webpack_require_83087__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var V8_VERSION = __nested_webpack_require_83087__(/*! ../internals/engine-v8-version */ \"./node_modules/core-js/internals/engine-v8-version.js\");\n                var SPECIES = wellKnownSymbol(\"species\");\n                module1.exports = function(METHOD_NAME) {\n                    // We can't use this feature detection in V8 since it causes\n                    // deoptimization and serious performance degradation\n                    // https://github.com/zloirock/core-js/issues/677\n                    return V8_VERSION >= 51 || !fails(function() {\n                        var array = [];\n                        var constructor = array.constructor = {};\n                        constructor[SPECIES] = function() {\n                            return {\n                                foo: 1\n                            };\n                        };\n                        return array[METHOD_NAME](Boolean).foo !== 1;\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-method-is-strict.js\": /*!******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-method-is-strict.js ***!\n  \\******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_84720__) {\n                \"use strict\";\n                var fails = __nested_webpack_require_84720__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                module1.exports = function(METHOD_NAME, argument) {\n                    var method = [][METHOD_NAME];\n                    return !!method && fails(function() {\n                        // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing\n                        method.call(null, argument || function() {\n                            throw 1;\n                        }, 1);\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-species-constructor.js\": /*!*********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-species-constructor.js ***!\n  \\*********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_85734__) {\n                var isObject = __nested_webpack_require_85734__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isArray = __nested_webpack_require_85734__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var wellKnownSymbol = __nested_webpack_require_85734__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var SPECIES = wellKnownSymbol(\"species\");\n                // a part of `ArraySpeciesCreate` abstract operation\n                // https://tc39.es/ecma262/#sec-arrayspeciescreate\n                module1.exports = function(originalArray) {\n                    var C;\n                    if (isArray(originalArray)) {\n                        C = originalArray.constructor;\n                        // cross-realm fallback\n                        if (typeof C == \"function\" && (C === Array || isArray(C.prototype))) C = undefined;\n                        else if (isObject(C)) {\n                            C = C[SPECIES];\n                            if (C === null) C = undefined;\n                        }\n                    }\n                    return C === undefined ? Array : C;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-species-create.js\": /*!****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-species-create.js ***!\n  \\****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_87344__) {\n                var arraySpeciesConstructor = __nested_webpack_require_87344__(/*! ../internals/array-species-constructor */ \"./node_modules/core-js/internals/array-species-constructor.js\");\n                // `ArraySpeciesCreate` abstract operation\n                // https://tc39.es/ecma262/#sec-arrayspeciescreate\n                module1.exports = function(originalArray, length) {\n                    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/classof-raw.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/classof-raw.js ***!\n  \\*******************************************************/ /***/ function(module1) {\n                var toString = {}.toString;\n                module1.exports = function(it) {\n                    return toString.call(it).slice(8, -1);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/classof.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/internals/classof.js ***!\n  \\***************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_88633__) {\n                var TO_STRING_TAG_SUPPORT = __nested_webpack_require_88633__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\n                var classofRaw = __nested_webpack_require_88633__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                var wellKnownSymbol = __nested_webpack_require_88633__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                // ES3 wrong here\n                var CORRECT_ARGUMENTS = classofRaw(function() {\n                    return arguments;\n                }()) == \"Arguments\";\n                // fallback for IE11 Script Access Denied error\n                var tryGet = function(it, key) {\n                    try {\n                        return it[key];\n                    } catch (error) {}\n                };\n                // getting tag from ES6+ `Object.prototype.toString`\n                module1.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n                    var O, tag, result;\n                    return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == \"Object\" && typeof O.callee == \"function\" ? \"Arguments\" : result;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/copy-constructor-properties.js\": /*!***********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!\n  \\***********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_90479__) {\n                var has = __nested_webpack_require_90479__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var ownKeys = __nested_webpack_require_90479__(/*! ../internals/own-keys */ \"./node_modules/core-js/internals/own-keys.js\");\n                var getOwnPropertyDescriptorModule = __nested_webpack_require_90479__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\");\n                var definePropertyModule = __nested_webpack_require_90479__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                module1.exports = function(target, source) {\n                    var keys = ownKeys(source);\n                    var defineProperty = definePropertyModule.f;\n                    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n                    for(var i = 0; i < keys.length; i++){\n                        var key = keys[i];\n                        if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/correct-prototype-getter.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!\n  \\********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_92006__) {\n                var fails = __nested_webpack_require_92006__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                module1.exports = !fails(function() {\n                    function F() {}\n                    F.prototype.constructor = null;\n                    // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n                    return Object.getPrototypeOf(new F()) !== F.prototype;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-html.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-html.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_92808__) {\n                var requireObjectCoercible = __nested_webpack_require_92808__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                var toString = __nested_webpack_require_92808__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var quot = /\"/g;\n                // `CreateHTML` abstract operation\n                // https://tc39.es/ecma262/#sec-createhtml\n                module1.exports = function(string, tag, attribute, value) {\n                    var S = toString(requireObjectCoercible(string));\n                    var p1 = \"<\" + tag;\n                    if (attribute !== \"\") p1 += \" \" + attribute + '=\"' + toString(value).replace(quot, \"&quot;\") + '\"';\n                    return p1 + \">\" + S + \"</\" + tag + \">\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-iterator-constructor.js\": /*!***********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!\n  \\***********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_94051__) {\n                \"use strict\";\n                var IteratorPrototype = __nested_webpack_require_94051__(/*! ../internals/iterators-core */ \"./node_modules/core-js/internals/iterators-core.js\").IteratorPrototype;\n                var create = __nested_webpack_require_94051__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var createPropertyDescriptor = __nested_webpack_require_94051__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                var setToStringTag = __nested_webpack_require_94051__(/*! ../internals/set-to-string-tag */ \"./node_modules/core-js/internals/set-to-string-tag.js\");\n                var Iterators = __nested_webpack_require_94051__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\n                var returnThis = function() {\n                    return this;\n                };\n                module1.exports = function(IteratorConstructor, NAME, next) {\n                    var TO_STRING_TAG = NAME + \" Iterator\";\n                    IteratorConstructor.prototype = create(IteratorPrototype, {\n                        next: createPropertyDescriptor(1, next)\n                    });\n                    setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n                    Iterators[TO_STRING_TAG] = returnThis;\n                    return IteratorConstructor;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-non-enumerable-property.js\": /*!**************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!\n  \\**************************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_95888__) {\n                var DESCRIPTORS = __nested_webpack_require_95888__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var definePropertyModule = __nested_webpack_require_95888__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var createPropertyDescriptor = __nested_webpack_require_95888__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                module1.exports = DESCRIPTORS ? function(object, key, value) {\n                    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n                } : function(object, key, value) {\n                    object[key] = value;\n                    return object;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-property-descriptor.js\": /*!**********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!\n  \\**********************************************************************/ /***/ function(module1) {\n                module1.exports = function(bitmap, value) {\n                    return {\n                        enumerable: !(bitmap & 1),\n                        configurable: !(bitmap & 2),\n                        writable: !(bitmap & 4),\n                        value: value\n                    };\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-property.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-property.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_97741__) {\n                \"use strict\";\n                var toPropertyKey = __nested_webpack_require_97741__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                var definePropertyModule = __nested_webpack_require_97741__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var createPropertyDescriptor = __nested_webpack_require_97741__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                module1.exports = function(object, key, value) {\n                    var propertyKey = toPropertyKey(key);\n                    if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n                    else object[propertyKey] = value;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/define-iterator.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/define-iterator.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_98954__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_98954__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var createIteratorConstructor = __nested_webpack_require_98954__(/*! ../internals/create-iterator-constructor */ \"./node_modules/core-js/internals/create-iterator-constructor.js\");\n                var getPrototypeOf = __nested_webpack_require_98954__(/*! ../internals/object-get-prototype-of */ \"./node_modules/core-js/internals/object-get-prototype-of.js\");\n                var setPrototypeOf = __nested_webpack_require_98954__(/*! ../internals/object-set-prototype-of */ \"./node_modules/core-js/internals/object-set-prototype-of.js\");\n                var setToStringTag = __nested_webpack_require_98954__(/*! ../internals/set-to-string-tag */ \"./node_modules/core-js/internals/set-to-string-tag.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_98954__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var redefine = __nested_webpack_require_98954__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var wellKnownSymbol = __nested_webpack_require_98954__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var IS_PURE = __nested_webpack_require_98954__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var Iterators = __nested_webpack_require_98954__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\n                var IteratorsCore = __nested_webpack_require_98954__(/*! ../internals/iterators-core */ \"./node_modules/core-js/internals/iterators-core.js\");\n                var IteratorPrototype = IteratorsCore.IteratorPrototype;\n                var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\n                var ITERATOR = wellKnownSymbol(\"iterator\");\n                var KEYS = \"keys\";\n                var VALUES = \"values\";\n                var ENTRIES = \"entries\";\n                var returnThis = function() {\n                    return this;\n                };\n                module1.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n                    createIteratorConstructor(IteratorConstructor, NAME, next);\n                    var getIterationMethod = function(KIND) {\n                        if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n                        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n                        switch(KIND){\n                            case KEYS:\n                                return function keys() {\n                                    return new IteratorConstructor(this, KIND);\n                                };\n                            case VALUES:\n                                return function values() {\n                                    return new IteratorConstructor(this, KIND);\n                                };\n                            case ENTRIES:\n                                return function entries() {\n                                    return new IteratorConstructor(this, KIND);\n                                };\n                        }\n                        return function() {\n                            return new IteratorConstructor(this);\n                        };\n                    };\n                    var TO_STRING_TAG = NAME + \" Iterator\";\n                    var INCORRECT_VALUES_NAME = false;\n                    var IterablePrototype = Iterable.prototype;\n                    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype[\"@@iterator\"] || DEFAULT && IterablePrototype[DEFAULT];\n                    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n                    var anyNativeIterator = NAME == \"Array\" ? IterablePrototype.entries || nativeIterator : nativeIterator;\n                    var CurrentIteratorPrototype, methods, KEY;\n                    // fix native\n                    if (anyNativeIterator) {\n                        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n                        if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n                            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n                                if (setPrototypeOf) {\n                                    setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n                                } else if (typeof CurrentIteratorPrototype[ITERATOR] != \"function\") {\n                                    createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);\n                                }\n                            }\n                            // Set @@toStringTag to native iterators\n                            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n                            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n                        }\n                    }\n                    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n                    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n                        INCORRECT_VALUES_NAME = true;\n                        defaultIterator = function values() {\n                            return nativeIterator.call(this);\n                        };\n                    }\n                    // define iterator\n                    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n                        createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);\n                    }\n                    Iterators[NAME] = defaultIterator;\n                    // export additional methods\n                    if (DEFAULT) {\n                        methods = {\n                            values: getIterationMethod(VALUES),\n                            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n                            entries: getIterationMethod(ENTRIES)\n                        };\n                        if (FORCED) for(KEY in methods){\n                            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n                                redefine(IterablePrototype, KEY, methods[KEY]);\n                            }\n                        }\n                        else $({\n                            target: NAME,\n                            proto: true,\n                            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME\n                        }, methods);\n                    }\n                    return methods;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/define-well-known-symbol.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/define-well-known-symbol.js ***!\n  \\********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_106255__) {\n                var path = __nested_webpack_require_106255__(/*! ../internals/path */ \"./node_modules/core-js/internals/path.js\");\n                var has = __nested_webpack_require_106255__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var wrappedWellKnownSymbolModule = __nested_webpack_require_106255__(/*! ../internals/well-known-symbol-wrapped */ \"./node_modules/core-js/internals/well-known-symbol-wrapped.js\");\n                var defineProperty = __nested_webpack_require_106255__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                module1.exports = function(NAME) {\n                    var Symbol1 = path.Symbol || (path.Symbol = {});\n                    if (!has(Symbol1, NAME)) defineProperty(Symbol1, NAME, {\n                        value: wrappedWellKnownSymbolModule.f(NAME)\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/descriptors.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/descriptors.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_107487__) {\n                var fails = __nested_webpack_require_107487__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                // Detect IE8's incomplete defineProperty implementation\n                module1.exports = !fails(function() {\n                    // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n                    return Object.defineProperty({}, 1, {\n                        get: function() {\n                            return 7;\n                        }\n                    })[1] != 7;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/document-create-element.js\": /*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/document-create-element.js ***!\n  \\*******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_108443__) {\n                var global1 = __nested_webpack_require_108443__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var isObject = __nested_webpack_require_108443__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var document1 = global1.document;\n                // typeof document.createElement is 'object' in old IE\n                var EXISTS = isObject(document1) && isObject(document1.createElement);\n                module1.exports = function(it) {\n                    return EXISTS ? document1.createElement(it) : {};\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/dom-iterables.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/dom-iterables.js ***!\n  \\*********************************************************/ /***/ function(module1) {\n                // iterable DOM collections\n                // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\n                module1.exports = {\n                    CSSRuleList: 0,\n                    CSSStyleDeclaration: 0,\n                    CSSValueList: 0,\n                    ClientRectList: 0,\n                    DOMRectList: 0,\n                    DOMStringList: 0,\n                    DOMTokenList: 1,\n                    DataTransferItemList: 0,\n                    FileList: 0,\n                    HTMLAllCollection: 0,\n                    HTMLCollection: 0,\n                    HTMLFormElement: 0,\n                    HTMLSelectElement: 0,\n                    MediaList: 0,\n                    MimeTypeArray: 0,\n                    NamedNodeMap: 0,\n                    NodeList: 1,\n                    PaintRequestList: 0,\n                    Plugin: 0,\n                    PluginArray: 0,\n                    SVGLengthList: 0,\n                    SVGNumberList: 0,\n                    SVGPathSegList: 0,\n                    SVGPointList: 0,\n                    SVGStringList: 0,\n                    SVGTransformList: 0,\n                    SourceBufferList: 0,\n                    StyleSheetList: 0,\n                    TextTrackCueList: 0,\n                    TextTrackList: 0,\n                    TouchList: 0\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/engine-user-agent.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_111095__) {\n                var getBuiltIn = __nested_webpack_require_111095__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                module1.exports = getBuiltIn(\"navigator\", \"userAgent\") || \"\";\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/engine-v8-version.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_111681__) {\n                var global1 = __nested_webpack_require_111681__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var userAgent = __nested_webpack_require_111681__(/*! ../internals/engine-user-agent */ \"./node_modules/core-js/internals/engine-user-agent.js\");\n                var process1 = global1.process;\n                var Deno = global1.Deno;\n                var versions = process1 && process1.versions || Deno && Deno.version;\n                var v8 = versions && versions.v8;\n                var match, version;\n                if (v8) {\n                    match = v8.split(\".\");\n                    version = match[0] < 4 ? 1 : match[0] + match[1];\n                } else if (userAgent) {\n                    match = userAgent.match(/Edge\\/(\\d+)/);\n                    if (!match || match[1] >= 74) {\n                        match = userAgent.match(/Chrome\\/(\\d+)/);\n                        if (match) version = match[1];\n                    }\n                }\n                module1.exports = version && +version;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/enum-bug-keys.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!\n  \\*********************************************************/ /***/ function(module1) {\n                // IE8- don't enum bug keys\n                module1.exports = [\n                    \"constructor\",\n                    \"hasOwnProperty\",\n                    \"isPrototypeOf\",\n                    \"propertyIsEnumerable\",\n                    \"toLocaleString\",\n                    \"toString\",\n                    \"valueOf\"\n                ];\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/export.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/export.js ***!\n  \\**************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_113705__) {\n                var global1 = __nested_webpack_require_113705__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var getOwnPropertyDescriptor = __nested_webpack_require_113705__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\").f;\n                var createNonEnumerableProperty = __nested_webpack_require_113705__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var redefine = __nested_webpack_require_113705__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var setGlobal = __nested_webpack_require_113705__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\n                var copyConstructorProperties = __nested_webpack_require_113705__(/*! ../internals/copy-constructor-properties */ \"./node_modules/core-js/internals/copy-constructor-properties.js\");\n                var isForced = __nested_webpack_require_113705__(/*! ../internals/is-forced */ \"./node_modules/core-js/internals/is-forced.js\");\n                /*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/ module1.exports = function(options, source) {\n                    var TARGET = options.target;\n                    var GLOBAL = options.global;\n                    var STATIC = options.stat;\n                    var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n                    if (GLOBAL) {\n                        target = global1;\n                    } else if (STATIC) {\n                        target = global1[TARGET] || setGlobal(TARGET, {});\n                    } else {\n                        target = (global1[TARGET] || {}).prototype;\n                    }\n                    if (target) for(key in source){\n                        sourceProperty = source[key];\n                        if (options.noTargetGet) {\n                            descriptor = getOwnPropertyDescriptor(target, key);\n                            targetProperty = descriptor && descriptor.value;\n                        } else targetProperty = target[key];\n                        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n                        // contained in target\n                        if (!FORCED && targetProperty !== undefined) {\n                            if (typeof sourceProperty === typeof targetProperty) continue;\n                            copyConstructorProperties(sourceProperty, targetProperty);\n                        }\n                        // add a flag to not completely full polyfills\n                        if (options.sham || targetProperty && targetProperty.sham) {\n                            createNonEnumerableProperty(sourceProperty, \"sham\", true);\n                        }\n                        // extend global\n                        redefine(target, key, sourceProperty, options);\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/fails.js\": /*!*************************************************!*\\\n  !*** ./node_modules/core-js/internals/fails.js ***!\n  \\*************************************************/ /***/ function(module1) {\n                module1.exports = function(exec) {\n                    try {\n                        return !!exec();\n                    } catch (error) {\n                        return true;\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/function-bind-context.js\": /*!*****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/function-bind-context.js ***!\n  \\*****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_118366__) {\n                var aFunction = __nested_webpack_require_118366__(/*! ../internals/a-function */ \"./node_modules/core-js/internals/a-function.js\");\n                // optional / simple context binding\n                module1.exports = function(fn, that, length) {\n                    aFunction(fn);\n                    if (that === undefined) return fn;\n                    switch(length){\n                        case 0:\n                            return function() {\n                                return fn.call(that);\n                            };\n                        case 1:\n                            return function(a) {\n                                return fn.call(that, a);\n                            };\n                        case 2:\n                            return function(a, b) {\n                                return fn.call(that, a, b);\n                            };\n                        case 3:\n                            return function(a, b, c) {\n                                return fn.call(that, a, b, c);\n                            };\n                    }\n                    return function() {\n                        return fn.apply(that, arguments);\n                    };\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/get-built-in.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/get-built-in.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_119943__) {\n                var global1 = __nested_webpack_require_119943__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var aFunction = function(variable) {\n                    return typeof variable == \"function\" ? variable : undefined;\n                };\n                module1.exports = function(namespace, method) {\n                    return arguments.length < 2 ? aFunction(global1[namespace]) : global1[namespace] && global1[namespace][method];\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/global.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/global.js ***!\n  \\**************************************************/ /***/ function(module1) {\n                var check = function(it) {\n                    return it && it.Math == Math && it;\n                };\n                // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n                module1.exports = // eslint-disable-next-line es/no-global-this -- safe\n                check(typeof globalThis == \"object\" && globalThis) || check( false && 0) || // eslint-disable-next-line no-restricted-globals -- safe\n                check(typeof self == \"object\" && self) || check(typeof global == \"object\" && global) || // eslint-disable-next-line no-new-func -- fallback\n                function() {\n                    return this;\n                }() || Function(\"return this\")();\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/has.js\": /*!***********************************************!*\\\n  !*** ./node_modules/core-js/internals/has.js ***!\n  \\***********************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_121760__) {\n                var toObject = __nested_webpack_require_121760__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var hasOwnProperty = {}.hasOwnProperty;\n                module1.exports = Object.hasOwn || function hasOwn(it, key) {\n                    return hasOwnProperty.call(toObject(it), key);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/hidden-keys.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/hidden-keys.js ***!\n  \\*******************************************************/ /***/ function(module1) {\n                module1.exports = {};\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/html.js\": /*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/html.js ***!\n  \\************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_122764__) {\n                var getBuiltIn = __nested_webpack_require_122764__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                module1.exports = getBuiltIn(\"document\", \"documentElement\");\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/ie8-dom-define.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_123337__) {\n                var DESCRIPTORS = __nested_webpack_require_123337__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var fails = __nested_webpack_require_123337__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var createElement = __nested_webpack_require_123337__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\n                // Thank's IE8 for his funny defineProperty\n                module1.exports = !DESCRIPTORS && !fails(function() {\n                    // eslint-disable-next-line es/no-object-defineproperty -- requied for testing\n                    return Object.defineProperty(createElement(\"div\"), \"a\", {\n                        get: function() {\n                            return 7;\n                        }\n                    }).a != 7;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/indexed-object.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/indexed-object.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_124580__) {\n                var fails = __nested_webpack_require_124580__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var classof = __nested_webpack_require_124580__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                var split = \"\".split;\n                // fallback for non-array-like ES3 and non-enumerable old V8 strings\n                module1.exports = fails(function() {\n                    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n                    // eslint-disable-next-line no-prototype-builtins -- safe\n                    return !Object(\"z\").propertyIsEnumerable(0);\n                }) ? function(it) {\n                    return classof(it) == \"String\" ? split.call(it, \"\") : Object(it);\n                } : Object;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/inherit-if-required.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!\n  \\***************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_125777__) {\n                var isObject = __nested_webpack_require_125777__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var setPrototypeOf = __nested_webpack_require_125777__(/*! ../internals/object-set-prototype-of */ \"./node_modules/core-js/internals/object-set-prototype-of.js\");\n                // makes subclassing work correct for wrapped built-ins\n                module1.exports = function($this, dummy, Wrapper) {\n                    var NewTarget, NewTargetPrototype;\n                    if (// it can work only with native `setPrototypeOf`\n                    setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n                    typeof (NewTarget = dummy.constructor) == \"function\" && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);\n                    return $this;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/inspect-source.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/inspect-source.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_127112__) {\n                var store = __nested_webpack_require_127112__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n                var functionToString = Function.toString;\n                // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\n                if (typeof store.inspectSource != \"function\") {\n                    store.inspectSource = function(it) {\n                        return functionToString.call(it);\n                    };\n                }\n                module1.exports = store.inspectSource;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/internal-state.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/internal-state.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_128032__) {\n                var NATIVE_WEAK_MAP = __nested_webpack_require_128032__(/*! ../internals/native-weak-map */ \"./node_modules/core-js/internals/native-weak-map.js\");\n                var global1 = __nested_webpack_require_128032__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var isObject = __nested_webpack_require_128032__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_128032__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var objectHas = __nested_webpack_require_128032__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var shared = __nested_webpack_require_128032__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n                var sharedKey = __nested_webpack_require_128032__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var hiddenKeys = __nested_webpack_require_128032__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                var OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\n                var WeakMap = global1.WeakMap;\n                var set, get, has;\n                var enforce = function(it) {\n                    return has(it) ? get(it) : set(it, {});\n                };\n                var getterFor = function(TYPE) {\n                    return function(it) {\n                        var state;\n                        if (!isObject(it) || (state = get(it)).type !== TYPE) {\n                            throw TypeError(\"Incompatible receiver, \" + TYPE + \" required\");\n                        }\n                        return state;\n                    };\n                };\n                if (NATIVE_WEAK_MAP || shared.state) {\n                    var store = shared.state || (shared.state = new WeakMap());\n                    var wmget = store.get;\n                    var wmhas = store.has;\n                    var wmset = store.set;\n                    set = function(it, metadata) {\n                        if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n                        metadata.facade = it;\n                        wmset.call(store, it, metadata);\n                        return metadata;\n                    };\n                    get = function(it) {\n                        return wmget.call(store, it) || {};\n                    };\n                    has = function(it) {\n                        return wmhas.call(store, it);\n                    };\n                } else {\n                    var STATE = sharedKey(\"state\");\n                    hiddenKeys[STATE] = true;\n                    set = function(it, metadata) {\n                        if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n                        metadata.facade = it;\n                        createNonEnumerableProperty(it, STATE, metadata);\n                        return metadata;\n                    };\n                    get = function(it) {\n                        return objectHas(it, STATE) ? it[STATE] : {};\n                    };\n                    has = function(it) {\n                        return objectHas(it, STATE);\n                    };\n                }\n                module1.exports = {\n                    set: set,\n                    get: get,\n                    has: has,\n                    enforce: enforce,\n                    getterFor: getterFor\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-array.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-array.js ***!\n  \\****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_131952__) {\n                var classof = __nested_webpack_require_131952__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                // `IsArray` abstract operation\n                // https://tc39.es/ecma262/#sec-isarray\n                // eslint-disable-next-line es/no-array-isarray -- safe\n                module1.exports = Array.isArray || function isArray(arg) {\n                    return classof(arg) == \"Array\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-forced.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-forced.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_132745__) {\n                var fails = __nested_webpack_require_132745__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var replacement = /#|\\.prototype\\./;\n                var isForced = function(feature, detection) {\n                    var value = data[normalize(feature)];\n                    return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == \"function\" ? fails(detection) : !!detection;\n                };\n                var normalize = isForced.normalize = function(string) {\n                    return String(string).replace(replacement, \".\").toLowerCase();\n                };\n                var data = isForced.data = {};\n                var NATIVE = isForced.NATIVE = \"N\";\n                var POLYFILL = isForced.POLYFILL = \"P\";\n                module1.exports = isForced;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-object.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-object.js ***!\n  \\*****************************************************/ /***/ function(module1) {\n                module1.exports = function(it) {\n                    return typeof it === \"object\" ? it !== null : typeof it === \"function\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-pure.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-pure.js ***!\n  \\***************************************************/ /***/ function(module1) {\n                module1.exports = false;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-symbol.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-symbol.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_134685__) {\n                var getBuiltIn = __nested_webpack_require_134685__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                var USE_SYMBOL_AS_UID = __nested_webpack_require_134685__(/*! ../internals/use-symbol-as-uid */ \"./node_modules/core-js/internals/use-symbol-as-uid.js\");\n                module1.exports = USE_SYMBOL_AS_UID ? function(it) {\n                    return typeof it == \"symbol\";\n                } : function(it) {\n                    var $Symbol = getBuiltIn(\"Symbol\");\n                    return typeof $Symbol == \"function\" && Object(it) instanceof $Symbol;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/iterators-core.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/iterators-core.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_135656__) {\n                \"use strict\";\n                var fails = __nested_webpack_require_135656__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var getPrototypeOf = __nested_webpack_require_135656__(/*! ../internals/object-get-prototype-of */ \"./node_modules/core-js/internals/object-get-prototype-of.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_135656__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var has = __nested_webpack_require_135656__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var wellKnownSymbol = __nested_webpack_require_135656__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var IS_PURE = __nested_webpack_require_135656__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var ITERATOR = wellKnownSymbol(\"iterator\");\n                var BUGGY_SAFARI_ITERATORS = false;\n                var returnThis = function() {\n                    return this;\n                };\n                // `%IteratorPrototype%` object\n                // https://tc39.es/ecma262/#sec-%iteratorprototype%-object\n                var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n                /* eslint-disable es/no-array-prototype-keys -- safe */ if ([].keys) {\n                    arrayIterator = [].keys();\n                    // Safari 8 has buggy iterators w/o `next`\n                    if (!(\"next\" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n                    else {\n                        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n                        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n                    }\n                }\n                var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function() {\n                    var test = {};\n                    // FF44- legacy iterators case\n                    return IteratorPrototype[ITERATOR].call(test) !== test;\n                });\n                if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\n                // `%IteratorPrototype%[@@iterator]()` method\n                // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\n                if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {\n                    createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n                }\n                module1.exports = {\n                    IteratorPrototype: IteratorPrototype,\n                    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/iterators.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/iterators.js ***!\n  \\*****************************************************/ /***/ function(module1) {\n                module1.exports = {};\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/native-symbol.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/native-symbol.js ***!\n  \\*********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_139127__) {\n                /* eslint-disable es/no-symbol -- required for testing */ var V8_VERSION = __nested_webpack_require_139127__(/*! ../internals/engine-v8-version */ \"./node_modules/core-js/internals/engine-v8-version.js\");\n                var fails = __nested_webpack_require_139127__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\n                module1.exports = !!Object.getOwnPropertySymbols && !fails(function() {\n                    var symbol = Symbol();\n                    // Chrome 38 Symbol has incorrect toString conversion\n                    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n                    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n                    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/native-weak-map.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/native-weak-map.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_140494__) {\n                var global1 = __nested_webpack_require_140494__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var inspectSource = __nested_webpack_require_140494__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\n                var WeakMap = global1.WeakMap;\n                module1.exports = typeof WeakMap === \"function\" && /native code/.test(inspectSource(WeakMap));\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-assign.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-assign.js ***!\n  \\*********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_141275__) {\n                \"use strict\";\n                var DESCRIPTORS = __nested_webpack_require_141275__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var fails = __nested_webpack_require_141275__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var objectKeys = __nested_webpack_require_141275__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                var getOwnPropertySymbolsModule = __nested_webpack_require_141275__(/*! ../internals/object-get-own-property-symbols */ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\");\n                var propertyIsEnumerableModule = __nested_webpack_require_141275__(/*! ../internals/object-property-is-enumerable */ \"./node_modules/core-js/internals/object-property-is-enumerable.js\");\n                var toObject = __nested_webpack_require_141275__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var IndexedObject = __nested_webpack_require_141275__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                // eslint-disable-next-line es/no-object-assign -- safe\n                var $assign = Object.assign;\n                // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n                var defineProperty = Object.defineProperty;\n                // `Object.assign` method\n                // https://tc39.es/ecma262/#sec-object.assign\n                module1.exports = !$assign || fails(function() {\n                    // should have correct order of operations (Edge bug)\n                    if (DESCRIPTORS && $assign({\n                        b: 1\n                    }, $assign(defineProperty({}, \"a\", {\n                        enumerable: true,\n                        get: function() {\n                            defineProperty(this, \"b\", {\n                                value: 3,\n                                enumerable: false\n                            });\n                        }\n                    }), {\n                        b: 2\n                    })).b !== 1) return true;\n                    // should work with symbols and should have deterministic property order (V8 bug)\n                    var A = {};\n                    var B = {};\n                    // eslint-disable-next-line es/no-symbol -- safe\n                    var symbol = Symbol();\n                    var alphabet = \"abcdefghijklmnopqrst\";\n                    A[symbol] = 7;\n                    alphabet.split(\"\").forEach(function(chr) {\n                        B[chr] = chr;\n                    });\n                    return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join(\"\") != alphabet;\n                }) ? function assign(target, source) {\n                    var T = toObject(target);\n                    var argumentsLength = arguments.length;\n                    var index = 1;\n                    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n                    var propertyIsEnumerable = propertyIsEnumerableModule.f;\n                    while(argumentsLength > index){\n                        var S = IndexedObject(arguments[index++]);\n                        var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n                        var length = keys.length;\n                        var j = 0;\n                        var key;\n                        while(length > j){\n                            key = keys[j++];\n                            if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n                        }\n                    }\n                    return T;\n                } : $assign;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-create.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-create.js ***!\n  \\*********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_145366__) {\n                /* global ActiveXObject -- old IE, WSH */ var anObject = __nested_webpack_require_145366__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var defineProperties = __nested_webpack_require_145366__(/*! ../internals/object-define-properties */ \"./node_modules/core-js/internals/object-define-properties.js\");\n                var enumBugKeys = __nested_webpack_require_145366__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n                var hiddenKeys = __nested_webpack_require_145366__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                var html = __nested_webpack_require_145366__(/*! ../internals/html */ \"./node_modules/core-js/internals/html.js\");\n                var documentCreateElement = __nested_webpack_require_145366__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\n                var sharedKey = __nested_webpack_require_145366__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var GT = \">\";\n                var LT = \"<\";\n                var PROTOTYPE = \"prototype\";\n                var SCRIPT = \"script\";\n                var IE_PROTO = sharedKey(\"IE_PROTO\");\n                var EmptyConstructor = function() {};\n                var scriptTag = function(content) {\n                    return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n                };\n                // Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n                var NullProtoObjectViaActiveX = function(activeXDocument) {\n                    activeXDocument.write(scriptTag(\"\"));\n                    activeXDocument.close();\n                    var temp = activeXDocument.parentWindow.Object;\n                    activeXDocument = null; // avoid memory leak\n                    return temp;\n                };\n                // Create object with fake `null` prototype: use iframe Object with cleared prototype\n                var NullProtoObjectViaIFrame = function() {\n                    // Thrash, waste and sodomy: IE GC bug\n                    var iframe = documentCreateElement(\"iframe\");\n                    var JS = \"java\" + SCRIPT + \":\";\n                    var iframeDocument;\n                    if (iframe.style) {\n                        iframe.style.display = \"none\";\n                        html.appendChild(iframe);\n                        // https://github.com/zloirock/core-js/issues/475\n                        iframe.src = String(JS);\n                        iframeDocument = iframe.contentWindow.document;\n                        iframeDocument.open();\n                        iframeDocument.write(scriptTag(\"document.F=Object\"));\n                        iframeDocument.close();\n                        return iframeDocument.F;\n                    }\n                };\n                // Check for document.domain and active x support\n                // No need to use active x approach when document.domain is not set\n                // see https://github.com/es-shims/es5-shim/issues/150\n                // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n                // avoid IE GC bug\n                var activeXDocument;\n                var NullProtoObject = function() {\n                    try {\n                        activeXDocument = new ActiveXObject(\"htmlfile\");\n                    } catch (error) {}\n                    NullProtoObject = document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() || NullProtoObjectViaActiveX(activeXDocument); // WSH\n                    var length = enumBugKeys.length;\n                    while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n                    return NullProtoObject();\n                };\n                hiddenKeys[IE_PROTO] = true;\n                // `Object.create` method\n                // https://tc39.es/ecma262/#sec-object.create\n                module1.exports = Object.create || function create(O, Properties) {\n                    var result;\n                    if (O !== null) {\n                        EmptyConstructor[PROTOTYPE] = anObject(O);\n                        result = new EmptyConstructor();\n                        EmptyConstructor[PROTOTYPE] = null;\n                        // add \"__proto__\" for Object.getPrototypeOf polyfill\n                        result[IE_PROTO] = O;\n                    } else result = NullProtoObject();\n                    return Properties === undefined ? result : defineProperties(result, Properties);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-define-properties.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-define-properties.js ***!\n  \\********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_150431__) {\n                var DESCRIPTORS = __nested_webpack_require_150431__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var definePropertyModule = __nested_webpack_require_150431__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var anObject = __nested_webpack_require_150431__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var objectKeys = __nested_webpack_require_150431__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                // `Object.defineProperties` method\n                // https://tc39.es/ecma262/#sec-object.defineproperties\n                // eslint-disable-next-line es/no-object-defineproperties -- safe\n                module1.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n                    anObject(O);\n                    var keys = objectKeys(Properties);\n                    var length = keys.length;\n                    var index = 0;\n                    var key;\n                    while(length > index)definePropertyModule.f(O, key = keys[index++], Properties[key]);\n                    return O;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-define-property.js\": /*!******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-define-property.js ***!\n  \\******************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_152071__) {\n                var DESCRIPTORS = __nested_webpack_require_152071__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var IE8_DOM_DEFINE = __nested_webpack_require_152071__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\n                var anObject = __nested_webpack_require_152071__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var toPropertyKey = __nested_webpack_require_152071__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                // eslint-disable-next-line es/no-object-defineproperty -- safe\n                var $defineProperty = Object.defineProperty;\n                // `Object.defineProperty` method\n                // https://tc39.es/ecma262/#sec-object.defineproperty\n                exports1.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {\n                    anObject(O);\n                    P = toPropertyKey(P);\n                    anObject(Attributes);\n                    if (IE8_DOM_DEFINE) try {\n                        return $defineProperty(O, P, Attributes);\n                    } catch (error) {}\n                    if (\"get\" in Attributes || \"set\" in Attributes) throw TypeError(\"Accessors not supported\");\n                    if (\"value\" in Attributes) O[P] = Attributes.value;\n                    return O;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\": /*!******************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!\n  \\******************************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_153939__) {\n                var DESCRIPTORS = __nested_webpack_require_153939__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var propertyIsEnumerableModule = __nested_webpack_require_153939__(/*! ../internals/object-property-is-enumerable */ \"./node_modules/core-js/internals/object-property-is-enumerable.js\");\n                var createPropertyDescriptor = __nested_webpack_require_153939__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                var toIndexedObject = __nested_webpack_require_153939__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var toPropertyKey = __nested_webpack_require_153939__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                var has = __nested_webpack_require_153939__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var IE8_DOM_DEFINE = __nested_webpack_require_153939__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\n                // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n                var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n                // `Object.getOwnPropertyDescriptor` method\n                // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n                exports1.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n                    O = toIndexedObject(O);\n                    P = toPropertyKey(P);\n                    if (IE8_DOM_DEFINE) try {\n                        return $getOwnPropertyDescriptor(O, P);\n                    } catch (error) {}\n                    if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-names-external.js\": /*!**********************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!\n  \\**********************************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_156257__) {\n                /* eslint-disable es/no-object-getownpropertynames -- safe */ var toIndexedObject = __nested_webpack_require_156257__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var $getOwnPropertyNames = __nested_webpack_require_156257__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\").f;\n                var toString = {}.toString;\n                var windowNames =  false ? 0 : [];\n                var getWindowNames = function(it) {\n                    try {\n                        return $getOwnPropertyNames(it);\n                    } catch (error) {\n                        return windowNames.slice();\n                    }\n                };\n                // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n                module1.exports.f = function getOwnPropertyNames(it) {\n                    return windowNames && toString.call(it) == \"[object Window]\" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-names.js\": /*!*************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!\n  \\*************************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_157856__) {\n                var internalObjectKeys = __nested_webpack_require_157856__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\n                var enumBugKeys = __nested_webpack_require_157856__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n                var hiddenKeys = enumBugKeys.concat(\"length\", \"prototype\");\n                // `Object.getOwnPropertyNames` method\n                // https://tc39.es/ecma262/#sec-object.getownpropertynames\n                // eslint-disable-next-line es/no-object-getownpropertynames -- safe\n                exports1.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n                    return internalObjectKeys(O, hiddenKeys);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\": /*!***************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!\n  \\***************************************************************************/ /***/ function(__unused_webpack_module, exports1) {\n                // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\n                exports1.f = Object.getOwnPropertySymbols;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-prototype-of.js\": /*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!\n  \\*******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_159569__) {\n                var has = __nested_webpack_require_159569__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var toObject = __nested_webpack_require_159569__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var sharedKey = __nested_webpack_require_159569__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var CORRECT_PROTOTYPE_GETTER = __nested_webpack_require_159569__(/*! ../internals/correct-prototype-getter */ \"./node_modules/core-js/internals/correct-prototype-getter.js\");\n                var IE_PROTO = sharedKey(\"IE_PROTO\");\n                var ObjectPrototype = Object.prototype;\n                // `Object.getPrototypeOf` method\n                // https://tc39.es/ecma262/#sec-object.getprototypeof\n                // eslint-disable-next-line es/no-object-getprototypeof -- safe\n                module1.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {\n                    O = toObject(O);\n                    if (has(O, IE_PROTO)) return O[IE_PROTO];\n                    if (typeof O.constructor == \"function\" && O instanceof O.constructor) {\n                        return O.constructor.prototype;\n                    }\n                    return O instanceof Object ? ObjectPrototype : null;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-keys-internal.js\": /*!****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!\n  \\****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_161276__) {\n                var has = __nested_webpack_require_161276__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var toIndexedObject = __nested_webpack_require_161276__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var indexOf = __nested_webpack_require_161276__(/*! ../internals/array-includes */ \"./node_modules/core-js/internals/array-includes.js\").indexOf;\n                var hiddenKeys = __nested_webpack_require_161276__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                module1.exports = function(object, names) {\n                    var O = toIndexedObject(object);\n                    var i = 0;\n                    var result = [];\n                    var key;\n                    for(key in O)!has(hiddenKeys, key) && has(O, key) && result.push(key);\n                    // Don't enum bug & hidden keys\n                    while(names.length > i)if (has(O, key = names[i++])) {\n                        ~indexOf(result, key) || result.push(key);\n                    }\n                    return result;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-keys.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-keys.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_162745__) {\n                var internalObjectKeys = __nested_webpack_require_162745__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\n                var enumBugKeys = __nested_webpack_require_162745__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n                // `Object.keys` method\n                // https://tc39.es/ecma262/#sec-object.keys\n                // eslint-disable-next-line es/no-object-keys -- safe\n                module1.exports = Object.keys || function keys(O) {\n                    return internalObjectKeys(O, enumBugKeys);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-property-is-enumerable.js\": /*!*************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!\n  \\*************************************************************************/ /***/ function(__unused_webpack_module, exports1) {\n                \"use strict\";\n                var $propertyIsEnumerable = {}.propertyIsEnumerable;\n                // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n                var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n                // Nashorn ~ JDK8 bug\n                var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({\n                    1: 2\n                }, 1);\n                // `Object.prototype.propertyIsEnumerable` method implementation\n                // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n                exports1.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n                    var descriptor = getOwnPropertyDescriptor(this, V);\n                    return !!descriptor && descriptor.enumerable;\n                } : $propertyIsEnumerable;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-set-prototype-of.js\": /*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!\n  \\*******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_165032__) {\n                /* eslint-disable no-proto -- safe */ var anObject = __nested_webpack_require_165032__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var aPossiblePrototype = __nested_webpack_require_165032__(/*! ../internals/a-possible-prototype */ \"./node_modules/core-js/internals/a-possible-prototype.js\");\n                // `Object.setPrototypeOf` method\n                // https://tc39.es/ecma262/#sec-object.setprototypeof\n                // Works with __proto__ only. Old v8 can't work with null proto objects.\n                // eslint-disable-next-line es/no-object-setprototypeof -- safe\n                module1.exports = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n                    var CORRECT_SETTER = false;\n                    var test = {};\n                    var setter;\n                    try {\n                        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n                        setter = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set;\n                        setter.call(test, []);\n                        CORRECT_SETTER = test instanceof Array;\n                    } catch (error) {}\n                    return function setPrototypeOf(O, proto) {\n                        anObject(O);\n                        aPossiblePrototype(proto);\n                        if (CORRECT_SETTER) setter.call(O, proto);\n                        else O.__proto__ = proto;\n                        return O;\n                    };\n                }() : undefined);\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-to-string.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-to-string.js ***!\n  \\************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_166960__) {\n                \"use strict\";\n                var TO_STRING_TAG_SUPPORT = __nested_webpack_require_166960__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\n                var classof = __nested_webpack_require_166960__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\n                // `Object.prototype.toString` method implementation\n                // https://tc39.es/ecma262/#sec-object.prototype.tostring\n                module1.exports = TO_STRING_TAG_SUPPORT ? ({}).toString : function toString() {\n                    return \"[object \" + classof(this) + \"]\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/ordinary-to-primitive.js\": /*!*****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!\n  \\*****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_167988__) {\n                var isObject = __nested_webpack_require_167988__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                // `OrdinaryToPrimitive` abstract operation\n                // https://tc39.es/ecma262/#sec-ordinarytoprimitive\n                module1.exports = function(input, pref) {\n                    var fn, val;\n                    if (pref === \"string\" && typeof (fn = input.toString) == \"function\" && !isObject(val = fn.call(input))) return val;\n                    if (typeof (fn = input.valueOf) == \"function\" && !isObject(val = fn.call(input))) return val;\n                    if (pref !== \"string\" && typeof (fn = input.toString) == \"function\" && !isObject(val = fn.call(input))) return val;\n                    throw TypeError(\"Can't convert object to primitive value\");\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/own-keys.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/own-keys.js ***!\n  \\****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_169156__) {\n                var getBuiltIn = __nested_webpack_require_169156__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                var getOwnPropertyNamesModule = __nested_webpack_require_169156__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\");\n                var getOwnPropertySymbolsModule = __nested_webpack_require_169156__(/*! ../internals/object-get-own-property-symbols */ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\");\n                var anObject = __nested_webpack_require_169156__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                // all object keys, includes non-enumerable and symbols\n                module1.exports = getBuiltIn(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n                    var keys = getOwnPropertyNamesModule.f(anObject(it));\n                    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n                    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/path.js\": /*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/path.js ***!\n  \\************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_170560__) {\n                var global1 = __nested_webpack_require_170560__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                module1.exports = global1;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/redefine.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/redefine.js ***!\n  \\****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_171060__) {\n                var global1 = __nested_webpack_require_171060__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_171060__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var has = __nested_webpack_require_171060__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var setGlobal = __nested_webpack_require_171060__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\n                var inspectSource = __nested_webpack_require_171060__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\n                var InternalStateModule = __nested_webpack_require_171060__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var getInternalState = InternalStateModule.get;\n                var enforceInternalState = InternalStateModule.enforce;\n                var TEMPLATE = String(String).split(\"String\");\n                (module1.exports = function(O, key, value, options) {\n                    var unsafe = options ? !!options.unsafe : false;\n                    var simple = options ? !!options.enumerable : false;\n                    var noTargetGet = options ? !!options.noTargetGet : false;\n                    var state;\n                    if (typeof value == \"function\") {\n                        if (typeof key == \"string\" && !has(value, \"name\")) {\n                            createNonEnumerableProperty(value, \"name\", key);\n                        }\n                        state = enforceInternalState(value);\n                        if (!state.source) {\n                            state.source = TEMPLATE.join(typeof key == \"string\" ? key : \"\");\n                        }\n                    }\n                    if (O === global1) {\n                        if (simple) O[key] = value;\n                        else setGlobal(key, value);\n                        return;\n                    } else if (!unsafe) {\n                        delete O[key];\n                    } else if (!noTargetGet && O[key]) {\n                        simple = true;\n                    }\n                    if (simple) O[key] = value;\n                    else createNonEnumerableProperty(O, key, value);\n                // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n                })(Function.prototype, \"toString\", function toString() {\n                    return typeof this == \"function\" && getInternalState(this).source || inspectSource(this);\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/regexp-flags.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/regexp-flags.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_174097__) {\n                \"use strict\";\n                var anObject = __nested_webpack_require_174097__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                // `RegExp.prototype.flags` getter implementation\n                // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\n                module1.exports = function() {\n                    var that = anObject(this);\n                    var result = \"\";\n                    if (that.global) result += \"g\";\n                    if (that.ignoreCase) result += \"i\";\n                    if (that.multiline) result += \"m\";\n                    if (that.dotAll) result += \"s\";\n                    if (that.unicode) result += \"u\";\n                    if (that.sticky) result += \"y\";\n                    return result;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/require-object-coercible.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!\n  \\********************************************************************/ /***/ function(module1) {\n                // `RequireObjectCoercible` abstract operation\n                // https://tc39.es/ecma262/#sec-requireobjectcoercible\n                module1.exports = function(it) {\n                    if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/set-global.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/set-global.js ***!\n  \\******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_175916__) {\n                var global1 = __nested_webpack_require_175916__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                module1.exports = function(key, value) {\n                    try {\n                        // eslint-disable-next-line es/no-object-defineproperty -- safe\n                        Object.defineProperty(global1, key, {\n                            value: value,\n                            configurable: true,\n                            writable: true\n                        });\n                    } catch (error) {\n                        global1[key] = value;\n                    }\n                    return value;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/set-to-string-tag.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_176962__) {\n                var defineProperty = __nested_webpack_require_176962__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var has = __nested_webpack_require_176962__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var wellKnownSymbol = __nested_webpack_require_176962__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                module1.exports = function(it, TAG, STATIC) {\n                    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n                        defineProperty(it, TO_STRING_TAG, {\n                            configurable: true,\n                            value: TAG\n                        });\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/shared-key.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared-key.js ***!\n  \\******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_178168__) {\n                var shared = __nested_webpack_require_178168__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\n                var uid = __nested_webpack_require_178168__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\n                var keys = shared(\"keys\");\n                module1.exports = function(key) {\n                    return keys[key] || (keys[key] = uid(key));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/shared-store.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared-store.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_178930__) {\n                var global1 = __nested_webpack_require_178930__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var setGlobal = __nested_webpack_require_178930__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\n                var SHARED = \"__core-js_shared__\";\n                var store = global1[SHARED] || setGlobal(SHARED, {});\n                module1.exports = store;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/shared.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared.js ***!\n  \\**************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_179675__) {\n                var IS_PURE = __nested_webpack_require_179675__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var store = __nested_webpack_require_179675__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n                (module1.exports = function(key, value) {\n                    return store[key] || (store[key] = value !== undefined ? value : {});\n                })(\"versions\", []).push({\n                    version: \"3.16.0\",\n                    mode: IS_PURE ? \"pure\" : \"global\",\n                    copyright: \"\\xa9 2021 Denis Pushkarev (zloirock.ru)\"\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/string-html-forced.js\": /*!**************************************************************!*\\\n  !*** ./node_modules/core-js/internals/string-html-forced.js ***!\n  \\**************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_180685__) {\n                var fails = __nested_webpack_require_180685__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                // check the existence of a method, lowercase\n                // of a tag and escaping quotes in arguments\n                module1.exports = function(METHOD_NAME) {\n                    return fails(function() {\n                        var test = \"\"[METHOD_NAME]('\"');\n                        return test !== test.toLowerCase() || test.split('\"').length > 3;\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/string-multibyte.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/internals/string-multibyte.js ***!\n  \\************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_181587__) {\n                var toInteger = __nested_webpack_require_181587__(/*! ../internals/to-integer */ \"./node_modules/core-js/internals/to-integer.js\");\n                var toString = __nested_webpack_require_181587__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var requireObjectCoercible = __nested_webpack_require_181587__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                // `String.prototype.codePointAt` methods implementation\n                var createMethod = function(CONVERT_TO_STRING) {\n                    return function($this, pos) {\n                        var S = toString(requireObjectCoercible($this));\n                        var position = toInteger(pos);\n                        var size = S.length;\n                        var first, second;\n                        if (position < 0 || position >= size) return CONVERT_TO_STRING ? \"\" : undefined;\n                        first = S.charCodeAt(position);\n                        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n                    };\n                };\n                module1.exports = {\n                    // `String.prototype.codePointAt` method\n                    // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n                    codeAt: createMethod(false),\n                    // `String.prototype.at` method\n                    // https://github.com/mathiasbynens/String.prototype.at\n                    charAt: createMethod(true)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/string-trim.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/string-trim.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_183717__) {\n                var requireObjectCoercible = __nested_webpack_require_183717__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                var toString = __nested_webpack_require_183717__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var whitespaces = __nested_webpack_require_183717__(/*! ../internals/whitespaces */ \"./node_modules/core-js/internals/whitespaces.js\");\n                var whitespace = \"[\" + whitespaces + \"]\";\n                var ltrim = RegExp(\"^\" + whitespace + whitespace + \"*\");\n                var rtrim = RegExp(whitespace + whitespace + \"*$\");\n                // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\n                var createMethod = function(TYPE) {\n                    return function($this) {\n                        var string = toString(requireObjectCoercible($this));\n                        if (TYPE & 1) string = string.replace(ltrim, \"\");\n                        if (TYPE & 2) string = string.replace(rtrim, \"\");\n                        return string;\n                    };\n                };\n                module1.exports = {\n                    // `String.prototype.{ trimLeft, trimStart }` methods\n                    // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n                    start: createMethod(1),\n                    // `String.prototype.{ trimRight, trimEnd }` methods\n                    // https://tc39.es/ecma262/#sec-string.prototype.trimend\n                    end: createMethod(2),\n                    // `String.prototype.trim` method\n                    // https://tc39.es/ecma262/#sec-string.prototype.trim\n                    trim: createMethod(3)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-absolute-index.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_185858__) {\n                var toInteger = __nested_webpack_require_185858__(/*! ../internals/to-integer */ \"./node_modules/core-js/internals/to-integer.js\");\n                var max = Math.max;\n                var min = Math.min;\n                // Helper for a popular repeating case of the spec:\n                // Let integer be ? ToInteger(index).\n                // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n                module1.exports = function(index, length) {\n                    var integer = toInteger(index);\n                    return integer < 0 ? max(integer + length, 0) : min(integer, length);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-indexed-object.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_186894__) {\n                // toObject with fallback for non-array-like ES3 strings\n                var IndexedObject = __nested_webpack_require_186894__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                var requireObjectCoercible = __nested_webpack_require_186894__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                module1.exports = function(it) {\n                    return IndexedObject(requireObjectCoercible(it));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-integer.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-integer.js ***!\n  \\******************************************************/ /***/ function(module1) {\n                var ceil = Math.ceil;\n                var floor = Math.floor;\n                // `ToInteger` abstract operation\n                // https://tc39.es/ecma262/#sec-tointeger\n                module1.exports = function(argument) {\n                    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-length.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-length.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_188419__) {\n                var toInteger = __nested_webpack_require_188419__(/*! ../internals/to-integer */ \"./node_modules/core-js/internals/to-integer.js\");\n                var min = Math.min;\n                // `ToLength` abstract operation\n                // https://tc39.es/ecma262/#sec-tolength\n                module1.exports = function(argument) {\n                    return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-object.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-object.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_189231__) {\n                var requireObjectCoercible = __nested_webpack_require_189231__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                // `ToObject` abstract operation\n                // https://tc39.es/ecma262/#sec-toobject\n                module1.exports = function(argument) {\n                    return Object(requireObjectCoercible(argument));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-primitive.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-primitive.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_190004__) {\n                var isObject = __nested_webpack_require_190004__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isSymbol = __nested_webpack_require_190004__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                var ordinaryToPrimitive = __nested_webpack_require_190004__(/*! ../internals/ordinary-to-primitive */ \"./node_modules/core-js/internals/ordinary-to-primitive.js\");\n                var wellKnownSymbol = __nested_webpack_require_190004__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_PRIMITIVE = wellKnownSymbol(\"toPrimitive\");\n                // `ToPrimitive` abstract operation\n                // https://tc39.es/ecma262/#sec-toprimitive\n                module1.exports = function(input, pref) {\n                    if (!isObject(input) || isSymbol(input)) return input;\n                    var exoticToPrim = input[TO_PRIMITIVE];\n                    var result;\n                    if (exoticToPrim !== undefined) {\n                        if (pref === undefined) pref = \"default\";\n                        result = exoticToPrim.call(input, pref);\n                        if (!isObject(result) || isSymbol(result)) return result;\n                        throw TypeError(\"Can't convert object to primitive value\");\n                    }\n                    if (pref === undefined) pref = \"number\";\n                    return ordinaryToPrimitive(input, pref);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-property-key.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-property-key.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_191865__) {\n                var toPrimitive = __nested_webpack_require_191865__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\n                var isSymbol = __nested_webpack_require_191865__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                // `ToPropertyKey` abstract operation\n                // https://tc39.es/ecma262/#sec-topropertykey\n                module1.exports = function(argument) {\n                    var key = toPrimitive(argument, \"string\");\n                    return isSymbol(key) ? key : String(key);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-string-tag-support.js\": /*!*****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!\n  \\*****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_192836__) {\n                var wellKnownSymbol = __nested_webpack_require_192836__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                var test = {};\n                test[TO_STRING_TAG] = \"z\";\n                module1.exports = String(test) === \"[object z]\";\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-string.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-string.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_193534__) {\n                var isSymbol = __nested_webpack_require_193534__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                module1.exports = function(argument) {\n                    if (isSymbol(argument)) throw TypeError(\"Cannot convert a Symbol value to a string\");\n                    return String(argument);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/uid.js\": /*!***********************************************!*\\\n  !*** ./node_modules/core-js/internals/uid.js ***!\n  \\***********************************************/ /***/ function(module1) {\n                var id = 0;\n                var postfix = Math.random();\n                module1.exports = function(key) {\n                    return \"Symbol(\" + String(key === undefined ? \"\" : key) + \")_\" + (++id + postfix).toString(36);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/use-symbol-as-uid.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_194783__) {\n                /* eslint-disable es/no-symbol -- required for testing */ var NATIVE_SYMBOL = __nested_webpack_require_194783__(/*! ../internals/native-symbol */ \"./node_modules/core-js/internals/native-symbol.js\");\n                module1.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/well-known-symbol-wrapped.js\": /*!*********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/well-known-symbol-wrapped.js ***!\n  \\*********************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_195489__) {\n                var wellKnownSymbol = __nested_webpack_require_195489__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                exports1.f = wellKnownSymbol;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/well-known-symbol.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_196058__) {\n                var global1 = __nested_webpack_require_196058__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var shared = __nested_webpack_require_196058__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\n                var has = __nested_webpack_require_196058__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var uid = __nested_webpack_require_196058__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\n                var NATIVE_SYMBOL = __nested_webpack_require_196058__(/*! ../internals/native-symbol */ \"./node_modules/core-js/internals/native-symbol.js\");\n                var USE_SYMBOL_AS_UID = __nested_webpack_require_196058__(/*! ../internals/use-symbol-as-uid */ \"./node_modules/core-js/internals/use-symbol-as-uid.js\");\n                var WellKnownSymbolsStore = shared(\"wks\");\n                var Symbol1 = global1.Symbol;\n                var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol1 : Symbol1 && Symbol1.withoutSetter || uid;\n                module1.exports = function(name) {\n                    if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \"string\")) {\n                        if (NATIVE_SYMBOL && has(Symbol1, name)) {\n                            WellKnownSymbolsStore[name] = Symbol1[name];\n                        } else {\n                            WellKnownSymbolsStore[name] = createWellKnownSymbol(\"Symbol.\" + name);\n                        }\n                    }\n                    return WellKnownSymbolsStore[name];\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/whitespaces.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/whitespaces.js ***!\n  \\*******************************************************/ /***/ function(module1) {\n                // a string of all valid unicode whitespaces\n                module1.exports = \"\t\\n\\v\\f\\r \\xa0    \" + \"          　\\u2028\\u2029\\uFEFF\";\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.concat.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.concat.js ***!\n  \\*********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_198448__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_198448__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var fails = __nested_webpack_require_198448__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var isArray = __nested_webpack_require_198448__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var isObject = __nested_webpack_require_198448__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var toObject = __nested_webpack_require_198448__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var toLength = __nested_webpack_require_198448__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var createProperty = __nested_webpack_require_198448__(/*! ../internals/create-property */ \"./node_modules/core-js/internals/create-property.js\");\n                var arraySpeciesCreate = __nested_webpack_require_198448__(/*! ../internals/array-species-create */ \"./node_modules/core-js/internals/array-species-create.js\");\n                var arrayMethodHasSpeciesSupport = __nested_webpack_require_198448__(/*! ../internals/array-method-has-species-support */ \"./node_modules/core-js/internals/array-method-has-species-support.js\");\n                var wellKnownSymbol = __nested_webpack_require_198448__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var V8_VERSION = __nested_webpack_require_198448__(/*! ../internals/engine-v8-version */ \"./node_modules/core-js/internals/engine-v8-version.js\");\n                var IS_CONCAT_SPREADABLE = wellKnownSymbol(\"isConcatSpreadable\");\n                var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\n                var MAXIMUM_ALLOWED_INDEX_EXCEEDED = \"Maximum allowed index exceeded\";\n                // We can't use this feature detection in V8 since it causes\n                // deoptimization and serious performance degradation\n                // https://github.com/zloirock/core-js/issues/679\n                var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {\n                    var array = [];\n                    array[IS_CONCAT_SPREADABLE] = false;\n                    return array.concat()[0] !== array;\n                });\n                var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(\"concat\");\n                var isConcatSpreadable = function(O) {\n                    if (!isObject(O)) return false;\n                    var spreadable = O[IS_CONCAT_SPREADABLE];\n                    return spreadable !== undefined ? !!spreadable : isArray(O);\n                };\n                var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;\n                // `Array.prototype.concat` method\n                // https://tc39.es/ecma262/#sec-array.prototype.concat\n                // with adding support of @@isConcatSpreadable and @@species\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: FORCED\n                }, {\n                    // eslint-disable-next-line no-unused-vars -- required for `.length`\n                    concat: function concat(arg) {\n                        var O = toObject(this);\n                        var A = arraySpeciesCreate(O, 0);\n                        var n = 0;\n                        var i, k, length, len, E;\n                        for(i = -1, length = arguments.length; i < length; i++){\n                            E = i === -1 ? O : arguments[i];\n                            if (isConcatSpreadable(E)) {\n                                len = toLength(E.length);\n                                if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n                                for(k = 0; k < len; k++, n++)if (k in E) createProperty(A, n, E[k]);\n                            } else {\n                                if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n                                createProperty(A, n++, E);\n                            }\n                        }\n                        A.length = n;\n                        return A;\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.iterator.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_203057__) {\n                \"use strict\";\n                var toIndexedObject = __nested_webpack_require_203057__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var addToUnscopables = __nested_webpack_require_203057__(/*! ../internals/add-to-unscopables */ \"./node_modules/core-js/internals/add-to-unscopables.js\");\n                var Iterators = __nested_webpack_require_203057__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\n                var InternalStateModule = __nested_webpack_require_203057__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var defineIterator = __nested_webpack_require_203057__(/*! ../internals/define-iterator */ \"./node_modules/core-js/internals/define-iterator.js\");\n                var ARRAY_ITERATOR = \"Array Iterator\";\n                var setInternalState = InternalStateModule.set;\n                var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\n                // `Array.prototype.entries` method\n                // https://tc39.es/ecma262/#sec-array.prototype.entries\n                // `Array.prototype.keys` method\n                // https://tc39.es/ecma262/#sec-array.prototype.keys\n                // `Array.prototype.values` method\n                // https://tc39.es/ecma262/#sec-array.prototype.values\n                // `Array.prototype[@@iterator]` method\n                // https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n                // `CreateArrayIterator` internal method\n                // https://tc39.es/ecma262/#sec-createarrayiterator\n                module1.exports = defineIterator(Array, \"Array\", function(iterated, kind) {\n                    setInternalState(this, {\n                        type: ARRAY_ITERATOR,\n                        target: toIndexedObject(iterated),\n                        index: 0,\n                        kind: kind // kind\n                    });\n                // `%ArrayIteratorPrototype%.next` method\n                // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n                }, function() {\n                    var state = getInternalState(this);\n                    var target = state.target;\n                    var kind = state.kind;\n                    var index = state.index++;\n                    if (!target || index >= target.length) {\n                        state.target = undefined;\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                    if (kind == \"keys\") return {\n                        value: index,\n                        done: false\n                    };\n                    if (kind == \"values\") return {\n                        value: target[index],\n                        done: false\n                    };\n                    return {\n                        value: [\n                            index,\n                            target[index]\n                        ],\n                        done: false\n                    };\n                }, \"values\");\n                // argumentsList[@@iterator] is %ArrayProto_values%\n                // https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n                // https://tc39.es/ecma262/#sec-createmappedargumentsobject\n                Iterators.Arguments = Iterators.Array;\n                // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n                addToUnscopables(\"keys\");\n                addToUnscopables(\"values\");\n                addToUnscopables(\"entries\");\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.join.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.join.js ***!\n  \\*******************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_207042__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_207042__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var IndexedObject = __nested_webpack_require_207042__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                var toIndexedObject = __nested_webpack_require_207042__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var arrayMethodIsStrict = __nested_webpack_require_207042__(/*! ../internals/array-method-is-strict */ \"./node_modules/core-js/internals/array-method-is-strict.js\");\n                var nativeJoin = [].join;\n                var ES3_STRINGS = IndexedObject != Object;\n                var STRICT_METHOD = arrayMethodIsStrict(\"join\", \",\");\n                // `Array.prototype.join` method\n                // https://tc39.es/ecma262/#sec-array.prototype.join\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: ES3_STRINGS || !STRICT_METHOD\n                }, {\n                    join: function join(separator) {\n                        return nativeJoin.call(toIndexedObject(this), separator === undefined ? \",\" : separator);\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.map.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.map.js ***!\n  \\******************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_208682__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_208682__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var $map = __nested_webpack_require_208682__(/*! ../internals/array-iteration */ \"./node_modules/core-js/internals/array-iteration.js\").map;\n                var arrayMethodHasSpeciesSupport = __nested_webpack_require_208682__(/*! ../internals/array-method-has-species-support */ \"./node_modules/core-js/internals/array-method-has-species-support.js\");\n                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(\"map\");\n                // `Array.prototype.map` method\n                // https://tc39.es/ecma262/#sec-array.prototype.map\n                // with adding support of @@species\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: !HAS_SPECIES_SUPPORT\n                }, {\n                    map: function map(callbackfn /* , thisArg */ ) {\n                        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.slice.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.slice.js ***!\n  \\********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_210157__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_210157__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var isObject = __nested_webpack_require_210157__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isArray = __nested_webpack_require_210157__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var toAbsoluteIndex = __nested_webpack_require_210157__(/*! ../internals/to-absolute-index */ \"./node_modules/core-js/internals/to-absolute-index.js\");\n                var toLength = __nested_webpack_require_210157__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var toIndexedObject = __nested_webpack_require_210157__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var createProperty = __nested_webpack_require_210157__(/*! ../internals/create-property */ \"./node_modules/core-js/internals/create-property.js\");\n                var wellKnownSymbol = __nested_webpack_require_210157__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var arrayMethodHasSpeciesSupport = __nested_webpack_require_210157__(/*! ../internals/array-method-has-species-support */ \"./node_modules/core-js/internals/array-method-has-species-support.js\");\n                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(\"slice\");\n                var SPECIES = wellKnownSymbol(\"species\");\n                var nativeSlice = [].slice;\n                var max = Math.max;\n                // `Array.prototype.slice` method\n                // https://tc39.es/ecma262/#sec-array.prototype.slice\n                // fallback for not array-like ES3 strings and DOM objects\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: !HAS_SPECIES_SUPPORT\n                }, {\n                    slice: function slice(start, end) {\n                        var O = toIndexedObject(this);\n                        var length = toLength(O.length);\n                        var k = toAbsoluteIndex(start, length);\n                        var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n                        // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible\n                        var Constructor, result, n;\n                        if (isArray(O)) {\n                            Constructor = O.constructor;\n                            // cross-realm fallback\n                            if (typeof Constructor == \"function\" && (Constructor === Array || isArray(Constructor.prototype))) {\n                                Constructor = undefined;\n                            } else if (isObject(Constructor)) {\n                                Constructor = Constructor[SPECIES];\n                                if (Constructor === null) Constructor = undefined;\n                            }\n                            if (Constructor === Array || Constructor === undefined) {\n                                return nativeSlice.call(O, k, fin);\n                            }\n                        }\n                        result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));\n                        for(n = 0; k < fin; k++, n++)if (k in O) createProperty(result, n, O[k]);\n                        result.length = n;\n                        return result;\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.function.name.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.function.name.js ***!\n  \\**********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_214052__) {\n                var DESCRIPTORS = __nested_webpack_require_214052__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var defineProperty = __nested_webpack_require_214052__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var FunctionPrototype = Function.prototype;\n                var FunctionPrototypeToString = FunctionPrototype.toString;\n                var nameRE = /^\\s*function ([^ (]*)/;\n                var NAME = \"name\";\n                // Function instances `.name` property\n                // https://tc39.es/ecma262/#sec-function-instances-name\n                if (DESCRIPTORS && !(NAME in FunctionPrototype)) {\n                    defineProperty(FunctionPrototype, NAME, {\n                        configurable: true,\n                        get: function() {\n                            try {\n                                return FunctionPrototypeToString.call(this).match(nameRE)[1];\n                            } catch (error) {\n                                return \"\";\n                            }\n                        }\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.number.constructor.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.number.constructor.js ***!\n  \\***************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_215630__) {\n                \"use strict\";\n                var DESCRIPTORS = __nested_webpack_require_215630__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var global1 = __nested_webpack_require_215630__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var isForced = __nested_webpack_require_215630__(/*! ../internals/is-forced */ \"./node_modules/core-js/internals/is-forced.js\");\n                var redefine = __nested_webpack_require_215630__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var has = __nested_webpack_require_215630__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var classof = __nested_webpack_require_215630__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                var inheritIfRequired = __nested_webpack_require_215630__(/*! ../internals/inherit-if-required */ \"./node_modules/core-js/internals/inherit-if-required.js\");\n                var isSymbol = __nested_webpack_require_215630__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                var toPrimitive = __nested_webpack_require_215630__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\n                var fails = __nested_webpack_require_215630__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var create = __nested_webpack_require_215630__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var getOwnPropertyNames = __nested_webpack_require_215630__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\").f;\n                var getOwnPropertyDescriptor = __nested_webpack_require_215630__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\").f;\n                var defineProperty = __nested_webpack_require_215630__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var trim = __nested_webpack_require_215630__(/*! ../internals/string-trim */ \"./node_modules/core-js/internals/string-trim.js\").trim;\n                var NUMBER = \"Number\";\n                var NativeNumber = global1[NUMBER];\n                var NumberPrototype = NativeNumber.prototype;\n                // Opera ~12 has broken Object#toString\n                var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;\n                // `ToNumber` abstract operation\n                // https://tc39.es/ecma262/#sec-tonumber\n                var toNumber = function(argument) {\n                    if (isSymbol(argument)) throw TypeError(\"Cannot convert a Symbol value to a number\");\n                    var it = toPrimitive(argument, \"number\");\n                    var first, third, radix, maxCode, digits, length, index, code;\n                    if (typeof it == \"string\" && it.length > 2) {\n                        it = trim(it);\n                        first = it.charCodeAt(0);\n                        if (first === 43 || first === 45) {\n                            third = it.charCodeAt(2);\n                            if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n                        } else if (first === 48) {\n                            switch(it.charCodeAt(1)){\n                                case 66:\n                                case 98:\n                                    radix = 2;\n                                    maxCode = 49;\n                                    break; // fast equal of /^0b[01]+$/i\n                                case 79:\n                                case 111:\n                                    radix = 8;\n                                    maxCode = 55;\n                                    break; // fast equal of /^0o[0-7]+$/i\n                                default:\n                                    return +it;\n                            }\n                            digits = it.slice(2);\n                            length = digits.length;\n                            for(index = 0; index < length; index++){\n                                code = digits.charCodeAt(index);\n                                // parseInt parses a string to a first unavailable symbol\n                                // but ToNumber should return NaN if a string contains unavailable symbols\n                                if (code < 48 || code > maxCode) return NaN;\n                            }\n                            return parseInt(digits, radix);\n                        }\n                    }\n                    return +it;\n                };\n                // `Number` constructor\n                // https://tc39.es/ecma262/#sec-number-constructor\n                if (isForced(NUMBER, !NativeNumber(\" 0o1\") || !NativeNumber(\"0b1\") || NativeNumber(\"+0x1\"))) {\n                    var NumberWrapper = function Number1(value) {\n                        var it = arguments.length < 1 ? 0 : value;\n                        var dummy = this;\n                        return dummy instanceof NumberWrapper && (BROKEN_CLASSOF ? fails(function() {\n                            NumberPrototype.valueOf.call(dummy);\n                        }) : classof(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);\n                    };\n                    for(var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : // ES3:\n                    (\"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,\" + // ES2015 (in case, if modules with ES2015 Number statics required before):\n                    \"EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,\" + \"MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,\" + // ESNext\n                    \"fromString,range\").split(\",\"), j = 0, key; keys.length > j; j++){\n                        if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {\n                            defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));\n                        }\n                    }\n                    NumberWrapper.prototype = NumberPrototype;\n                    NumberPrototype.constructor = NumberWrapper;\n                    redefine(global1, NUMBER, NumberWrapper);\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.object.assign.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.object.assign.js ***!\n  \\**********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_222369__) {\n                var $ = __nested_webpack_require_222369__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var assign = __nested_webpack_require_222369__(/*! ../internals/object-assign */ \"./node_modules/core-js/internals/object-assign.js\");\n                // `Object.assign` method\n                // https://tc39.es/ecma262/#sec-object.assign\n                // eslint-disable-next-line es/no-object-assign -- required for testing\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: Object.assign !== assign\n                }, {\n                    assign: assign\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.object.keys.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.object.keys.js ***!\n  \\********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_223400__) {\n                var $ = __nested_webpack_require_223400__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var toObject = __nested_webpack_require_223400__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var nativeKeys = __nested_webpack_require_223400__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                var fails = __nested_webpack_require_223400__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var FAILS_ON_PRIMITIVES = fails(function() {\n                    nativeKeys(1);\n                });\n                // `Object.keys` method\n                // https://tc39.es/ecma262/#sec-object.keys\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: FAILS_ON_PRIMITIVES\n                }, {\n                    keys: function keys(it) {\n                        return nativeKeys(toObject(it));\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.object.to-string.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!\n  \\*************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_224811__) {\n                var TO_STRING_TAG_SUPPORT = __nested_webpack_require_224811__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\n                var redefine = __nested_webpack_require_224811__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var toString = __nested_webpack_require_224811__(/*! ../internals/object-to-string */ \"./node_modules/core-js/internals/object-to-string.js\");\n                // `Object.prototype.toString` method\n                // https://tc39.es/ecma262/#sec-object.prototype.tostring\n                if (!TO_STRING_TAG_SUPPORT) {\n                    redefine(Object.prototype, \"toString\", toString, {\n                        unsafe: true\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.regexp.to-string.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.regexp.to-string.js ***!\n  \\*************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_225962__) {\n                \"use strict\";\n                var redefine = __nested_webpack_require_225962__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var anObject = __nested_webpack_require_225962__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var $toString = __nested_webpack_require_225962__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var fails = __nested_webpack_require_225962__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var flags = __nested_webpack_require_225962__(/*! ../internals/regexp-flags */ \"./node_modules/core-js/internals/regexp-flags.js\");\n                var TO_STRING = \"toString\";\n                var RegExpPrototype = RegExp.prototype;\n                var nativeToString = RegExpPrototype[TO_STRING];\n                var NOT_GENERIC = fails(function() {\n                    return nativeToString.call({\n                        source: \"a\",\n                        flags: \"b\"\n                    }) != \"/a/b\";\n                });\n                // FF44- RegExp#toString has a wrong name\n                var INCORRECT_NAME = nativeToString.name != TO_STRING;\n                // `RegExp.prototype.toString` method\n                // https://tc39.es/ecma262/#sec-regexp.prototype.tostring\n                if (NOT_GENERIC || INCORRECT_NAME) {\n                    redefine(RegExp.prototype, TO_STRING, function toString() {\n                        var R = anObject(this);\n                        var p = $toString(R.source);\n                        var rf = R.flags;\n                        var f = $toString(rf === undefined && R instanceof RegExp && !(\"flags\" in RegExpPrototype) ? flags.call(R) : rf);\n                        return \"/\" + p + \"/\" + f;\n                    }, {\n                        unsafe: true\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.string.iterator.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!\n  \\************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_228237__) {\n                \"use strict\";\n                var charAt = __nested_webpack_require_228237__(/*! ../internals/string-multibyte */ \"./node_modules/core-js/internals/string-multibyte.js\").charAt;\n                var toString = __nested_webpack_require_228237__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var InternalStateModule = __nested_webpack_require_228237__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var defineIterator = __nested_webpack_require_228237__(/*! ../internals/define-iterator */ \"./node_modules/core-js/internals/define-iterator.js\");\n                var STRING_ITERATOR = \"String Iterator\";\n                var setInternalState = InternalStateModule.set;\n                var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\n                // `String.prototype[@@iterator]` method\n                // https://tc39.es/ecma262/#sec-string.prototype-@@iterator\n                defineIterator(String, \"String\", function(iterated) {\n                    setInternalState(this, {\n                        type: STRING_ITERATOR,\n                        string: toString(iterated),\n                        index: 0\n                    });\n                // `%StringIteratorPrototype%.next` method\n                // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n                }, function next() {\n                    var state = getInternalState(this);\n                    var string = state.string;\n                    var index = state.index;\n                    var point;\n                    if (index >= string.length) return {\n                        value: undefined,\n                        done: true\n                    };\n                    point = charAt(string, index);\n                    state.index += point.length;\n                    return {\n                        value: point,\n                        done: false\n                    };\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.string.link.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.string.link.js ***!\n  \\********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_230583__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_230583__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var createHTML = __nested_webpack_require_230583__(/*! ../internals/create-html */ \"./node_modules/core-js/internals/create-html.js\");\n                var forcedStringHTMLMethod = __nested_webpack_require_230583__(/*! ../internals/string-html-forced */ \"./node_modules/core-js/internals/string-html-forced.js\");\n                // `String.prototype.link` method\n                // https://tc39.es/ecma262/#sec-string.prototype.link\n                $({\n                    target: \"String\",\n                    proto: true,\n                    forced: forcedStringHTMLMethod(\"link\")\n                }, {\n                    link: function link(url) {\n                        return createHTML(this, \"a\", \"href\", url);\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.symbol.description.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.symbol.description.js ***!\n  \\***************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_231871__) {\n                \"use strict\";\n                // `Symbol.prototype.description` getter\n                // https://tc39.es/ecma262/#sec-symbol.prototype.description\n                var $ = __nested_webpack_require_231871__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var DESCRIPTORS = __nested_webpack_require_231871__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var global1 = __nested_webpack_require_231871__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var has = __nested_webpack_require_231871__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var isObject = __nested_webpack_require_231871__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var defineProperty = __nested_webpack_require_231871__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var copyConstructorProperties = __nested_webpack_require_231871__(/*! ../internals/copy-constructor-properties */ \"./node_modules/core-js/internals/copy-constructor-properties.js\");\n                var NativeSymbol = global1.Symbol;\n                if (DESCRIPTORS && typeof NativeSymbol == \"function\" && (!(\"description\" in NativeSymbol.prototype) || // Safari 12 bug\n                NativeSymbol().description !== undefined)) {\n                    var EmptyStringDescriptionStore = {};\n                    // wrap Symbol constructor for correct work with undefined description\n                    var SymbolWrapper = function Symbol1() {\n                        var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);\n                        var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === undefined ? NativeSymbol() : NativeSymbol(description);\n                        if (description === \"\") EmptyStringDescriptionStore[result] = true;\n                        return result;\n                    };\n                    copyConstructorProperties(SymbolWrapper, NativeSymbol);\n                    var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;\n                    symbolPrototype.constructor = SymbolWrapper;\n                    var symbolToString = symbolPrototype.toString;\n                    var native = String(NativeSymbol(\"test\")) == \"Symbol(test)\";\n                    var regexp = /^Symbol\\((.*)\\)[^)]+$/;\n                    defineProperty(symbolPrototype, \"description\", {\n                        configurable: true,\n                        get: function description() {\n                            var symbol = isObject(this) ? this.valueOf() : this;\n                            var string = symbolToString.call(symbol);\n                            if (has(EmptyStringDescriptionStore, symbol)) return \"\";\n                            var desc = native ? string.slice(7, -1) : string.replace(regexp, \"$1\");\n                            return desc === \"\" ? undefined : desc;\n                        }\n                    });\n                    $({\n                        global: true,\n                        forced: true\n                    }, {\n                        Symbol: SymbolWrapper\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.symbol.iterator.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!\n  \\************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_235575__) {\n                var defineWellKnownSymbol = __nested_webpack_require_235575__(/*! ../internals/define-well-known-symbol */ \"./node_modules/core-js/internals/define-well-known-symbol.js\");\n                // `Symbol.iterator` well-known symbol\n                // https://tc39.es/ecma262/#sec-symbol.iterator\n                defineWellKnownSymbol(\"iterator\");\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.symbol.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.symbol.js ***!\n  \\***************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_236264__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_236264__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var global1 = __nested_webpack_require_236264__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var getBuiltIn = __nested_webpack_require_236264__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                var IS_PURE = __nested_webpack_require_236264__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var DESCRIPTORS = __nested_webpack_require_236264__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var NATIVE_SYMBOL = __nested_webpack_require_236264__(/*! ../internals/native-symbol */ \"./node_modules/core-js/internals/native-symbol.js\");\n                var fails = __nested_webpack_require_236264__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var has = __nested_webpack_require_236264__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var isArray = __nested_webpack_require_236264__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var isObject = __nested_webpack_require_236264__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isSymbol = __nested_webpack_require_236264__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                var anObject = __nested_webpack_require_236264__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var toObject = __nested_webpack_require_236264__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var toIndexedObject = __nested_webpack_require_236264__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var toPropertyKey = __nested_webpack_require_236264__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                var $toString = __nested_webpack_require_236264__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var createPropertyDescriptor = __nested_webpack_require_236264__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                var nativeObjectCreate = __nested_webpack_require_236264__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var objectKeys = __nested_webpack_require_236264__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                var getOwnPropertyNamesModule = __nested_webpack_require_236264__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\");\n                var getOwnPropertyNamesExternal = __nested_webpack_require_236264__(/*! ../internals/object-get-own-property-names-external */ \"./node_modules/core-js/internals/object-get-own-property-names-external.js\");\n                var getOwnPropertySymbolsModule = __nested_webpack_require_236264__(/*! ../internals/object-get-own-property-symbols */ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\");\n                var getOwnPropertyDescriptorModule = __nested_webpack_require_236264__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\");\n                var definePropertyModule = __nested_webpack_require_236264__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var propertyIsEnumerableModule = __nested_webpack_require_236264__(/*! ../internals/object-property-is-enumerable */ \"./node_modules/core-js/internals/object-property-is-enumerable.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_236264__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var redefine = __nested_webpack_require_236264__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var shared = __nested_webpack_require_236264__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\n                var sharedKey = __nested_webpack_require_236264__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var hiddenKeys = __nested_webpack_require_236264__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                var uid = __nested_webpack_require_236264__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\n                var wellKnownSymbol = __nested_webpack_require_236264__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var wrappedWellKnownSymbolModule = __nested_webpack_require_236264__(/*! ../internals/well-known-symbol-wrapped */ \"./node_modules/core-js/internals/well-known-symbol-wrapped.js\");\n                var defineWellKnownSymbol = __nested_webpack_require_236264__(/*! ../internals/define-well-known-symbol */ \"./node_modules/core-js/internals/define-well-known-symbol.js\");\n                var setToStringTag = __nested_webpack_require_236264__(/*! ../internals/set-to-string-tag */ \"./node_modules/core-js/internals/set-to-string-tag.js\");\n                var InternalStateModule = __nested_webpack_require_236264__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var $forEach = __nested_webpack_require_236264__(/*! ../internals/array-iteration */ \"./node_modules/core-js/internals/array-iteration.js\").forEach;\n                var HIDDEN = sharedKey(\"hidden\");\n                var SYMBOL = \"Symbol\";\n                var PROTOTYPE = \"prototype\";\n                var TO_PRIMITIVE = wellKnownSymbol(\"toPrimitive\");\n                var setInternalState = InternalStateModule.set;\n                var getInternalState = InternalStateModule.getterFor(SYMBOL);\n                var ObjectPrototype = Object[PROTOTYPE];\n                var $Symbol = global1.Symbol;\n                var $stringify = getBuiltIn(\"JSON\", \"stringify\");\n                var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n                var nativeDefineProperty = definePropertyModule.f;\n                var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;\n                var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;\n                var AllSymbols = shared(\"symbols\");\n                var ObjectPrototypeSymbols = shared(\"op-symbols\");\n                var StringToSymbolRegistry = shared(\"string-to-symbol-registry\");\n                var SymbolToStringRegistry = shared(\"symbol-to-string-registry\");\n                var WellKnownSymbolsStore = shared(\"wks\");\n                var QObject = global1.QObject;\n                // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n                var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n                // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n                var setSymbolDescriptor = DESCRIPTORS && fails(function() {\n                    return nativeObjectCreate(nativeDefineProperty({}, \"a\", {\n                        get: function() {\n                            return nativeDefineProperty(this, \"a\", {\n                                value: 7\n                            }).a;\n                        }\n                    })).a != 7;\n                }) ? function(O, P, Attributes) {\n                    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);\n                    if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];\n                    nativeDefineProperty(O, P, Attributes);\n                    if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {\n                        nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);\n                    }\n                } : nativeDefineProperty;\n                var wrap = function(tag, description) {\n                    var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);\n                    setInternalState(symbol, {\n                        type: SYMBOL,\n                        tag: tag,\n                        description: description\n                    });\n                    if (!DESCRIPTORS) symbol.description = description;\n                    return symbol;\n                };\n                var $defineProperty = function defineProperty(O, P, Attributes) {\n                    if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n                    anObject(O);\n                    var key = toPropertyKey(P);\n                    anObject(Attributes);\n                    if (has(AllSymbols, key)) {\n                        if (!Attributes.enumerable) {\n                            if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));\n                            O[HIDDEN][key] = true;\n                        } else {\n                            if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;\n                            Attributes = nativeObjectCreate(Attributes, {\n                                enumerable: createPropertyDescriptor(0, false)\n                            });\n                        }\n                        return setSymbolDescriptor(O, key, Attributes);\n                    }\n                    return nativeDefineProperty(O, key, Attributes);\n                };\n                var $defineProperties = function defineProperties(O, Properties) {\n                    anObject(O);\n                    var properties = toIndexedObject(Properties);\n                    var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n                    $forEach(keys, function(key) {\n                        if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);\n                    });\n                    return O;\n                };\n                var $create = function create(O, Properties) {\n                    return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);\n                };\n                var $propertyIsEnumerable = function propertyIsEnumerable(V) {\n                    var P = toPropertyKey(V);\n                    var enumerable = nativePropertyIsEnumerable.call(this, P);\n                    if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;\n                    return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;\n                };\n                var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n                    var it = toIndexedObject(O);\n                    var key = toPropertyKey(P);\n                    if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;\n                    var descriptor = nativeGetOwnPropertyDescriptor(it, key);\n                    if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {\n                        descriptor.enumerable = true;\n                    }\n                    return descriptor;\n                };\n                var $getOwnPropertyNames = function getOwnPropertyNames(O) {\n                    var names = nativeGetOwnPropertyNames(toIndexedObject(O));\n                    var result = [];\n                    $forEach(names, function(key) {\n                        if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);\n                    });\n                    return result;\n                };\n                var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {\n                    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;\n                    var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));\n                    var result = [];\n                    $forEach(names, function(key) {\n                        if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {\n                            result.push(AllSymbols[key]);\n                        }\n                    });\n                    return result;\n                };\n                // `Symbol` constructor\n                // https://tc39.es/ecma262/#sec-symbol-constructor\n                if (!NATIVE_SYMBOL) {\n                    $Symbol = function Symbol1() {\n                        if (this instanceof $Symbol) throw TypeError(\"Symbol is not a constructor\");\n                        var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);\n                        var tag = uid(description);\n                        var setter = function(value) {\n                            if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);\n                            if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n                            setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));\n                        };\n                        if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {\n                            configurable: true,\n                            set: setter\n                        });\n                        return wrap(tag, description);\n                    };\n                    redefine($Symbol[PROTOTYPE], \"toString\", function toString() {\n                        return getInternalState(this).tag;\n                    });\n                    redefine($Symbol, \"withoutSetter\", function(description) {\n                        return wrap(uid(description), description);\n                    });\n                    propertyIsEnumerableModule.f = $propertyIsEnumerable;\n                    definePropertyModule.f = $defineProperty;\n                    getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;\n                    getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n                    getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;\n                    wrappedWellKnownSymbolModule.f = function(name) {\n                        return wrap(wellKnownSymbol(name), name);\n                    };\n                    if (DESCRIPTORS) {\n                        // https://github.com/tc39/proposal-Symbol-description\n                        nativeDefineProperty($Symbol[PROTOTYPE], \"description\", {\n                            configurable: true,\n                            get: function description() {\n                                return getInternalState(this).description;\n                            }\n                        });\n                        if (!IS_PURE) {\n                            redefine(ObjectPrototype, \"propertyIsEnumerable\", $propertyIsEnumerable, {\n                                unsafe: true\n                            });\n                        }\n                    }\n                }\n                $({\n                    global: true,\n                    wrap: true,\n                    forced: !NATIVE_SYMBOL,\n                    sham: !NATIVE_SYMBOL\n                }, {\n                    Symbol: $Symbol\n                });\n                $forEach(objectKeys(WellKnownSymbolsStore), function(name) {\n                    defineWellKnownSymbol(name);\n                });\n                $({\n                    target: SYMBOL,\n                    stat: true,\n                    forced: !NATIVE_SYMBOL\n                }, {\n                    // `Symbol.for` method\n                    // https://tc39.es/ecma262/#sec-symbol.for\n                    \"for\": function(key) {\n                        var string = $toString(key);\n                        if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];\n                        var symbol = $Symbol(string);\n                        StringToSymbolRegistry[string] = symbol;\n                        SymbolToStringRegistry[symbol] = string;\n                        return symbol;\n                    },\n                    // `Symbol.keyFor` method\n                    // https://tc39.es/ecma262/#sec-symbol.keyfor\n                    keyFor: function keyFor(sym) {\n                        if (!isSymbol(sym)) throw TypeError(sym + \" is not a symbol\");\n                        if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];\n                    },\n                    useSetter: function() {\n                        USE_SETTER = true;\n                    },\n                    useSimple: function() {\n                        USE_SETTER = false;\n                    }\n                });\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: !NATIVE_SYMBOL,\n                    sham: !DESCRIPTORS\n                }, {\n                    // `Object.create` method\n                    // https://tc39.es/ecma262/#sec-object.create\n                    create: $create,\n                    // `Object.defineProperty` method\n                    // https://tc39.es/ecma262/#sec-object.defineproperty\n                    defineProperty: $defineProperty,\n                    // `Object.defineProperties` method\n                    // https://tc39.es/ecma262/#sec-object.defineproperties\n                    defineProperties: $defineProperties,\n                    // `Object.getOwnPropertyDescriptor` method\n                    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors\n                    getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n                });\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: !NATIVE_SYMBOL\n                }, {\n                    // `Object.getOwnPropertyNames` method\n                    // https://tc39.es/ecma262/#sec-object.getownpropertynames\n                    getOwnPropertyNames: $getOwnPropertyNames,\n                    // `Object.getOwnPropertySymbols` method\n                    // https://tc39.es/ecma262/#sec-object.getownpropertysymbols\n                    getOwnPropertySymbols: $getOwnPropertySymbols\n                });\n                // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n                // https://bugs.chromium.org/p/v8/issues/detail?id=3443\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: fails(function() {\n                        getOwnPropertySymbolsModule.f(1);\n                    })\n                }, {\n                    getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n                        return getOwnPropertySymbolsModule.f(toObject(it));\n                    }\n                });\n                // `JSON.stringify` method behavior with symbols\n                // https://tc39.es/ecma262/#sec-json.stringify\n                if ($stringify) {\n                    var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {\n                        var symbol = $Symbol();\n                        // MS Edge converts symbol values to JSON as {}\n                        return $stringify([\n                            symbol\n                        ]) != \"[null]\" || $stringify({\n                            a: symbol\n                        }) != \"{}\" || $stringify(Object(symbol)) != \"{}\";\n                    });\n                    $({\n                        target: \"JSON\",\n                        stat: true,\n                        forced: FORCED_JSON_STRINGIFY\n                    }, {\n                        // eslint-disable-next-line no-unused-vars -- required for `.length`\n                        stringify: function stringify(it, replacer, space) {\n                            var args = [\n                                it\n                            ];\n                            var index = 1;\n                            var $replacer;\n                            while(arguments.length > index)args.push(arguments[index++]);\n                            $replacer = replacer;\n                            if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n                            if (!isArray(replacer)) replacer = function(key, value) {\n                                if (typeof $replacer == \"function\") value = $replacer.call(this, key, value);\n                                if (!isSymbol(value)) return value;\n                            };\n                            args[1] = replacer;\n                            return $stringify.apply(null, args);\n                        }\n                    });\n                }\n                // `Symbol.prototype[@@toPrimitive]` method\n                // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive\n                if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {\n                    createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n                }\n                // `Symbol.prototype[@@toStringTag]` property\n                // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\n                setToStringTag($Symbol, SYMBOL);\n                hiddenKeys[HIDDEN] = true;\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\": /*!**********************************************************************!*\\\n  !*** ./node_modules/core-js/modules/web.dom-collections.for-each.js ***!\n  \\**********************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_258228__) {\n                var global1 = __nested_webpack_require_258228__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var DOMIterables = __nested_webpack_require_258228__(/*! ../internals/dom-iterables */ \"./node_modules/core-js/internals/dom-iterables.js\");\n                var forEach = __nested_webpack_require_258228__(/*! ../internals/array-for-each */ \"./node_modules/core-js/internals/array-for-each.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_258228__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                for(var COLLECTION_NAME in DOMIterables){\n                    var Collection = global1[COLLECTION_NAME];\n                    var CollectionPrototype = Collection && Collection.prototype;\n                    // some Chrome versions have non-configurable methods on DOMTokenList\n                    if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {\n                        createNonEnumerableProperty(CollectionPrototype, \"forEach\", forEach);\n                    } catch (error) {\n                        CollectionPrototype.forEach = forEach;\n                    }\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\": /*!**********************************************************************!*\\\n  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!\n  \\**********************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_259870__) {\n                var global1 = __nested_webpack_require_259870__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var DOMIterables = __nested_webpack_require_259870__(/*! ../internals/dom-iterables */ \"./node_modules/core-js/internals/dom-iterables.js\");\n                var ArrayIteratorMethods = __nested_webpack_require_259870__(/*! ../modules/es.array.iterator */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_259870__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var wellKnownSymbol = __nested_webpack_require_259870__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var ITERATOR = wellKnownSymbol(\"iterator\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                var ArrayValues = ArrayIteratorMethods.values;\n                for(var COLLECTION_NAME in DOMIterables){\n                    var Collection = global1[COLLECTION_NAME];\n                    var CollectionPrototype = Collection && Collection.prototype;\n                    if (CollectionPrototype) {\n                        // some Chrome versions have non-configurable methods on DOMTokenList\n                        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n                            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);\n                        } catch (error) {\n                            CollectionPrototype[ITERATOR] = ArrayValues;\n                        }\n                        if (!CollectionPrototype[TO_STRING_TAG]) {\n                            createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n                        }\n                        if (DOMIterables[COLLECTION_NAME]) for(var METHOD_NAME in ArrayIteratorMethods){\n                            // some Chrome versions have non-configurable methods on DOMTokenList\n                            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n                                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n                            } catch (error) {\n                                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n                            }\n                        }\n                    }\n                }\n            /***/ },\n            /***/ \"./node_modules/es6-promise/dist/es6-promise.js\": /*!******************************************************!*\\\n  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!\n  \\******************************************************/ /***/ function(module1) {\n                /*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */ (function(global1, factory) {\n                     true ? module1.exports = factory() : 0;\n                })(this, function() {\n                    \"use strict\";\n                    function objectOrFunction(x) {\n                        var type = typeof x;\n                        return x !== null && (type === \"object\" || type === \"function\");\n                    }\n                    function isFunction(x) {\n                        return typeof x === \"function\";\n                    }\n                    var _isArray = void 0;\n                    if (Array.isArray) {\n                        _isArray = Array.isArray;\n                    } else {\n                        _isArray = function(x) {\n                            return Object.prototype.toString.call(x) === \"[object Array]\";\n                        };\n                    }\n                    var isArray = _isArray;\n                    var len = 0;\n                    var vertxNext = void 0;\n                    var customSchedulerFn = void 0;\n                    var asap = function asap(callback, arg) {\n                        queue[len] = callback;\n                        queue[len + 1] = arg;\n                        len += 2;\n                        if (len === 2) {\n                            // If len is 2, that means that we need to schedule an async flush.\n                            // If additional callbacks are queued before the queue is flushed, they\n                            // will be processed by this flush that we are scheduling.\n                            if (customSchedulerFn) {\n                                customSchedulerFn(flush);\n                            } else {\n                                scheduleFlush();\n                            }\n                        }\n                    };\n                    function setScheduler(scheduleFn) {\n                        customSchedulerFn = scheduleFn;\n                    }\n                    function setAsap(asapFn) {\n                        asap = asapFn;\n                    }\n                    var browserWindow =  false ? 0 : undefined;\n                    var browserGlobal = browserWindow || {};\n                    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n                    var isNode = typeof self === \"undefined\" && typeof process !== \"undefined\" && ({}).toString.call(process) === \"[object process]\";\n                    // test for web worker but not in IE10\n                    var isWorker = typeof Uint8ClampedArray !== \"undefined\" && typeof importScripts !== \"undefined\" && typeof MessageChannel !== \"undefined\";\n                    // node\n                    function useNextTick() {\n                        // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n                        // see https://github.com/cujojs/when/issues/410 for details\n                        return function() {\n                            return process.nextTick(flush);\n                        };\n                    }\n                    // vertx\n                    function useVertxTimer() {\n                        if (typeof vertxNext !== \"undefined\") {\n                            return function() {\n                                vertxNext(flush);\n                            };\n                        }\n                        return useSetTimeout();\n                    }\n                    function useMutationObserver() {\n                        var iterations = 0;\n                        var observer = new BrowserMutationObserver(flush);\n                        var node = document.createTextNode(\"\");\n                        observer.observe(node, {\n                            characterData: true\n                        });\n                        return function() {\n                            node.data = iterations = ++iterations % 2;\n                        };\n                    }\n                    // web worker\n                    function useMessageChannel() {\n                        var channel = new MessageChannel();\n                        channel.port1.onmessage = flush;\n                        return function() {\n                            return channel.port2.postMessage(0);\n                        };\n                    }\n                    function useSetTimeout() {\n                        // Store setTimeout reference so es6-promise will be unaffected by\n                        // other code modifying setTimeout (like sinon.useFakeTimers())\n                        var globalSetTimeout = setTimeout;\n                        return function() {\n                            return globalSetTimeout(flush, 1);\n                        };\n                    }\n                    var queue = new Array(1000);\n                    function flush() {\n                        for(var i = 0; i < len; i += 2){\n                            var callback = queue[i];\n                            var arg = queue[i + 1];\n                            callback(arg);\n                            queue[i] = undefined;\n                            queue[i + 1] = undefined;\n                        }\n                        len = 0;\n                    }\n                    function attemptVertx() {\n                        try {\n                            var vertx = Function(\"return this\")().require(\"vertx\");\n                            vertxNext = vertx.runOnLoop || vertx.runOnContext;\n                            return useVertxTimer();\n                        } catch (e) {\n                            return useSetTimeout();\n                        }\n                    }\n                    var scheduleFlush = void 0;\n                    // Decide what async method to use to triggering processing of queued callbacks:\n                    if (isNode) {\n                        scheduleFlush = useNextTick();\n                    } else if (BrowserMutationObserver) {\n                        scheduleFlush = useMutationObserver();\n                    } else if (isWorker) {\n                        scheduleFlush = useMessageChannel();\n                    } else if (browserWindow === undefined && \"function\" === \"function\") {\n                        scheduleFlush = attemptVertx();\n                    } else {\n                        scheduleFlush = useSetTimeout();\n                    }\n                    function then(onFulfillment, onRejection) {\n                        var parent = this;\n                        var child = new this.constructor(noop);\n                        if (child[PROMISE_ID] === undefined) {\n                            makePromise(child);\n                        }\n                        var _state = parent._state;\n                        if (_state) {\n                            var callback = arguments[_state - 1];\n                            asap(function() {\n                                return invokeCallback(_state, child, callback, parent._result);\n                            });\n                        } else {\n                            subscribe(parent, child, onFulfillment, onRejection);\n                        }\n                        return child;\n                    }\n                    /**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/ function resolve$1(object) {\n                        /*jshint validthis:true */ var Constructor = this;\n                        if (object && typeof object === \"object\" && object.constructor === Constructor) {\n                            return object;\n                        }\n                        var promise = new Constructor(noop);\n                        resolve(promise, object);\n                        return promise;\n                    }\n                    var PROMISE_ID = Math.random().toString(36).substring(2);\n                    function noop() {}\n                    var PENDING = void 0;\n                    var FULFILLED = 1;\n                    var REJECTED = 2;\n                    function selfFulfillment() {\n                        return new TypeError(\"You cannot resolve a promise with itself\");\n                    }\n                    function cannotReturnOwn() {\n                        return new TypeError(\"A promises callback cannot return that same promise.\");\n                    }\n                    function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n                        try {\n                            then$$1.call(value, fulfillmentHandler, rejectionHandler);\n                        } catch (e) {\n                            return e;\n                        }\n                    }\n                    function handleForeignThenable(promise, thenable, then$$1) {\n                        asap(function(promise) {\n                            var sealed = false;\n                            var error = tryThen(then$$1, thenable, function(value) {\n                                if (sealed) {\n                                    return;\n                                }\n                                sealed = true;\n                                if (thenable !== value) {\n                                    resolve(promise, value);\n                                } else {\n                                    fulfill(promise, value);\n                                }\n                            }, function(reason) {\n                                if (sealed) {\n                                    return;\n                                }\n                                sealed = true;\n                                reject(promise, reason);\n                            }, \"Settle: \" + (promise._label || \" unknown promise\"));\n                            if (!sealed && error) {\n                                sealed = true;\n                                reject(promise, error);\n                            }\n                        }, promise);\n                    }\n                    function handleOwnThenable(promise, thenable) {\n                        if (thenable._state === FULFILLED) {\n                            fulfill(promise, thenable._result);\n                        } else if (thenable._state === REJECTED) {\n                            reject(promise, thenable._result);\n                        } else {\n                            subscribe(thenable, undefined, function(value) {\n                                return resolve(promise, value);\n                            }, function(reason) {\n                                return reject(promise, reason);\n                            });\n                        }\n                    }\n                    function handleMaybeThenable(promise, maybeThenable, then$$1) {\n                        if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n                            handleOwnThenable(promise, maybeThenable);\n                        } else {\n                            if (then$$1 === undefined) {\n                                fulfill(promise, maybeThenable);\n                            } else if (isFunction(then$$1)) {\n                                handleForeignThenable(promise, maybeThenable, then$$1);\n                            } else {\n                                fulfill(promise, maybeThenable);\n                            }\n                        }\n                    }\n                    function resolve(promise, value) {\n                        if (promise === value) {\n                            reject(promise, selfFulfillment());\n                        } else if (objectOrFunction(value)) {\n                            var then$$1 = void 0;\n                            try {\n                                then$$1 = value.then;\n                            } catch (error) {\n                                reject(promise, error);\n                                return;\n                            }\n                            handleMaybeThenable(promise, value, then$$1);\n                        } else {\n                            fulfill(promise, value);\n                        }\n                    }\n                    function publishRejection(promise) {\n                        if (promise._onerror) {\n                            promise._onerror(promise._result);\n                        }\n                        publish(promise);\n                    }\n                    function fulfill(promise, value) {\n                        if (promise._state !== PENDING) {\n                            return;\n                        }\n                        promise._result = value;\n                        promise._state = FULFILLED;\n                        if (promise._subscribers.length !== 0) {\n                            asap(publish, promise);\n                        }\n                    }\n                    function reject(promise, reason) {\n                        if (promise._state !== PENDING) {\n                            return;\n                        }\n                        promise._state = REJECTED;\n                        promise._result = reason;\n                        asap(publishRejection, promise);\n                    }\n                    function subscribe(parent, child, onFulfillment, onRejection) {\n                        var _subscribers = parent._subscribers;\n                        var length = _subscribers.length;\n                        parent._onerror = null;\n                        _subscribers[length] = child;\n                        _subscribers[length + FULFILLED] = onFulfillment;\n                        _subscribers[length + REJECTED] = onRejection;\n                        if (length === 0 && parent._state) {\n                            asap(publish, parent);\n                        }\n                    }\n                    function publish(promise) {\n                        var subscribers = promise._subscribers;\n                        var settled = promise._state;\n                        if (subscribers.length === 0) {\n                            return;\n                        }\n                        var child = void 0, callback = void 0, detail = promise._result;\n                        for(var i = 0; i < subscribers.length; i += 3){\n                            child = subscribers[i];\n                            callback = subscribers[i + settled];\n                            if (child) {\n                                invokeCallback(settled, child, callback, detail);\n                            } else {\n                                callback(detail);\n                            }\n                        }\n                        promise._subscribers.length = 0;\n                    }\n                    function invokeCallback(settled, promise, callback, detail) {\n                        var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = true;\n                        if (hasCallback) {\n                            try {\n                                value = callback(detail);\n                            } catch (e) {\n                                succeeded = false;\n                                error = e;\n                            }\n                            if (promise === value) {\n                                reject(promise, cannotReturnOwn());\n                                return;\n                            }\n                        } else {\n                            value = detail;\n                        }\n                        if (promise._state !== PENDING) {\n                        // noop\n                        } else if (hasCallback && succeeded) {\n                            resolve(promise, value);\n                        } else if (succeeded === false) {\n                            reject(promise, error);\n                        } else if (settled === FULFILLED) {\n                            fulfill(promise, value);\n                        } else if (settled === REJECTED) {\n                            reject(promise, value);\n                        }\n                    }\n                    function initializePromise(promise, resolver) {\n                        try {\n                            resolver(function resolvePromise(value) {\n                                resolve(promise, value);\n                            }, function rejectPromise(reason) {\n                                reject(promise, reason);\n                            });\n                        } catch (e) {\n                            reject(promise, e);\n                        }\n                    }\n                    var id = 0;\n                    function nextId() {\n                        return id++;\n                    }\n                    function makePromise(promise) {\n                        promise[PROMISE_ID] = id++;\n                        promise._state = undefined;\n                        promise._result = undefined;\n                        promise._subscribers = [];\n                    }\n                    function validationError() {\n                        return new Error(\"Array Methods must be provided an Array\");\n                    }\n                    var Enumerator = function() {\n                        function Enumerator(Constructor, input) {\n                            this._instanceConstructor = Constructor;\n                            this.promise = new Constructor(noop);\n                            if (!this.promise[PROMISE_ID]) {\n                                makePromise(this.promise);\n                            }\n                            if (isArray(input)) {\n                                this.length = input.length;\n                                this._remaining = input.length;\n                                this._result = new Array(this.length);\n                                if (this.length === 0) {\n                                    fulfill(this.promise, this._result);\n                                } else {\n                                    this.length = this.length || 0;\n                                    this._enumerate(input);\n                                    if (this._remaining === 0) {\n                                        fulfill(this.promise, this._result);\n                                    }\n                                }\n                            } else {\n                                reject(this.promise, validationError());\n                            }\n                        }\n                        Enumerator.prototype._enumerate = function _enumerate(input) {\n                            for(var i = 0; this._state === PENDING && i < input.length; i++){\n                                this._eachEntry(input[i], i);\n                            }\n                        };\n                        Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n                            var c = this._instanceConstructor;\n                            var resolve$$1 = c.resolve;\n                            if (resolve$$1 === resolve$1) {\n                                var _then = void 0;\n                                var error = void 0;\n                                var didError = false;\n                                try {\n                                    _then = entry.then;\n                                } catch (e) {\n                                    didError = true;\n                                    error = e;\n                                }\n                                if (_then === then && entry._state !== PENDING) {\n                                    this._settledAt(entry._state, i, entry._result);\n                                } else if (typeof _then !== \"function\") {\n                                    this._remaining--;\n                                    this._result[i] = entry;\n                                } else if (c === Promise$1) {\n                                    var promise = new c(noop);\n                                    if (didError) {\n                                        reject(promise, error);\n                                    } else {\n                                        handleMaybeThenable(promise, entry, _then);\n                                    }\n                                    this._willSettleAt(promise, i);\n                                } else {\n                                    this._willSettleAt(new c(function(resolve$$1) {\n                                        return resolve$$1(entry);\n                                    }), i);\n                                }\n                            } else {\n                                this._willSettleAt(resolve$$1(entry), i);\n                            }\n                        };\n                        Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n                            var promise = this.promise;\n                            if (promise._state === PENDING) {\n                                this._remaining--;\n                                if (state === REJECTED) {\n                                    reject(promise, value);\n                                } else {\n                                    this._result[i] = value;\n                                }\n                            }\n                            if (this._remaining === 0) {\n                                fulfill(promise, this._result);\n                            }\n                        };\n                        Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n                            var enumerator = this;\n                            subscribe(promise, undefined, function(value) {\n                                return enumerator._settledAt(FULFILLED, i, value);\n                            }, function(reason) {\n                                return enumerator._settledAt(REJECTED, i, reason);\n                            });\n                        };\n                        return Enumerator;\n                    }();\n                    /**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/ function all(entries) {\n                        return new Enumerator(this, entries).promise;\n                    }\n                    /**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/ function race(entries) {\n                        /*jshint validthis:true */ var Constructor = this;\n                        if (!isArray(entries)) {\n                            return new Constructor(function(_, reject) {\n                                return reject(new TypeError(\"You must pass an array to race.\"));\n                            });\n                        } else {\n                            return new Constructor(function(resolve, reject) {\n                                var length = entries.length;\n                                for(var i = 0; i < length; i++){\n                                    Constructor.resolve(entries[i]).then(resolve, reject);\n                                }\n                            });\n                        }\n                    }\n                    /**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/ function reject$1(reason) {\n                        /*jshint validthis:true */ var Constructor = this;\n                        var promise = new Constructor(noop);\n                        reject(promise, reason);\n                        return promise;\n                    }\n                    function needsResolver() {\n                        throw new TypeError(\"You must pass a resolver function as the first argument to the promise constructor\");\n                    }\n                    function needsNew() {\n                        throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n                    }\n                    /**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/ var Promise$1 = function() {\n                        function Promise(resolver) {\n                            this[PROMISE_ID] = nextId();\n                            this._result = this._state = undefined;\n                            this._subscribers = [];\n                            if (noop !== resolver) {\n                                typeof resolver !== \"function\" && needsResolver();\n                                this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n                            }\n                        }\n                        /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */ /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */ Promise.prototype.catch = function _catch(onRejection) {\n                            return this.then(null, onRejection);\n                        };\n                        /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */ Promise.prototype.finally = function _finally(callback) {\n                            var promise = this;\n                            var constructor = promise.constructor;\n                            if (isFunction(callback)) {\n                                return promise.then(function(value) {\n                                    return constructor.resolve(callback()).then(function() {\n                                        return value;\n                                    });\n                                }, function(reason) {\n                                    return constructor.resolve(callback()).then(function() {\n                                        throw reason;\n                                    });\n                                });\n                            }\n                            return promise.then(callback, callback);\n                        };\n                        return Promise;\n                    }();\n                    Promise$1.prototype.then = then;\n                    Promise$1.all = all;\n                    Promise$1.race = race;\n                    Promise$1.resolve = resolve$1;\n                    Promise$1.reject = reject$1;\n                    Promise$1._setScheduler = setScheduler;\n                    Promise$1._setAsap = setAsap;\n                    Promise$1._asap = asap;\n                    /*global self*/ function polyfill() {\n                        var local = void 0;\n                        if (typeof global !== \"undefined\") {\n                            local = global;\n                        } else if (typeof self !== \"undefined\") {\n                            local = self;\n                        } else {\n                            try {\n                                local = Function(\"return this\")();\n                            } catch (e) {\n                                throw new Error(\"polyfill failed because global object is unavailable in this environment\");\n                            }\n                        }\n                        var P = local.Promise;\n                        if (P) {\n                            var promiseToString = null;\n                            try {\n                                promiseToString = Object.prototype.toString.call(P.resolve());\n                            } catch (e) {\n                            // silently ignored\n                            }\n                            if (promiseToString === \"[object Promise]\" && !P.cast) {\n                                return;\n                            }\n                        }\n                        local.Promise = Promise$1;\n                    }\n                    // Strange compat..\n                    Promise$1.polyfill = polyfill;\n                    Promise$1.Promise = Promise$1;\n                    return Promise$1;\n                });\n            //# sourceMappingURL=es6-promise.map\n            /***/ },\n            /***/ \"html2canvas\": /*!******************************!*\\\n  !*** external \"html2canvas\" ***!\n  \\******************************/ /***/ function(module1) {\n                \"use strict\";\n                module1.exports = __WEBPACK_EXTERNAL_MODULE_html2canvas__;\n            /***/ },\n            /***/ \"jspdf\": /*!************************!*\\\n  !*** external \"jspdf\" ***!\n  \\************************/ /***/ function(module1) {\n                \"use strict\";\n                module1.exports = __WEBPACK_EXTERNAL_MODULE_jspdf__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_304581__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_304581__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ !function() {\n            /******/ // getDefaultExport function for compatibility with non-harmony modules\n            /******/ __nested_webpack_require_304581__.n = function(module1) {\n                /******/ var getter = module1 && module1.__esModule ? /******/ function() {\n                    return module1[\"default\"];\n                } : /******/ function() {\n                    return module1;\n                };\n                /******/ __nested_webpack_require_304581__.d(getter, {\n                    a: getter\n                });\n                /******/ return getter;\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/define property getters */ /******/ !function() {\n            /******/ // define getter functions for harmony exports\n            /******/ __nested_webpack_require_304581__.d = function(exports1, definition) {\n                /******/ for(var key in definition){\n                    /******/ if (__nested_webpack_require_304581__.o(definition, key) && !__nested_webpack_require_304581__.o(exports1, key)) {\n                        /******/ Object.defineProperty(exports1, key, {\n                            enumerable: true,\n                            get: definition[key]\n                        });\n                    /******/ }\n                /******/ }\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ !function() {\n            /******/ __nested_webpack_require_304581__.o = function(obj, prop) {\n                return Object.prototype.hasOwnProperty.call(obj, prop);\n            };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ !function() {\n            /******/ // define __esModule on exports\n            /******/ __nested_webpack_require_304581__.r = function(exports1) {\n                /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                        value: \"Module\"\n                    });\n                /******/ }\n                /******/ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /******/ };\n        /******/ }();\n        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};\n        // This entry need to be wrapped in an IIFE because it need to be in strict mode.\n        !function() {\n            \"use strict\";\n            /*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/ __nested_webpack_require_304581__.r(__nested_webpack_exports__);\n            /* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_304581__(/*! ./worker.js */ \"./src/worker.js\");\n            /* harmony import */ var _plugin_jspdf_plugin_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_304581__(/*! ./plugin/jspdf-plugin.js */ \"./src/plugin/jspdf-plugin.js\");\n            /* harmony import */ var _plugin_pagebreaks_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_304581__(/*! ./plugin/pagebreaks.js */ \"./src/plugin/pagebreaks.js\");\n            /* harmony import */ var _plugin_hyperlinks_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_304581__(/*! ./plugin/hyperlinks.js */ \"./src/plugin/hyperlinks.js\");\n            /**\n * Generate a PDF from an HTML element or string using html2canvas and jsPDF.\n *\n * @param {Element|string} source The source element or HTML string.\n * @param {Object=} opt An object of optional settings: 'margin', 'filename',\n *    'image' ('type' and 'quality'), and 'html2canvas' / 'jspdf', which are\n *    sent as settings to their corresponding functions.\n */ var html2pdf = function html2pdf(src, opt) {\n                // Create a new worker with the given options.\n                var worker = new html2pdf.Worker(opt);\n                if (src) {\n                    // If src is specified, perform the traditional 'simple' operation.\n                    return worker.from(src).save();\n                } else {\n                    // Otherwise, return the worker for new Promise-based operation.\n                    return worker;\n                }\n            };\n            html2pdf.Worker = _worker_js__WEBPACK_IMPORTED_MODULE_0__.default; // Expose the html2pdf function.\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = html2pdf;\n        }();\n        __nested_webpack_exports__ = __nested_webpack_exports__.default;\n        /******/ return __nested_webpack_exports__;\n    /******/ }();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDJwZGYuanMvZGlzdC9odG1sMnBkZi5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Q0FJQyxHQUNBLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0QsUUFBUUcsbUJBQU9BLENBQUMsOERBQU8sR0FBR0EsbUJBQU9BLENBQUMsNkVBQWE7U0FDNUQsRUFLMkQ7QUFDakUsR0FBR0csTUFBTSxTQUFTQyxpQ0FBaUMsRUFBRUMsdUNBQXVDO0lBQzVGLE9BQWdCLE1BQUgsR0FBSTtRQUNqQixNQUFNLEdBQUksSUFBSUMsc0JBQXVCO1lBRXJDLEdBQUcsR0FBRyw4QkFDTjs7b0NBRW9DLEdBQ3BDLEdBQUcsR0FBSSxTQUFTQyx1QkFBdUIsRUFBRUMsMEJBQW1CLEVBQUVDLCtCQUFtQjtnQkFFakY7Z0JBQ0FBLCtCQUFtQkEsQ0FBQ0MsQ0FBQyxDQUFDRiwwQkFBbUJBO2dCQUN6QyxrQkFBa0IsR0FBRyxJQUFJRywrRUFBK0VGLCtCQUFtQkEsQ0FBQyxvREFBb0QsR0FBRztnQkFDbkwsa0JBQWtCLEdBQUcsSUFBSUcsdUZBQXVGLFdBQVcsR0FBRUgsK0JBQW1CQSxDQUFDSSxDQUFDLENBQUNGO2dCQUNuSixrQkFBa0IsR0FBRyxJQUFJRyxpRUFBaUVMLCtCQUFtQkEsQ0FBQyxzQ0FBc0MsR0FBRztnQkFDdkosa0JBQWtCLEdBQUcsSUFBSU0seUVBQXlFLFdBQVcsR0FBRU4sK0JBQW1CQSxDQUFDSSxDQUFDLENBQUNDO2dCQUNySSxrQkFBa0IsR0FBRyxJQUFJRSwwQ0FBMENQLCtCQUFtQkEsQ0FBQyxpQkFBaUIsR0FBRztnQkFDM0csa0JBQWtCLEdBQUcsSUFBSVEseUNBQXlDUiwrQkFBbUJBLENBQUMsZ0JBQWdCLEdBQUc7Z0JBSXhHLG1EQUFtRDtnQkFDcEQsbURBQW1EO2dCQUVuRCxJQUFJUyxXQUFXLEVBQUU7Z0JBQ2pCLElBQUlDLE9BQU87b0JB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O1lBRUFELFNBQVMvckIsTUFBTSxHQUFHMnJCLHdDQUF3Q2o1QixPQUFPLEVBQUUsZ0NBQWdDO1lBRW5HLDBCQUEwQixHQUFHYiwwQkFBbUIsQ0FBQyxVQUFVLEdBQUlrNkI7UUFDL0Q7UUFDQWw2QiwwQkFBbUJBLEdBQUdBLDBCQUFtQkEsQ0FBQ2EsT0FBTztRQUNqRCxNQUFNLEdBQUksT0FBT2IsMEJBQW1CQTtJQUNwQyxNQUFNLEdBQUc7QUFFVCIsInNvdXJjZXMiOlsid2VicGFjazovL3pvc3RlbC10cmlwLW12cC8uL25vZGVfbW9kdWxlcy9odG1sMnBkZi5qcy9kaXN0L2h0bWwycGRmLmpzPzg1MzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBodG1sMnBkZi5qcyB2MC4xMC4zXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUgRXJpayBLb29wbWFuc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqc3BkZlwiKSwgcmVxdWlyZShcImh0bWwyY2FudmFzXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiaHRtbDJwZGZcIiwgW1wianNwZGZcIiwgXCJodG1sMmNhbnZhc1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJodG1sMnBkZlwiXSA9IGZhY3RvcnkocmVxdWlyZShcImpzcGRmXCIpLCByZXF1aXJlKFwiaHRtbDJjYW52YXNcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImh0bWwycGRmXCJdID0gZmFjdG9yeShyb290W1wianNwZGZcIl0sIHJvb3RbXCJodG1sMmNhbnZhc1wiXSk7XG59KShzZWxmLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pzcGRmX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfaHRtbDJjYW52YXNfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9zcmMvcGx1Z2luL2h5cGVybGlua3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcGx1Z2luL2h5cGVybGlua3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3RyaW5nX2xpbmtfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubGluay5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubGluay5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3RyaW5nX2xpbmtfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfc3RyaW5nX2xpbmtfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vd29ya2VyLmpzICovIFwiLi9zcmMvd29ya2VyLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMuanMgKi8gXCIuL3NyYy91dGlscy5qc1wiKTtcblxuXG5cbiAvLyBBZGQgaHlwZXJsaW5rIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIFBERiBjcmVhdGlvbi5cbi8vIE1haW4gbGluayBhcnJheSwgYW5kIHJlZnMgdG8gb3JpZ2luYWwgZnVuY3Rpb25zLlxuXG52YXIgbGlua0luZm8gPSBbXTtcbnZhciBvcmlnID0ge1xuICB0b0NvbnRhaW5lcjogX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmRlZmF1bHQucHJvdG90eXBlLnRvQ29udGFpbmVyLFxuICB0b1BkZjogX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmRlZmF1bHQucHJvdG90eXBlLnRvUGRmXG59O1xuXG5fd29ya2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uZGVmYXVsdC5wcm90b3R5cGUudG9Db250YWluZXIgPSBmdW5jdGlvbiB0b0NvbnRhaW5lcigpIHtcbiAgcmV0dXJuIG9yaWcudG9Db250YWluZXIuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uIHRvQ29udGFpbmVyX2h5cGVybGluaygpIHtcbiAgICAvLyBSZXRyaWV2ZSBoeXBlcmxpbmsgaW5mbyBpZiB0aGUgb3B0aW9uIGlzIGVuYWJsZWQuXG4gICAgaWYgKHRoaXMub3B0LmVuYWJsZUxpbmtzKSB7XG4gICAgICAvLyBGaW5kIGFsbCBhbmNob3IgdGFncyBhbmQgZ2V0IHRoZSBjb250YWluZXIncyBib3VuZHMgZm9yIHJlZmVyZW5jZS5cbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLnByb3AuY29udGFpbmVyO1xuICAgICAgdmFyIGxpbmtzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKTtcbiAgICAgIHZhciBjb250YWluZXJSZWN0ID0gKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18udW5pdENvbnZlcnQpKGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdGhpcy5wcm9wLnBhZ2VTaXplLmspO1xuICAgICAgbGlua0luZm8gPSBbXTsgLy8gTG9vcCB0aHJvdWdoIGVhY2ggYW5jaG9yIHRhZy5cblxuICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChsaW5rcywgZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgLy8gVHJlYXQgZWFjaCBjbGllbnQgcmVjdCBhcyBhIHNlcGFyYXRlIGxpbmsgKGZvciB0ZXh0LXdyYXBwaW5nKS5cbiAgICAgICAgdmFyIGNsaWVudFJlY3RzID0gbGluay5nZXRDbGllbnRSZWN0cygpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpZW50UmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2xpZW50UmVjdCA9ICgwLF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLnVuaXRDb252ZXJ0KShjbGllbnRSZWN0c1tpXSwgdGhpcy5wcm9wLnBhZ2VTaXplLmspO1xuICAgICAgICAgIGNsaWVudFJlY3QubGVmdCAtPSBjb250YWluZXJSZWN0LmxlZnQ7XG4gICAgICAgICAgY2xpZW50UmVjdC50b3AgLT0gY29udGFpbmVyUmVjdC50b3A7XG4gICAgICAgICAgdmFyIHBhZ2UgPSBNYXRoLmZsb29yKGNsaWVudFJlY3QudG9wIC8gdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLmhlaWdodCkgKyAxO1xuICAgICAgICAgIHZhciB0b3AgPSB0aGlzLm9wdC5tYXJnaW5bMF0gKyBjbGllbnRSZWN0LnRvcCAlIHRoaXMucHJvcC5wYWdlU2l6ZS5pbm5lci5oZWlnaHQ7XG4gICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLm9wdC5tYXJnaW5bMV0gKyBjbGllbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgbGlua0luZm8ucHVzaCh7XG4gICAgICAgICAgICBwYWdlOiBwYWdlLFxuICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgY2xpZW50UmVjdDogY2xpZW50UmVjdCxcbiAgICAgICAgICAgIGxpbms6IGxpbmtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcbn07XG5cbl93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5kZWZhdWx0LnByb3RvdHlwZS50b1BkZiA9IGZ1bmN0aW9uIHRvUGRmKCkge1xuICByZXR1cm4gb3JpZy50b1BkZi5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gdG9QZGZfaHlwZXJsaW5rKCkge1xuICAgIC8vIEFkZCBoeXBlcmxpbmtzIGlmIHRoZSBvcHRpb24gaXMgZW5hYmxlZC5cbiAgICBpZiAodGhpcy5vcHQuZW5hYmxlTGlua3MpIHtcbiAgICAgIC8vIEF0dGFjaCBlYWNoIGFuY2hvciB0YWcgYmFzZWQgb24gaW5mbyBmcm9tIHRvQ29udGFpbmVyKCkuXG4gICAgICBsaW5rSW5mby5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHRoaXMucHJvcC5wZGYuc2V0UGFnZShsLnBhZ2UpO1xuICAgICAgICB0aGlzLnByb3AucGRmLmxpbmsobC5sZWZ0LCBsLnRvcCwgbC5jbGllbnRSZWN0LndpZHRoLCBsLmNsaWVudFJlY3QuaGVpZ2h0LCB7XG4gICAgICAgICAgdXJsOiBsLmxpbmsuaHJlZlxuICAgICAgICB9KTtcbiAgICAgIH0sIHRoaXMpOyAvLyBSZXNldCB0aGUgYWN0aXZlIHBhZ2Ugb2YgdGhlIFBERiB0byB0aGUgZmluYWwgcGFnZS5cblxuICAgICAgdmFyIG5QYWdlcyA9IHRoaXMucHJvcC5wZGYuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpO1xuICAgICAgdGhpcy5wcm9wLnBkZi5zZXRQYWdlKG5QYWdlcyk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3BsdWdpbi9qc3BkZi1wbHVnaW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9wbHVnaW4vanNwZGYtcGx1Z2luLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9kZXNjcmlwdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9kZXNjcmlwdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganNwZGYgKi8gXCJqc3BkZlwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpzcGRmX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18pO1xuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLy8gSW1wb3J0IGRlcGVuZGVuY2llcy5cbiAvLyBHZXQgZGltZW5zaW9ucyBvZiBhIFBERiBwYWdlLCBhcyBkZXRlcm1pbmVkIGJ5IGpzUERGLlxuXG5qc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLmpzUERGLmdldFBhZ2VTaXplID0gZnVuY3Rpb24gKG9yaWVudGF0aW9uLCB1bml0LCBmb3JtYXQpIHtcbiAgLy8gRGVjb2RlIG9wdGlvbnMgb2JqZWN0XG4gIGlmIChfdHlwZW9mKG9yaWVudGF0aW9uKSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9yaWVudGF0aW9uO1xuICAgIG9yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvbjtcbiAgICB1bml0ID0gb3B0aW9ucy51bml0IHx8IHVuaXQ7XG4gICAgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0O1xuICB9IC8vIERlZmF1bHQgb3B0aW9uc1xuXG5cbiAgdW5pdCA9IHVuaXQgfHwgJ21tJztcbiAgZm9ybWF0ID0gZm9ybWF0IHx8ICdhNCc7XG4gIG9yaWVudGF0aW9uID0gKCcnICsgKG9yaWVudGF0aW9uIHx8ICdQJykpLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBmb3JtYXRfYXNfc3RyaW5nID0gKCcnICsgZm9ybWF0KS50b0xvd2VyQ2FzZSgpOyAvLyBTaXplIGluIHB0IG9mIHZhcmlvdXMgcGFwZXIgZm9ybWF0c1xuXG4gIHZhciBwYWdlRm9ybWF0cyA9IHtcbiAgICAnYTAnOiBbMjM4My45NCwgMzM3MC4zOV0sXG4gICAgJ2ExJzogWzE2ODMuNzgsIDIzODMuOTRdLFxuICAgICdhMic6IFsxMTkwLjU1LCAxNjgzLjc4XSxcbiAgICAnYTMnOiBbODQxLjg5LCAxMTkwLjU1XSxcbiAgICAnYTQnOiBbNTk1LjI4LCA4NDEuODldLFxuICAgICdhNSc6IFs0MTkuNTMsIDU5NS4yOF0sXG4gICAgJ2E2JzogWzI5Ny42NCwgNDE5LjUzXSxcbiAgICAnYTcnOiBbMjA5Ljc2LCAyOTcuNjRdLFxuICAgICdhOCc6IFsxNDcuNDAsIDIwOS43Nl0sXG4gICAgJ2E5JzogWzEwNC44OCwgMTQ3LjQwXSxcbiAgICAnYTEwJzogWzczLjcwLCAxMDQuODhdLFxuICAgICdiMCc6IFsyODM0LjY1LCA0MDA4LjE5XSxcbiAgICAnYjEnOiBbMjAwNC4wOSwgMjgzNC42NV0sXG4gICAgJ2IyJzogWzE0MTcuMzIsIDIwMDQuMDldLFxuICAgICdiMyc6IFsxMDAwLjYzLCAxNDE3LjMyXSxcbiAgICAnYjQnOiBbNzA4LjY2LCAxMDAwLjYzXSxcbiAgICAnYjUnOiBbNDk4LjkwLCA3MDguNjZdLFxuICAgICdiNic6IFszNTQuMzMsIDQ5OC45MF0sXG4gICAgJ2I3JzogWzI0OS40NSwgMzU0LjMzXSxcbiAgICAnYjgnOiBbMTc1Ljc1LCAyNDkuNDVdLFxuICAgICdiOSc6IFsxMjQuNzIsIDE3NS43NV0sXG4gICAgJ2IxMCc6IFs4Ny44NywgMTI0LjcyXSxcbiAgICAnYzAnOiBbMjU5OS4zNywgMzY3Ni41NF0sXG4gICAgJ2MxJzogWzE4MzYuODUsIDI1OTkuMzddLFxuICAgICdjMic6IFsxMjk4LjI3LCAxODM2Ljg1XSxcbiAgICAnYzMnOiBbOTE4LjQzLCAxMjk4LjI3XSxcbiAgICAnYzQnOiBbNjQ5LjEzLCA5MTguNDNdLFxuICAgICdjNSc6IFs0NTkuMjEsIDY0OS4xM10sXG4gICAgJ2M2JzogWzMyMy4xNSwgNDU5LjIxXSxcbiAgICAnYzcnOiBbMjI5LjYxLCAzMjMuMTVdLFxuICAgICdjOCc6IFsxNjEuNTcsIDIyOS42MV0sXG4gICAgJ2M5JzogWzExMy4zOSwgMTYxLjU3XSxcbiAgICAnYzEwJzogWzc5LjM3LCAxMTMuMzldLFxuICAgICdkbCc6IFszMTEuODEsIDYyMy42Ml0sXG4gICAgJ2xldHRlcic6IFs2MTIsIDc5Ml0sXG4gICAgJ2dvdmVybm1lbnQtbGV0dGVyJzogWzU3NiwgNzU2XSxcbiAgICAnbGVnYWwnOiBbNjEyLCAxMDA4XSxcbiAgICAnanVuaW9yLWxlZ2FsJzogWzU3NiwgMzYwXSxcbiAgICAnbGVkZ2VyJzogWzEyMjQsIDc5Ml0sXG4gICAgJ3RhYmxvaWQnOiBbNzkyLCAxMjI0XSxcbiAgICAnY3JlZGl0LWNhcmQnOiBbMTUzLCAyNDNdXG4gIH07IC8vIFVuaXQgY29udmVyc2lvblxuXG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJ3B0JzpcbiAgICAgIHZhciBrID0gMTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbW0nOlxuICAgICAgdmFyIGsgPSA3MiAvIDI1LjQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2NtJzpcbiAgICAgIHZhciBrID0gNzIgLyAyLjU0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbic6XG4gICAgICB2YXIgayA9IDcyO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdweCc6XG4gICAgICB2YXIgayA9IDcyIC8gOTY7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BjJzpcbiAgICAgIHZhciBrID0gMTI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2VtJzpcbiAgICAgIHZhciBrID0gMTI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2V4JzpcbiAgICAgIHZhciBrID0gNjtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93ICdJbnZhbGlkIHVuaXQ6ICcgKyB1bml0O1xuICB9IC8vIERpbWVuc2lvbnMgYXJlIHN0b3JlZCBhcyB1c2VyIHVuaXRzIGFuZCBjb252ZXJ0ZWQgdG8gcG9pbnRzIG9uIG91dHB1dFxuXG5cbiAgaWYgKHBhZ2VGb3JtYXRzLmhhc093blByb3BlcnR5KGZvcm1hdF9hc19zdHJpbmcpKSB7XG4gICAgdmFyIHBhZ2VIZWlnaHQgPSBwYWdlRm9ybWF0c1tmb3JtYXRfYXNfc3RyaW5nXVsxXSAvIGs7XG4gICAgdmFyIHBhZ2VXaWR0aCA9IHBhZ2VGb3JtYXRzW2Zvcm1hdF9hc19zdHJpbmddWzBdIC8gaztcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHBhZ2VIZWlnaHQgPSBmb3JtYXRbMV07XG4gICAgICB2YXIgcGFnZVdpZHRoID0gZm9ybWF0WzBdO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZvcm1hdDogJyArIGZvcm1hdCk7XG4gICAgfVxuICB9IC8vIEhhbmRsZSBwYWdlIG9yaWVudGF0aW9uXG5cblxuICBpZiAob3JpZW50YXRpb24gPT09ICdwJyB8fCBvcmllbnRhdGlvbiA9PT0gJ3BvcnRyYWl0Jykge1xuICAgIG9yaWVudGF0aW9uID0gJ3AnO1xuXG4gICAgaWYgKHBhZ2VXaWR0aCA+IHBhZ2VIZWlnaHQpIHtcbiAgICAgIHZhciB0bXAgPSBwYWdlV2lkdGg7XG4gICAgICBwYWdlV2lkdGggPSBwYWdlSGVpZ2h0O1xuICAgICAgcGFnZUhlaWdodCA9IHRtcDtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3JpZW50YXRpb24gPT09ICdsJyB8fCBvcmllbnRhdGlvbiA9PT0gJ2xhbmRzY2FwZScpIHtcbiAgICBvcmllbnRhdGlvbiA9ICdsJztcblxuICAgIGlmIChwYWdlSGVpZ2h0ID4gcGFnZVdpZHRoKSB7XG4gICAgICB2YXIgdG1wID0gcGFnZVdpZHRoO1xuICAgICAgcGFnZVdpZHRoID0gcGFnZUhlaWdodDtcbiAgICAgIHBhZ2VIZWlnaHQgPSB0bXA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93ICdJbnZhbGlkIG9yaWVudGF0aW9uOiAnICsgb3JpZW50YXRpb247XG4gIH0gLy8gUmV0dXJuIGluZm9ybWF0aW9uIChrIGlzIHRoZSB1bml0IGNvbnZlcnNpb24gcmF0aW8gZnJvbSBwdHMpXG5cblxuICB2YXIgaW5mbyA9IHtcbiAgICAnd2lkdGgnOiBwYWdlV2lkdGgsXG4gICAgJ2hlaWdodCc6IHBhZ2VIZWlnaHQsXG4gICAgJ3VuaXQnOiB1bml0LFxuICAgICdrJzoga1xuICB9O1xuICByZXR1cm4gaW5mbztcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoanNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5qc1BERik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3BsdWdpbi9wYWdlYnJlYWtzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3BsdWdpbi9wYWdlYnJlYWtzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9jb25jYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9jb25jYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9zbGljZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9zbGljZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9zbGljZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfam9pbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfam9pbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9qb2luX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3dvcmtlci5qcyAqLyBcIi4vc3JjL3dvcmtlci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIik7XG5cblxuXG5cblxuXG5cbi8qIFBhZ2VicmVhayBwbHVnaW46XG5cbiAgICBBZGRzIHBhZ2UtYnJlYWsgZnVuY3Rpb25hbGl0eSB0byB0aGUgaHRtbDJwZGYgbGlicmFyeS4gUGFnZS1icmVha3MgY2FuIGJlXG4gICAgZW5hYmxlZCBieSBDU1Mgc3R5bGVzLCBzZXQgb24gaW5kaXZpZHVhbCBlbGVtZW50cyB1c2luZyBzZWxlY3RvcnMsIG9yXG4gICAgYXZvaWRlZCBmcm9tIGJyZWFraW5nIGluc2lkZSBhbGwgZWxlbWVudHMuXG5cbiAgICBPcHRpb25zIG9uIHRoZSBgb3B0LnBhZ2VicmVha2Agb2JqZWN0OlxuXG4gICAgbW9kZTogICBTdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5nczogJ2F2b2lkLWFsbCcsICdjc3MnLCBhbmQvb3IgJ2xlZ2FjeSdcbiAgICAgICAgICAgIERlZmF1bHQ6IFsnY3NzJywgJ2xlZ2FjeSddXG5cbiAgICBiZWZvcmU6IFN0cmluZyBvciBhcnJheSBvZiBDU1Mgc2VsZWN0b3JzIGZvciB3aGljaCB0byBhZGQgcGFnZS1icmVha3NcbiAgICAgICAgICAgIGJlZm9yZSBlYWNoIGVsZW1lbnQuIENhbiBiZSBhIHNwZWNpZmljIGVsZW1lbnQgd2l0aCBhbiBJRFxuICAgICAgICAgICAgKCcjbXlJRCcpLCBhbGwgZWxlbWVudHMgb2YgYSB0eXBlIChlLmcuICdpbWcnKSwgYWxsIG9mIGEgY2xhc3NcbiAgICAgICAgICAgICgnLm15Q2xhc3MnKSwgb3IgZXZlbiAnKicgdG8gbWF0Y2ggZXZlcnkgZWxlbWVudC5cblxuICAgIGFmdGVyOiAgTGlrZSAnYmVmb3JlJywgYnV0IGFkZHMgYSBwYWdlLWJyZWFrIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBlbGVtZW50LlxuXG4gICAgYXZvaWQ6ICBMaWtlICdiZWZvcmUnLCBidXQgYXZvaWRzIHBhZ2UtYnJlYWtzIG9uIHRoZXNlIGVsZW1lbnRzLiBZb3UgY2FuXG4gICAgICAgICAgICBlbmFibGUgdGhpcyBmZWF0dXJlIG9uIGV2ZXJ5IGVsZW1lbnQgdXNpbmcgdGhlICdhdm9pZC1hbGwnIG1vZGUuXG4qL1xuLy8gUmVmcyB0byBvcmlnaW5hbCBmdW5jdGlvbnMuXG5cbnZhciBvcmlnID0ge1xuICB0b0NvbnRhaW5lcjogX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmRlZmF1bHQucHJvdG90eXBlLnRvQ29udGFpbmVyXG59OyAvLyBBZGQgcGFnZWJyZWFrIGRlZmF1bHQgb3B0aW9ucyB0byB0aGUgV29ya2VyIHRlbXBsYXRlLlxuXG5fd29ya2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uZGVmYXVsdC50ZW1wbGF0ZS5vcHQucGFnZWJyZWFrID0ge1xuICBtb2RlOiBbJ2NzcycsICdsZWdhY3knXSxcbiAgYmVmb3JlOiBbXSxcbiAgYWZ0ZXI6IFtdLFxuICBhdm9pZDogW11cbn07XG5cbl93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5kZWZhdWx0LnByb3RvdHlwZS50b0NvbnRhaW5lciA9IGZ1bmN0aW9uIHRvQ29udGFpbmVyKCkge1xuICByZXR1cm4gb3JpZy50b0NvbnRhaW5lci5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gdG9Db250YWluZXJfcGFnZWJyZWFrKCkge1xuICAgIC8vIFNldHVwIHJvb3QgZWxlbWVudCBhbmQgaW5uZXIgcGFnZSBoZWlnaHQuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnByb3AuY29udGFpbmVyO1xuICAgIHZhciBweFBhZ2VIZWlnaHQgPSB0aGlzLnByb3AucGFnZVNpemUuaW5uZXIucHguaGVpZ2h0OyAvLyBDaGVjayBhbGwgcmVxdWVzdGVkIG1vZGVzLlxuXG4gICAgdmFyIG1vZGVTcmMgPSBbXS5jb25jYXQodGhpcy5vcHQucGFnZWJyZWFrLm1vZGUpO1xuICAgIHZhciBtb2RlID0ge1xuICAgICAgYXZvaWRBbGw6IG1vZGVTcmMuaW5kZXhPZignYXZvaWQtYWxsJykgIT09IC0xLFxuICAgICAgY3NzOiBtb2RlU3JjLmluZGV4T2YoJ2NzcycpICE9PSAtMSxcbiAgICAgIGxlZ2FjeTogbW9kZVNyYy5pbmRleE9mKCdsZWdhY3knKSAhPT0gLTFcbiAgICB9OyAvLyBHZXQgYXJyYXlzIG9mIGFsbCBleHBsaWNpdGx5IHJlcXVlc3RlZCBlbGVtZW50cy5cblxuICAgIHZhciBzZWxlY3QgPSB7fTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgWydiZWZvcmUnLCAnYWZ0ZXInLCAnYXZvaWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBhbGwgPSBtb2RlLmF2b2lkQWxsICYmIGtleSA9PT0gJ2F2b2lkJztcbiAgICAgIHNlbGVjdFtrZXldID0gYWxsID8gW10gOiBbXS5jb25jYXQoc2VsZi5vcHQucGFnZWJyZWFrW2tleV0gfHwgW10pO1xuXG4gICAgICBpZiAoc2VsZWN0W2tleV0ubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxlY3Rba2V5XSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHJvb3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rba2V5XS5qb2luKCcsICcpKSk7XG4gICAgICB9XG4gICAgfSk7IC8vIEdldCBhbGwgbGVnYWN5IHBhZ2UtYnJlYWsgZWxlbWVudHMuXG5cbiAgICB2YXIgbGVnYWN5RWxzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcuaHRtbDJwZGZfX3BhZ2UtYnJlYWsnKTtcbiAgICBsZWdhY3lFbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsZWdhY3lFbHMpOyAvLyBMb29wIHRocm91Z2ggYWxsIGVsZW1lbnRzLlxuXG4gICAgdmFyIGVscyA9IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnKicpO1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWxzLCBmdW5jdGlvbiBwYWdlYnJlYWtfbG9vcChlbCkge1xuICAgICAgLy8gU2V0dXAgcGFnZWJyZWFrIHJ1bGVzIGJhc2VkIG9uIGxlZ2FjeSBhbmQgYXZvaWRBbGwgbW9kZXMuXG4gICAgICB2YXIgcnVsZXMgPSB7XG4gICAgICAgIGJlZm9yZTogZmFsc2UsXG4gICAgICAgIGFmdGVyOiBtb2RlLmxlZ2FjeSAmJiBsZWdhY3lFbHMuaW5kZXhPZihlbCkgIT09IC0xLFxuICAgICAgICBhdm9pZDogbW9kZS5hdm9pZEFsbFxuICAgICAgfTsgLy8gQWRkIHJ1bGVzIGZvciBjc3MgbW9kZS5cblxuICAgICAgaWYgKG1vZGUuY3NzKSB7XG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgaXMgdmFsaWQgd2l0aCBpRnJhbWVzLlxuICAgICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7IC8vIFRPRE86IEhhbmRsZSAnbGVmdCcgYW5kICdyaWdodCcgY29ycmVjdGx5LlxuICAgICAgICAvLyBUT0RPOiBBZGQgc3VwcG9ydCBmb3IgJ2F2b2lkJyBvbiBicmVha0JlZm9yZS9BZnRlci5cblxuICAgICAgICB2YXIgYnJlYWtPcHQgPSBbJ2Fsd2F5cycsICdwYWdlJywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgICAgICAgdmFyIGF2b2lkT3B0ID0gWydhdm9pZCcsICdhdm9pZC1wYWdlJ107XG4gICAgICAgIHJ1bGVzID0ge1xuICAgICAgICAgIGJlZm9yZTogcnVsZXMuYmVmb3JlIHx8IGJyZWFrT3B0LmluZGV4T2Yoc3R5bGUuYnJlYWtCZWZvcmUgfHwgc3R5bGUucGFnZUJyZWFrQmVmb3JlKSAhPT0gLTEsXG4gICAgICAgICAgYWZ0ZXI6IHJ1bGVzLmFmdGVyIHx8IGJyZWFrT3B0LmluZGV4T2Yoc3R5bGUuYnJlYWtBZnRlciB8fCBzdHlsZS5wYWdlQnJlYWtBZnRlcikgIT09IC0xLFxuICAgICAgICAgIGF2b2lkOiBydWxlcy5hdm9pZCB8fCBhdm9pZE9wdC5pbmRleE9mKHN0eWxlLmJyZWFrSW5zaWRlIHx8IHN0eWxlLnBhZ2VCcmVha0luc2lkZSkgIT09IC0xXG4gICAgICAgIH07XG4gICAgICB9IC8vIEFkZCBydWxlcyBmb3IgZXhwbGljaXQgcmVxdWVzdHMuXG5cblxuICAgICAgT2JqZWN0LmtleXMocnVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBydWxlc1trZXldID0gcnVsZXNba2V5XSB8fCBzZWxlY3Rba2V5XS5pbmRleE9mKGVsKSAhPT0gLTE7XG4gICAgICB9KTsgLy8gR2V0IGVsZW1lbnQgcG9zaXRpb24gb24gdGhlIHNjcmVlbi5cbiAgICAgIC8vIFRPRE86IFN1YnRyYWN0IHRoZSB0b3Agb2YgdGhlIGNvbnRhaW5lciBmcm9tIGNsaWVudFJlY3QudG9wL2JvdHRvbT9cblxuICAgICAgdmFyIGNsaWVudFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gQXZvaWQ6IENoZWNrIGlmIGEgYnJlYWsgaGFwcGVucyBtaWQtZWxlbWVudC5cblxuICAgICAgaWYgKHJ1bGVzLmF2b2lkICYmICFydWxlcy5iZWZvcmUpIHtcbiAgICAgICAgdmFyIHN0YXJ0UGFnZSA9IE1hdGguZmxvb3IoY2xpZW50UmVjdC50b3AgLyBweFBhZ2VIZWlnaHQpO1xuICAgICAgICB2YXIgZW5kUGFnZSA9IE1hdGguZmxvb3IoY2xpZW50UmVjdC5ib3R0b20gLyBweFBhZ2VIZWlnaHQpO1xuICAgICAgICB2YXIgblBhZ2VzID0gTWF0aC5hYnMoY2xpZW50UmVjdC5ib3R0b20gLSBjbGllbnRSZWN0LnRvcCkgLyBweFBhZ2VIZWlnaHQ7IC8vIFR1cm4gb24gcnVsZXMuYmVmb3JlIGlmIHRoZSBlbCBpcyBicm9rZW4gYW5kIGlzIGF0IG1vc3Qgb25lIHBhZ2UgbG9uZy5cblxuICAgICAgICBpZiAoZW5kUGFnZSAhPT0gc3RhcnRQYWdlICYmIG5QYWdlcyA8PSAxKSB7XG4gICAgICAgICAgcnVsZXMuYmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBCZWZvcmU6IENyZWF0ZSBhIHBhZGRpbmcgZGl2IHRvIHB1c2ggdGhlIGVsZW1lbnQgdG8gdGhlIG5leHQgcGFnZS5cblxuXG4gICAgICBpZiAocnVsZXMuYmVmb3JlKSB7XG4gICAgICAgIHZhciBwYWQgPSAoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5jcmVhdGVFbGVtZW50KSgnZGl2Jywge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgaGVpZ2h0OiBweFBhZ2VIZWlnaHQgLSBjbGllbnRSZWN0LnRvcCAlIHB4UGFnZUhlaWdodCArICdweCdcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwYWQsIGVsKTtcbiAgICAgIH0gLy8gQWZ0ZXI6IENyZWF0ZSBhIHBhZGRpbmcgZGl2IHRvIGZpbGwgdGhlIHJlbWFpbmluZyBwYWdlLlxuXG5cbiAgICAgIGlmIChydWxlcy5hZnRlcikge1xuICAgICAgICB2YXIgcGFkID0gKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uY3JlYXRlRWxlbWVudCkoJ2RpdicsIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgIGhlaWdodDogcHhQYWdlSGVpZ2h0IC0gY2xpZW50UmVjdC5ib3R0b20gJSBweFBhZ2VIZWlnaHQgKyAncHgnXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocGFkLCBlbC5uZXh0U2libGluZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIm9ialR5cGVcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIG9ialR5cGU7IH0sXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiY3JlYXRlRWxlbWVudFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gY3JlYXRlRWxlbWVudDsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJjbG9uZU5vZGVcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNsb25lTm9kZTsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJ1bml0Q29udmVydFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gdW5pdENvbnZlcnQ7IH0sXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwidG9QeFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gdG9QeDsgfVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX251bWJlcl9jb25zdHJ1Y3Rvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX251bWJlcl9jb25zdHJ1Y3Rvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19udW1iZXJfY29uc3RydWN0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9kZXNjcmlwdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9kZXNjcmlwdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fKTtcblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLy8gRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgdmFyaWFibGUvb2JqZWN0LlxudmFyIG9ialR5cGUgPSBmdW5jdGlvbiBvYmpUeXBlKG9iaikge1xuICB2YXIgdHlwZSA9IF90eXBlb2Yob2JqKTtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAndW5kZWZpbmVkJztlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCBvYmogaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiAnc3RyaW5nJztlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAnbnVtYmVyJztlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nIHx8IG9iaiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSByZXR1cm4gJ2Z1bmN0aW9uJztlbHNlIGlmICghIW9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5KSByZXR1cm4gJ2FycmF5JztlbHNlIGlmIChvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKSByZXR1cm4gJ2VsZW1lbnQnO2Vsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSByZXR1cm4gJ29iamVjdCc7ZWxzZSByZXR1cm4gJ3Vua25vd24nO1xufTsgLy8gQ3JlYXRlIGFuIEhUTUwgZWxlbWVudCB3aXRoIG9wdGlvbmFsIGNsYXNzTmFtZSwgaW5uZXJIVE1MLCBhbmQgc3R5bGUuXG5cbnZhciBjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBvcHQpIHtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKG9wdC5jbGFzc05hbWUpIGVsLmNsYXNzTmFtZSA9IG9wdC5jbGFzc05hbWU7XG5cbiAgaWYgKG9wdC5pbm5lckhUTUwpIHtcbiAgICBlbC5pbm5lckhUTUwgPSBvcHQuaW5uZXJIVE1MO1xuICAgIHZhciBzY3JpcHRzID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IHNjcmlwdHMubGVuZ3RoOyBpLS0gPiAwOyBudWxsKSB7XG4gICAgICBzY3JpcHRzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9wdC5zdHlsZSkge1xuICAgIGVsLnN0eWxlW2tleV0gPSBvcHQuc3R5bGVba2V5XTtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn07IC8vIERlZXAtY2xvbmUgYSBub2RlIGFuZCBwcmVzZXJ2ZSBjb250ZW50cy9wcm9wZXJ0aWVzLlxuXG52YXIgY2xvbmVOb2RlID0gZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUsIGphdmFzY3JpcHRFbmFibGVkKSB7XG4gIC8vIFJlY3Vyc2l2ZWx5IGNsb25lIHRoZSBub2RlLlxuICB2YXIgY2xvbmUgPSBub2RlLm5vZGVUeXBlID09PSAzID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS5ub2RlVmFsdWUpIDogbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuXG4gIGZvciAodmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgIGlmIChqYXZhc2NyaXB0RW5hYmxlZCA9PT0gdHJ1ZSB8fCBjaGlsZC5ub2RlVHlwZSAhPT0gMSB8fCBjaGlsZC5ub2RlTmFtZSAhPT0gJ1NDUklQVCcpIHtcbiAgICAgIGNsb25lLmFwcGVuZENoaWxkKGNsb25lTm9kZShjaGlsZCwgamF2YXNjcmlwdEVuYWJsZWQpKTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgIC8vIFByZXNlcnZlIGNvbnRlbnRzL3Byb3BlcnRpZXMgb2Ygc3BlY2lhbCBub2Rlcy5cbiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ0NBTlZBUycpIHtcbiAgICAgIGNsb25lLndpZHRoID0gbm9kZS53aWR0aDtcbiAgICAgIGNsb25lLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgY2xvbmUuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2Uobm9kZSwgMCwgMCk7XG4gICAgfSBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09PSAnVEVYVEFSRUEnIHx8IG5vZGUubm9kZU5hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICBjbG9uZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgfSAvLyBQcmVzZXJ2ZSB0aGUgbm9kZSdzIHNjcm9sbCBwb3NpdGlvbiB3aGVuIGl0IGxvYWRzLlxuXG5cbiAgICBjbG9uZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgY2xvbmUuc2Nyb2xsVG9wID0gbm9kZS5zY3JvbGxUb3A7XG4gICAgICBjbG9uZS5zY3JvbGxMZWZ0ID0gbm9kZS5zY3JvbGxMZWZ0O1xuICAgIH0sIHRydWUpO1xuICB9IC8vIFJldHVybiB0aGUgY2xvbmVkIG5vZGUuXG5cblxuICByZXR1cm4gY2xvbmU7XG59OyAvLyBDb252ZXJ0IHVuaXRzIGZyb20gcHggdXNpbmcgdGhlIGNvbnZlcnNpb24gdmFsdWUgJ2snIGZyb20ganNQREYuXG5cbnZhciB1bml0Q29udmVydCA9IGZ1bmN0aW9uIHVuaXRDb252ZXJ0KG9iaiwgaykge1xuICBpZiAob2JqVHlwZShvYmopID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBvYmogKiA3MiAvIDk2IC8gaztcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV3T2JqID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldICogNzIgLyA5NiAvIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iajtcbiAgfVxufTsgLy8gQ29udmVydCB1bml0cyB0byBweCB1c2luZyB0aGUgY29udmVyc2lvbiB2YWx1ZSAnaycgZnJvbSBqc1BERi5cblxudmFyIHRvUHggPSBmdW5jdGlvbiB0b1B4KHZhbCwgaykge1xuICByZXR1cm4gTWF0aC5mbG9vcih2YWwgKiBrIC8gNzIgKiA5Nik7XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy93b3JrZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3dvcmtlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9hc3NpZ25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9hc3NpZ25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2Fzc2lnbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfbWFwX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfbWFwX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X21hcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2tleXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2tleXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2tleXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2NvbmNhdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2NvbmNhdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9jb25jYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfcmVnZXhwX3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfcmVnZXhwX3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19yZWdleHBfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19mdW5jdGlvbl9uYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19mdW5jdGlvbl9uYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX2Z1bmN0aW9uX25hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganNwZGYgKi8gXCJqc3BkZlwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpzcGRmX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGh0bWwyY2FudmFzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBodG1sMmNhbnZhcyAqLyBcImh0bWwyY2FudmFzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGh0bWwyY2FudmFzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaHRtbDJjYW52YXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy5qcyAqLyBcIi4vc3JjL3V0aWxzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGVzNl9wcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZXM2LXByb21pc2UgKi8gXCIuL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGVzNl9wcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGVzNl9wcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBQcm9taXNlID0gKGVzNl9wcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fX2RlZmF1bHQoKS5Qcm9taXNlKTtcbi8qIC0tLS0tIENPTlNUUlVDVE9SIC0tLS0tICovXG5cbnZhciBXb3JrZXIgPSBmdW5jdGlvbiBXb3JrZXIob3B0KSB7XG4gIC8vIENyZWF0ZSB0aGUgcm9vdCBwYXJlbnQgZm9yIHRoZSBwcm90byBjaGFpbiwgYW5kIHRoZSBzdGFydGluZyBXb3JrZXIuXG4gIHZhciByb290ID0gT2JqZWN0LmFzc2lnbihXb3JrZXIuY29udmVydChQcm9taXNlLnJlc29sdmUoKSksIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoV29ya2VyLnRlbXBsYXRlKSkpO1xuICB2YXIgc2VsZiA9IFdvcmtlci5jb252ZXJ0KFByb21pc2UucmVzb2x2ZSgpLCByb290KTsgLy8gU2V0IHByb2dyZXNzLCBvcHRpb25hbCBzZXR0aW5ncywgYW5kIHJldHVybi5cblxuICBzZWxmID0gc2VsZi5zZXRQcm9ncmVzcygxLCBXb3JrZXIsIDEsIFtXb3JrZXJdKTtcbiAgc2VsZiA9IHNlbGYuc2V0KG9wdCk7XG4gIHJldHVybiBzZWxmO1xufTsgLy8gQm9pbGVycGxhdGUgZm9yIHN1YmNsYXNzaW5nIFByb21pc2UuXG5cblxuV29ya2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuV29ya2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdvcmtlcjsgLy8gQ29udmVydHMvY2FzdHMgcHJvbWlzZXMgaW50byBXb3JrZXJzLlxuXG5Xb3JrZXIuY29udmVydCA9IGZ1bmN0aW9uIGNvbnZlcnQocHJvbWlzZSwgaW5oZXJpdCkge1xuICAvLyBVc2VzIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgdG8gcmVjZWl2ZSBjaGFuZ2VzIG1hZGUgdG8gYW5jZXN0b3JzJyBwcm9wZXJ0aWVzLlxuICBwcm9taXNlLl9fcHJvdG9fXyA9IGluaGVyaXQgfHwgV29ya2VyLnByb3RvdHlwZTtcbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5Xb3JrZXIudGVtcGxhdGUgPSB7XG4gIHByb3A6IHtcbiAgICBzcmM6IG51bGwsXG4gICAgY29udGFpbmVyOiBudWxsLFxuICAgIG92ZXJsYXk6IG51bGwsXG4gICAgY2FudmFzOiBudWxsLFxuICAgIGltZzogbnVsbCxcbiAgICBwZGY6IG51bGwsXG4gICAgcGFnZVNpemU6IG51bGxcbiAgfSxcbiAgcHJvZ3Jlc3M6IHtcbiAgICB2YWw6IDAsXG4gICAgc3RhdGU6IG51bGwsXG4gICAgbjogMCxcbiAgICBzdGFjazogW11cbiAgfSxcbiAgb3B0OiB7XG4gICAgZmlsZW5hbWU6ICdmaWxlLnBkZicsXG4gICAgbWFyZ2luOiBbMCwgMCwgMCwgMF0sXG4gICAgaW1hZ2U6IHtcbiAgICAgIHR5cGU6ICdqcGVnJyxcbiAgICAgIHF1YWxpdHk6IDAuOTVcbiAgICB9LFxuICAgIGVuYWJsZUxpbmtzOiB0cnVlLFxuICAgIGh0bWwyY2FudmFzOiB7fSxcbiAgICBqc1BERjoge31cbiAgfVxufTtcbi8qIC0tLS0tIEZST00gLyBUTyAtLS0tLSAqL1xuXG5Xb3JrZXIucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiBmcm9tKHNyYywgdHlwZSkge1xuICBmdW5jdGlvbiBnZXRUeXBlKHNyYykge1xuICAgIHN3aXRjaCAoKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLm9ialR5cGUpKHNyYykpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcblxuICAgICAgY2FzZSAnZWxlbWVudCc6XG4gICAgICAgIHJldHVybiBzcmMubm9kZU5hbWUudG9Mb3dlckNhc2UgJiYgc3JjLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnID8gJ2NhbnZhcycgOiAnZWxlbWVudCc7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiBmcm9tX21haW4oKSB7XG4gICAgdHlwZSA9IHR5cGUgfHwgZ2V0VHlwZShzcmMpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoe1xuICAgICAgICAgIHNyYzogKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLmNyZWF0ZUVsZW1lbnQpKCdkaXYnLCB7XG4gICAgICAgICAgICBpbm5lckhUTUw6IHNyY1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdlbGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICBzcmM6IHNyY1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnY2FudmFzJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICBjYW52YXM6IHNyY1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICBpbWc6IHNyY1xuICAgICAgICB9KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1Vua25vd24gc291cmNlIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiB0byh0YXJnZXQpIHtcbiAgLy8gUm91dGUgdGhlICd0bycgcmVxdWVzdCB0byB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kLlxuICBzd2l0Y2ggKHRhcmdldCkge1xuICAgIGNhc2UgJ2NvbnRhaW5lcic6XG4gICAgICByZXR1cm4gdGhpcy50b0NvbnRhaW5lcigpO1xuXG4gICAgY2FzZSAnY2FudmFzJzpcbiAgICAgIHJldHVybiB0aGlzLnRvQ2FudmFzKCk7XG5cbiAgICBjYXNlICdpbWcnOlxuICAgICAgcmV0dXJuIHRoaXMudG9JbWcoKTtcblxuICAgIGNhc2UgJ3BkZic6XG4gICAgICByZXR1cm4gdGhpcy50b1BkZigpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0aGlzLmVycm9yKCdJbnZhbGlkIHRhcmdldC4nKTtcbiAgfVxufTtcblxuV29ya2VyLnByb3RvdHlwZS50b0NvbnRhaW5lciA9IGZ1bmN0aW9uIHRvQ29udGFpbmVyKCkge1xuICAvLyBTZXQgdXAgZnVuY3Rpb24gcHJlcmVxdWlzaXRlcy5cbiAgdmFyIHByZXJlcXMgPSBbZnVuY3Rpb24gY2hlY2tTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcC5zcmMgfHwgdGhpcy5lcnJvcignQ2Fubm90IGR1cGxpY2F0ZSAtIG5vIHNvdXJjZSBIVE1MLicpO1xuICB9LCBmdW5jdGlvbiBjaGVja1BhZ2VTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnByb3AucGFnZVNpemUgfHwgdGhpcy5zZXRQYWdlU2l6ZSgpO1xuICB9XTtcbiAgcmV0dXJuIHRoaXMudGhlbkxpc3QocHJlcmVxcykudGhlbihmdW5jdGlvbiB0b0NvbnRhaW5lcl9tYWluKCkge1xuICAgIC8vIERlZmluZSB0aGUgQ1NTIHN0eWxlcyBmb3IgdGhlIGNvbnRhaW5lciBhbmQgaXRzIG92ZXJsYXkgcGFyZW50LlxuICAgIHZhciBvdmVybGF5Q1NTID0ge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICB6SW5kZXg6IDEwMDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknXG4gICAgfTtcbiAgICB2YXIgY29udGFpbmVyQ1NTID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLndpZHRoICsgdGhpcy5wcm9wLnBhZ2VTaXplLnVuaXQsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgIG1hcmdpbjogJ2F1dG8nLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnXG4gICAgfTsgLy8gU2V0IHRoZSBvdmVybGF5IHRvIGhpZGRlbiAoY291bGQgYmUgY2hhbmdlZCBpbiB0aGUgZnV0dXJlIHRvIHByb3ZpZGUgYSBwcmludCBwcmV2aWV3KS5cblxuICAgIG92ZXJsYXlDU1Mub3BhY2l0eSA9IDA7IC8vIENyZWF0ZSBhbmQgYXR0YWNoIHRoZSBlbGVtZW50cy5cblxuICAgIHZhciBzb3VyY2UgPSAoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18uY2xvbmVOb2RlKSh0aGlzLnByb3Auc3JjLCB0aGlzLm9wdC5odG1sMmNhbnZhcy5qYXZhc2NyaXB0RW5hYmxlZCk7XG4gICAgdGhpcy5wcm9wLm92ZXJsYXkgPSAoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18uY3JlYXRlRWxlbWVudCkoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2h0bWwycGRmX19vdmVybGF5JyxcbiAgICAgIHN0eWxlOiBvdmVybGF5Q1NTXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wLmNvbnRhaW5lciA9ICgwLF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXy5jcmVhdGVFbGVtZW50KSgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAnaHRtbDJwZGZfX2NvbnRhaW5lcicsXG4gICAgICBzdHlsZTogY29udGFpbmVyQ1NTXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wLmNvbnRhaW5lci5hcHBlbmRDaGlsZChzb3VyY2UpO1xuICAgIHRoaXMucHJvcC5vdmVybGF5LmFwcGVuZENoaWxkKHRoaXMucHJvcC5jb250YWluZXIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wcm9wLm92ZXJsYXkpO1xuICB9KTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUudG9DYW52YXMgPSBmdW5jdGlvbiB0b0NhbnZhcygpIHtcbiAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gIHZhciBwcmVyZXFzID0gW2Z1bmN0aW9uIGNoZWNrQ29udGFpbmVyKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMucHJvcC5jb250YWluZXIpIHx8IHRoaXMudG9Db250YWluZXIoKTtcbiAgfV07IC8vIEZ1bGZpbGwgcHJlcmVxcyB0aGVuIGNyZWF0ZSB0aGUgY2FudmFzLlxuXG4gIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gdG9DYW52YXNfbWFpbigpIHtcbiAgICAvLyBIYW5kbGUgb2xkLWZhc2hpb25lZCAnb25yZW5kZXJlZCcgYXJndW1lbnQuXG4gICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdC5odG1sMmNhbnZhcyk7XG4gICAgZGVsZXRlIG9wdGlvbnMub25yZW5kZXJlZDtcbiAgICByZXR1cm4gaHRtbDJjYW52YXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyh0aGlzLnByb3AuY29udGFpbmVyLCBvcHRpb25zKTtcbiAgfSkudGhlbihmdW5jdGlvbiB0b0NhbnZhc19wb3N0KGNhbnZhcykge1xuICAgIC8vIEhhbmRsZSBvbGQtZmFzaGlvbmVkICdvbnJlbmRlcmVkJyBhcmd1bWVudC5cbiAgICB2YXIgb25SZW5kZXJlZCA9IHRoaXMub3B0Lmh0bWwyY2FudmFzLm9ucmVuZGVyZWQgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICBvblJlbmRlcmVkKGNhbnZhcyk7XG4gICAgdGhpcy5wcm9wLmNhbnZhcyA9IGNhbnZhcztcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMucHJvcC5vdmVybGF5KTtcbiAgfSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLnRvSW1nID0gZnVuY3Rpb24gdG9JbWcoKSB7XG4gIC8vIFNldCB1cCBmdW5jdGlvbiBwcmVyZXF1aXNpdGVzLlxuICB2YXIgcHJlcmVxcyA9IFtmdW5jdGlvbiBjaGVja0NhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wLmNhbnZhcyB8fCB0aGlzLnRvQ2FudmFzKCk7XG4gIH1dOyAvLyBGdWxmaWxsIHByZXJlcXMgdGhlbiBjcmVhdGUgdGhlIGltYWdlLlxuXG4gIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gdG9JbWdfbWFpbigpIHtcbiAgICB2YXIgaW1nRGF0YSA9IHRoaXMucHJvcC5jYW52YXMudG9EYXRhVVJMKCdpbWFnZS8nICsgdGhpcy5vcHQuaW1hZ2UudHlwZSwgdGhpcy5vcHQuaW1hZ2UucXVhbGl0eSk7XG4gICAgdGhpcy5wcm9wLmltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIHRoaXMucHJvcC5pbWcuc3JjID0gaW1nRGF0YTtcbiAgfSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLnRvUGRmID0gZnVuY3Rpb24gdG9QZGYoKSB7XG4gIC8vIFNldCB1cCBmdW5jdGlvbiBwcmVyZXF1aXNpdGVzLlxuICB2YXIgcHJlcmVxcyA9IFtmdW5jdGlvbiBjaGVja0NhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wLmNhbnZhcyB8fCB0aGlzLnRvQ2FudmFzKCk7XG4gIH0sIGZ1bmN0aW9uIGNoZWNrUGFnZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcC5wYWdlU2l6ZSB8fCB0aGlzLnNldFBhZ2VTaXplKCk7XG4gIH1dOyAvLyBGdWxmaWxsIHByZXJlcXMgdGhlbiBjcmVhdGUgdGhlIGltYWdlLlxuXG4gIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gdG9QZGZfbWFpbigpIHtcbiAgICAvLyBDcmVhdGUgbG9jYWwgY29waWVzIG9mIGZyZXF1ZW50bHkgdXNlZCBwcm9wZXJ0aWVzLlxuICAgIHZhciBjYW52YXMgPSB0aGlzLnByb3AuY2FudmFzO1xuICAgIHZhciBvcHQgPSB0aGlzLm9wdDsgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgcGFnZXMuXG5cbiAgICB2YXIgcHhGdWxsSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB2YXIgcHhQYWdlSGVpZ2h0ID0gTWF0aC5mbG9vcihjYW52YXMud2lkdGggKiB0aGlzLnByb3AucGFnZVNpemUuaW5uZXIucmF0aW8pO1xuICAgIHZhciBuUGFnZXMgPSBNYXRoLmNlaWwocHhGdWxsSGVpZ2h0IC8gcHhQYWdlSGVpZ2h0KTsgLy8gRGVmaW5lIHBhZ2VIZWlnaHQgc2VwYXJhdGVseSBzbyBpdCBjYW4gYmUgdHJpbW1lZCBvbiB0aGUgZmluYWwgcGFnZS5cblxuICAgIHZhciBwYWdlSGVpZ2h0ID0gdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLmhlaWdodDsgLy8gQ3JlYXRlIGEgb25lLXBhZ2UgY2FudmFzIHRvIHNwbGl0IHVwIHRoZSBmdWxsIGltYWdlLlxuXG4gICAgdmFyIHBhZ2VDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgcGFnZUN0eCA9IHBhZ2VDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBwYWdlQ2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIHBhZ2VDYW52YXMuaGVpZ2h0ID0gcHhQYWdlSGVpZ2h0OyAvLyBJbml0aWFsaXplIHRoZSBQREYuXG5cbiAgICB0aGlzLnByb3AucGRmID0gdGhpcy5wcm9wLnBkZiB8fCBuZXcganNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXy5qc1BERihvcHQuanNQREYpO1xuXG4gICAgZm9yICh2YXIgcGFnZSA9IDA7IHBhZ2UgPCBuUGFnZXM7IHBhZ2UrKykge1xuICAgICAgLy8gVHJpbSB0aGUgZmluYWwgcGFnZSB0byByZWR1Y2UgZmlsZSBzaXplLlxuICAgICAgaWYgKHBhZ2UgPT09IG5QYWdlcyAtIDEgJiYgcHhGdWxsSGVpZ2h0ICUgcHhQYWdlSGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgIHBhZ2VDYW52YXMuaGVpZ2h0ID0gcHhGdWxsSGVpZ2h0ICUgcHhQYWdlSGVpZ2h0O1xuICAgICAgICBwYWdlSGVpZ2h0ID0gcGFnZUNhbnZhcy5oZWlnaHQgKiB0aGlzLnByb3AucGFnZVNpemUuaW5uZXIud2lkdGggLyBwYWdlQ2FudmFzLndpZHRoO1xuICAgICAgfSAvLyBEaXNwbGF5IHRoZSBwYWdlLlxuXG5cbiAgICAgIHZhciB3ID0gcGFnZUNhbnZhcy53aWR0aDtcbiAgICAgIHZhciBoID0gcGFnZUNhbnZhcy5oZWlnaHQ7XG4gICAgICBwYWdlQ3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBwYWdlQ3R4LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgcGFnZUN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCBwYWdlICogcHhQYWdlSGVpZ2h0LCB3LCBoLCAwLCAwLCB3LCBoKTsgLy8gQWRkIHRoZSBwYWdlIHRvIHRoZSBQREYuXG5cbiAgICAgIGlmIChwYWdlKSB0aGlzLnByb3AucGRmLmFkZFBhZ2UoKTtcbiAgICAgIHZhciBpbWdEYXRhID0gcGFnZUNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlLycgKyBvcHQuaW1hZ2UudHlwZSwgb3B0LmltYWdlLnF1YWxpdHkpO1xuICAgICAgdGhpcy5wcm9wLnBkZi5hZGRJbWFnZShpbWdEYXRhLCBvcHQuaW1hZ2UudHlwZSwgb3B0Lm1hcmdpblsxXSwgb3B0Lm1hcmdpblswXSwgdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLndpZHRoLCBwYWdlSGVpZ2h0KTtcbiAgICB9XG4gIH0pO1xufTtcbi8qIC0tLS0tIE9VVFBVVCAvIFNBVkUgLS0tLS0gKi9cblxuXG5Xb3JrZXIucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uIG91dHB1dCh0eXBlLCBvcHRpb25zLCBzcmMpIHtcbiAgLy8gUmVkaXJlY3QgcmVxdWVzdHMgdG8gdGhlIGNvcnJlY3QgZnVuY3Rpb24gKG91dHB1dFBkZiAvIG91dHB1dEltZykuXG4gIHNyYyA9IHNyYyB8fCAncGRmJztcblxuICBpZiAoc3JjLnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnIHx8IHNyYy50b0xvd2VyQ2FzZSgpID09PSAnaW1hZ2UnKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0SW1nKHR5cGUsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm91dHB1dFBkZih0eXBlLCBvcHRpb25zKTtcbiAgfVxufTtcblxuV29ya2VyLnByb3RvdHlwZS5vdXRwdXRQZGYgPSBmdW5jdGlvbiBvdXRwdXRQZGYodHlwZSwgb3B0aW9ucykge1xuICAvLyBTZXQgdXAgZnVuY3Rpb24gcHJlcmVxdWlzaXRlcy5cbiAgdmFyIHByZXJlcXMgPSBbZnVuY3Rpb24gY2hlY2tQZGYoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcC5wZGYgfHwgdGhpcy50b1BkZigpO1xuICB9XTsgLy8gRnVsZmlsbCBwcmVyZXFzIHRoZW4gcGVyZm9ybSB0aGUgYXBwcm9wcmlhdGUgb3V0cHV0LlxuXG4gIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gb3V0cHV0UGRmX21haW4oKSB7XG4gICAgLyogQ3VycmVudGx5IGltcGxlbWVudGVkIG91dHB1dCB0eXBlczpcbiAgICAgKiAgICBodHRwczovL3Jhd2dpdC5jb20vTXJSaW8vanNQREYvbWFzdGVyL2RvY3MvanNwZGYuanMuaHRtbCNsaW5lOTkyXG4gICAgICogIHNhdmUob3B0aW9ucyksIGFycmF5YnVmZmVyLCBibG9iLCBibG9idXJpL2Jsb2J1cmwsXG4gICAgICogIGRhdGF1cmlzdHJpbmcvZGF0YXVybHN0cmluZywgZGF0YXVybG5ld3dpbmRvdywgZGF0YXVyaS9kYXRhdXJsXG4gICAgICovXG4gICAgcmV0dXJuIHRoaXMucHJvcC5wZGYub3V0cHV0KHR5cGUsIG9wdGlvbnMpO1xuICB9KTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUub3V0cHV0SW1nID0gZnVuY3Rpb24gb3V0cHV0SW1nKHR5cGUsIG9wdGlvbnMpIHtcbiAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gIHZhciBwcmVyZXFzID0gW2Z1bmN0aW9uIGNoZWNrSW1nKCkge1xuICAgIHJldHVybiB0aGlzLnByb3AuaW1nIHx8IHRoaXMudG9JbWcoKTtcbiAgfV07IC8vIEZ1bGZpbGwgcHJlcmVxcyB0aGVuIHBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIG91dHB1dC5cblxuICByZXR1cm4gdGhpcy50aGVuTGlzdChwcmVyZXFzKS50aGVuKGZ1bmN0aW9uIG91dHB1dEltZ19tYWluKCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wLmltZztcblxuICAgICAgY2FzZSAnZGF0YXVyaXN0cmluZyc6XG4gICAgICBjYXNlICdkYXRhdXJsc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcC5pbWcuc3JjO1xuXG4gICAgICBjYXNlICdkYXRhdXJpJzpcbiAgICAgIGNhc2UgJ2RhdGF1cmwnOlxuICAgICAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9IHRoaXMucHJvcC5pbWcuc3JjO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyAnSW1hZ2Ugb3V0cHV0IHR5cGUgXCInICsgdHlwZSArICdcIiBpcyBub3Qgc3VwcG9ydGVkLic7XG4gICAgfVxuICB9KTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoZmlsZW5hbWUpIHtcbiAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gIHZhciBwcmVyZXFzID0gW2Z1bmN0aW9uIGNoZWNrUGRmKCkge1xuICAgIHJldHVybiB0aGlzLnByb3AucGRmIHx8IHRoaXMudG9QZGYoKTtcbiAgfV07IC8vIEZ1bGZpbGwgcHJlcmVxcywgdXBkYXRlIHRoZSBmaWxlbmFtZSAoaWYgcHJvdmlkZWQpLCBhbmQgc2F2ZSB0aGUgUERGLlxuXG4gIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnNldChmaWxlbmFtZSA/IHtcbiAgICBmaWxlbmFtZTogZmlsZW5hbWVcbiAgfSA6IG51bGwpLnRoZW4oZnVuY3Rpb24gc2F2ZV9tYWluKCkge1xuICAgIHRoaXMucHJvcC5wZGYuc2F2ZSh0aGlzLm9wdC5maWxlbmFtZSk7XG4gIH0pO1xufTtcbi8qIC0tLS0tIFNFVCAvIEdFVCAtLS0tLSAqL1xuXG5cbldvcmtlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KG9wdCkge1xuICAvLyBUT0RPOiBJbXBsZW1lbnQgb3JkZXJlZCBwYWlycz9cbiAgLy8gU2lsZW50bHkgaWdub3JlIGludmFsaWQgb3IgZW1wdHkgaW5wdXQuXG4gIGlmICgoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18ub2JqVHlwZSkob3B0KSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBCdWlsZCBhbiBhcnJheSBvZiBzZXR0ZXIgZnVuY3Rpb25zIHRvIHF1ZXVlLlxuXG5cbiAgdmFyIGZucyA9IE9iamVjdC5rZXlzKG9wdCB8fCB7fSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSAnbWFyZ2luJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWFyZ2luLmJpbmQodGhpcywgb3B0Lm1hcmdpbik7XG5cbiAgICAgIGNhc2UgJ2pzUERGJzpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldF9qc1BERigpIHtcbiAgICAgICAgICB0aGlzLm9wdC5qc1BERiA9IG9wdC5qc1BERjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXRQYWdlU2l6ZSgpO1xuICAgICAgICB9O1xuXG4gICAgICBjYXNlICdwYWdlU2l6ZSc6XG4gICAgICAgIHJldHVybiB0aGlzLnNldFBhZ2VTaXplLmJpbmQodGhpcywgb3B0LnBhZ2VTaXplKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGtleSBpbiBXb3JrZXIudGVtcGxhdGUucHJvcCkge1xuICAgICAgICAgIC8vIFNldCBwcmUtZGVmaW5lZCBwcm9wZXJ0aWVzIGluIHByb3AuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldF9wcm9wKCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wW2tleV0gPSBvcHRba2V5XTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNldCBhbnkgb3RoZXIgcHJvcGVydGllcyBpbiBvcHQuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldF9vcHQoKSB7XG4gICAgICAgICAgICB0aGlzLm9wdFtrZXldID0gb3B0W2tleV07XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9LCB0aGlzKTsgLy8gU2V0IHByb3BlcnRpZXMgd2l0aGluIHRoZSBwcm9taXNlIGNoYWluLlxuXG4gIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gc2V0X21haW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbkxpc3QoZm5zKTtcbiAgfSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChrZXksIGNiaykge1xuICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIGdldF9tYWluKCkge1xuICAgIC8vIEZldGNoIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHksIGVpdGhlciBhcyBhIHByZWRlZmluZWQgcHJvcCBvciBpbiBvcHQuXG4gICAgdmFyIHZhbCA9IGtleSBpbiBXb3JrZXIudGVtcGxhdGUucHJvcCA/IHRoaXMucHJvcFtrZXldIDogdGhpcy5vcHRba2V5XTtcbiAgICByZXR1cm4gY2JrID8gY2JrKHZhbCkgOiB2YWw7XG4gIH0pO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS5zZXRNYXJnaW4gPSBmdW5jdGlvbiBzZXRNYXJnaW4obWFyZ2luKSB7XG4gIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gc2V0TWFyZ2luX21haW4oKSB7XG4gICAgLy8gUGFyc2UgdGhlIG1hcmdpbiBwcm9wZXJ0eTogW3RvcCwgbGVmdCwgYm90dG9tLCByaWdodF0uXG4gICAgc3dpdGNoICgoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18ub2JqVHlwZSkobWFyZ2luKSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgbWFyZ2luID0gW21hcmdpbiwgbWFyZ2luLCBtYXJnaW4sIG1hcmdpbl07XG5cbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgaWYgKG1hcmdpbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBtYXJnaW4gPSBbbWFyZ2luWzBdLCBtYXJnaW5bMV0sIG1hcmdpblswXSwgbWFyZ2luWzFdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXJnaW4ubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0ludmFsaWQgbWFyZ2luIGFycmF5LicpO1xuICAgIH0gLy8gU2V0IHRoZSBtYXJnaW4gcHJvcGVydHksIHRoZW4gdXBkYXRlIHBhZ2VTaXplLlxuXG5cbiAgICB0aGlzLm9wdC5tYXJnaW4gPSBtYXJnaW47XG4gIH0pLnRoZW4odGhpcy5zZXRQYWdlU2l6ZSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLnNldFBhZ2VTaXplID0gZnVuY3Rpb24gc2V0UGFnZVNpemUocGFnZVNpemUpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiBzZXRQYWdlU2l6ZV9tYWluKCkge1xuICAgIC8vIFJldHJpZXZlIHBhZ2Utc2l6ZSBiYXNlZCBvbiBqc1BERiBzZXR0aW5ncywgaWYgbm90IGV4cGxpY2l0bHkgcHJvdmlkZWQuXG4gICAgcGFnZVNpemUgPSBwYWdlU2l6ZSB8fCBqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fLmpzUERGLmdldFBhZ2VTaXplKHRoaXMub3B0LmpzUERGKTsgLy8gQWRkICdpbm5lcicgZmllbGQgaWYgbm90IHByZXNlbnQuXG5cbiAgICBpZiAoIXBhZ2VTaXplLmhhc093blByb3BlcnR5KCdpbm5lcicpKSB7XG4gICAgICBwYWdlU2l6ZS5pbm5lciA9IHtcbiAgICAgICAgd2lkdGg6IHBhZ2VTaXplLndpZHRoIC0gdGhpcy5vcHQubWFyZ2luWzFdIC0gdGhpcy5vcHQubWFyZ2luWzNdLFxuICAgICAgICBoZWlnaHQ6IHBhZ2VTaXplLmhlaWdodCAtIHRoaXMub3B0Lm1hcmdpblswXSAtIHRoaXMub3B0Lm1hcmdpblsyXVxuICAgICAgfTtcbiAgICAgIHBhZ2VTaXplLmlubmVyLnB4ID0ge1xuICAgICAgICB3aWR0aDogKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLnRvUHgpKHBhZ2VTaXplLmlubmVyLndpZHRoLCBwYWdlU2l6ZS5rKSxcbiAgICAgICAgaGVpZ2h0OiAoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18udG9QeCkocGFnZVNpemUuaW5uZXIuaGVpZ2h0LCBwYWdlU2l6ZS5rKVxuICAgICAgfTtcbiAgICAgIHBhZ2VTaXplLmlubmVyLnJhdGlvID0gcGFnZVNpemUuaW5uZXIuaGVpZ2h0IC8gcGFnZVNpemUuaW5uZXIud2lkdGg7XG4gICAgfSAvLyBBdHRhY2ggcGFnZVNpemUgdG8gdGhpcy5cblxuXG4gICAgdGhpcy5wcm9wLnBhZ2VTaXplID0gcGFnZVNpemU7XG4gIH0pO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS5zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIHNldFByb2dyZXNzKHZhbCwgc3RhdGUsIG4sIHN0YWNrKSB7XG4gIC8vIEltbWVkaWF0ZWx5IHVwZGF0ZSBhbGwgcHJvZ3Jlc3MgdmFsdWVzLlxuICBpZiAodmFsICE9IG51bGwpIHRoaXMucHJvZ3Jlc3MudmFsID0gdmFsO1xuICBpZiAoc3RhdGUgIT0gbnVsbCkgdGhpcy5wcm9ncmVzcy5zdGF0ZSA9IHN0YXRlO1xuICBpZiAobiAhPSBudWxsKSB0aGlzLnByb2dyZXNzLm4gPSBuO1xuICBpZiAoc3RhY2sgIT0gbnVsbCkgdGhpcy5wcm9ncmVzcy5zdGFjayA9IHN0YWNrO1xuICB0aGlzLnByb2dyZXNzLnJhdGlvID0gdGhpcy5wcm9ncmVzcy52YWwgLyB0aGlzLnByb2dyZXNzLnN0YXRlOyAvLyBSZXR1cm4gdGhpcyBmb3IgY29tbWFuZCBjaGFpbmluZy5cblxuICByZXR1cm4gdGhpcztcbn07XG5cbldvcmtlci5wcm90b3R5cGUudXBkYXRlUHJvZ3Jlc3MgPSBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcyh2YWwsIHN0YXRlLCBuLCBzdGFjaykge1xuICAvLyBJbW1lZGlhdGVseSB1cGRhdGUgYWxsIHByb2dyZXNzIHZhbHVlcywgdXNpbmcgc2V0UHJvZ3Jlc3MuXG4gIHJldHVybiB0aGlzLnNldFByb2dyZXNzKHZhbCA/IHRoaXMucHJvZ3Jlc3MudmFsICsgdmFsIDogbnVsbCwgc3RhdGUgPyBzdGF0ZSA6IG51bGwsIG4gPyB0aGlzLnByb2dyZXNzLm4gKyBuIDogbnVsbCwgc3RhY2sgPyB0aGlzLnByb2dyZXNzLnN0YWNrLmNvbmNhdChzdGFjaykgOiBudWxsKTtcbn07XG4vKiAtLS0tLSBQUk9NSVNFIE1BUFBJTkcgLS0tLS0gKi9cblxuXG5Xb3JrZXIucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIC8vIFdyYXAgYHRoaXNgIGZvciBlbmNhcHN1bGF0aW9uLlxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLnRoZW5Db3JlKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBmdW5jdGlvbiB0aGVuX21haW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAvLyBVcGRhdGUgcHJvZ3Jlc3Mgd2hpbGUgcXVldWluZywgY2FsbGluZywgYW5kIHJlc29sdmluZyBgdGhlbmAuXG4gICAgc2VsZi51cGRhdGVQcm9ncmVzcyhudWxsLCBudWxsLCAxLCBbb25GdWxmaWxsZWRdKTtcbiAgICByZXR1cm4gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5jYWxsKHRoaXMsIGZ1bmN0aW9uIHRoZW5fcHJlKHZhbCkge1xuICAgICAgc2VsZi51cGRhdGVQcm9ncmVzcyhudWxsLCBvbkZ1bGZpbGxlZCk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpLnRoZW4oZnVuY3Rpb24gdGhlbl9wb3N0KHZhbCkge1xuICAgICAgc2VsZi51cGRhdGVQcm9ncmVzcygxKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS50aGVuQ29yZSA9IGZ1bmN0aW9uIHRoZW5Db3JlKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCB0aGVuQmFzZSkge1xuICAvLyBIYW5kbGUgb3B0aW9uYWwgdGhlbkJhc2UgcGFyYW1ldGVyLlxuICB0aGVuQmFzZSA9IHRoZW5CYXNlIHx8IFByb21pc2UucHJvdG90eXBlLnRoZW47IC8vIFdyYXAgYHRoaXNgIGZvciBlbmNhcHN1bGF0aW9uIGFuZCBiaW5kIGl0IHRvIHRoZSBwcm9taXNlIGhhbmRsZXJzLlxuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAob25GdWxmaWxsZWQpIHtcbiAgICBvbkZ1bGZpbGxlZCA9IG9uRnVsZmlsbGVkLmJpbmQoc2VsZik7XG4gIH1cblxuICBpZiAob25SZWplY3RlZCkge1xuICAgIG9uUmVqZWN0ZWQgPSBvblJlamVjdGVkLmJpbmQoc2VsZik7XG4gIH0gLy8gQ2FzdCBzZWxmIGludG8gYSBQcm9taXNlIHRvIGF2b2lkIHBvbHlmaWxscyByZWN1cnNpdmVseSBkZWZpbmluZyBgdGhlbmAuXG5cblxuICB2YXIgaXNOYXRpdmUgPSBQcm9taXNlLnRvU3RyaW5nKCkuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMSAmJiBQcm9taXNlLm5hbWUgPT09ICdQcm9taXNlJztcbiAgdmFyIHNlbGZQcm9taXNlID0gaXNOYXRpdmUgPyBzZWxmIDogV29ya2VyLmNvbnZlcnQoT2JqZWN0LmFzc2lnbih7fSwgc2VsZiksIFByb21pc2UucHJvdG90eXBlKTsgLy8gUmV0dXJuIHRoZSBwcm9taXNlLCBhZnRlciBjYXN0aW5nIGl0IGludG8gYSBXb3JrZXIgYW5kIHByZXNlcnZpbmcgcHJvcHMuXG5cbiAgdmFyIHJldHVyblZhbCA9IHRoZW5CYXNlLmNhbGwoc2VsZlByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgcmV0dXJuIFdvcmtlci5jb252ZXJ0KHJldHVyblZhbCwgc2VsZi5fX3Byb3RvX18pO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS50aGVuRXh0ZXJuYWwgPSBmdW5jdGlvbiB0aGVuRXh0ZXJuYWwob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgLy8gQ2FsbCBgdGhlbmAgYW5kIHJldHVybiBhIHN0YW5kYXJkIHByb21pc2UgKGV4aXRzIHRoZSBXb3JrZXIgY2hhaW4pLlxuICByZXR1cm4gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5jYWxsKHRoaXMsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUudGhlbkxpc3QgPSBmdW5jdGlvbiB0aGVuTGlzdChmbnMpIHtcbiAgLy8gUXVldWUgYSBzZXJpZXMgb2YgcHJvbWlzZSAnZmFjdG9yaWVzJyBpbnRvIHRoZSBwcm9taXNlIGNoYWluLlxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZucy5mb3JFYWNoKGZ1bmN0aW9uIHRoZW5MaXN0X2ZvckVhY2goZm4pIHtcbiAgICBzZWxmID0gc2VsZi50aGVuQ29yZShmbik7XG4gIH0pO1xuICByZXR1cm4gc2VsZjtcbn07XG5cbldvcmtlci5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAvLyBCaW5kIGB0aGlzYCB0byB0aGUgcHJvbWlzZSBoYW5kbGVyLCBjYWxsIGBjYXRjaGAsIGFuZCByZXR1cm4gYSBXb3JrZXIuXG4gIGlmIChvblJlamVjdGVkKSB7XG4gICAgb25SZWplY3RlZCA9IG9uUmVqZWN0ZWQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHZhciByZXR1cm5WYWwgPSBQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXS5jYWxsKHRoaXMsIG9uUmVqZWN0ZWQpO1xuICByZXR1cm4gV29ya2VyLmNvbnZlcnQocmV0dXJuVmFsLCB0aGlzKTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUuY2F0Y2hFeHRlcm5hbCA9IGZ1bmN0aW9uIGNhdGNoRXh0ZXJuYWwob25SZWplY3RlZCkge1xuICAvLyBDYWxsIGBjYXRjaGAgYW5kIHJldHVybiBhIHN0YW5kYXJkIHByb21pc2UgKGV4aXRzIHRoZSBXb3JrZXIgY2hhaW4pLlxuICByZXR1cm4gUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10uY2FsbCh0aGlzLCBvblJlamVjdGVkKTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgLy8gVGhyb3cgdGhlIGVycm9yIGluIHRoZSBQcm9taXNlIGNoYWluLlxuICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIGVycm9yX21haW4oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH0pO1xufTtcbi8qIC0tLS0tIEFMSUFTRVMgLS0tLS0gKi9cblxuXG5Xb3JrZXIucHJvdG90eXBlLnVzaW5nID0gV29ya2VyLnByb3RvdHlwZS5zZXQ7XG5Xb3JrZXIucHJvdG90eXBlLnNhdmVBcyA9IFdvcmtlci5wcm90b3R5cGUuc2F2ZTtcbldvcmtlci5wcm90b3R5cGUuZXhwb3J0ID0gV29ya2VyLnByb3RvdHlwZS5vdXRwdXQ7XG5Xb3JrZXIucHJvdG90eXBlLnJ1biA9IFdvcmtlci5wcm90b3R5cGUudGhlbjtcbi8qIC0tLS0tIEZJTklTSElORyAtLS0tLSAqL1xuLy8gRXhwb3NlIHRoZSBXb3JrZXIgY2xhc3MuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoV29ya2VyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1mdW5jdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtZnVuY3Rpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhpdCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKTtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qc1wiKS5mb3JFYWNoO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QuanNcIik7XG5cbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnZm9yRWFjaCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxubW9kdWxlLmV4cG9ydHMgPSAhU1RSSUNUX01FVEhPRCA/IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1wcm90b3R5cGUtZm9yZWFjaCAtLSBzYWZlXG59IDogW10uZm9yRWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzXCIpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzXCIpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0LmpzXCIpO1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzXCIpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXCIpO1xuXG52YXIgcHVzaCA9IFtdLnB1c2g7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCwgZmlsdGVyUmVqZWN0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIElTX0ZJTFRFUl9SRUpFQ1QgPSBUWVBFID09IDc7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGU7XG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiB8fCBJU19GSUxURVJfUkVKRUNUID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsdWUsIHJlc3VsdDtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbHVlID0gc2VsZltpbmRleF07XG4gICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OyAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0KSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbHVlOyAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcHVzaC5jYWxsKHRhcmdldCwgdmFsdWUpOyAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAvLyBldmVyeVxuICAgICAgICAgIGNhc2UgNzogcHVzaC5jYWxsKHRhcmdldCwgdmFsdWUpOyAvLyBmaWx0ZXJSZWplY3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICBtYXA6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCg0KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICBmaW5kOiBjcmVhdGVNZXRob2QoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kKDYpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlclJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xuICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCg3KVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcbnZhciBWOF9WRVJTSU9OID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanNcIik7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc3XG4gIHJldHVybiBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGZvbzogMSB9O1xuICAgIH07XG4gICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbCxuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyB0aHJvdyAxOyB9LCAxKTtcbiAgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGEgcGFydCBvZiBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5KSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbEFycmF5KSkge1xuICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXCIpO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoYXJyYXlTcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSkpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanNcIik7XG52YXIgY2xhc3NvZlJhdyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jbGFzc29mLXJhdyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgb3duS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vd24ta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzXCIpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXModGFyZ2V0LCBrZXkpKSBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWh0bWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWh0bWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzXCIpO1xudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qc1wiKTtcblxudmFyIHF1b3QgPSAvXCIvZztcblxuLy8gYENyZWF0ZUhUTUxgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVodG1sXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSkge1xuICB2YXIgUyA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoc3RyaW5nKSk7XG4gIHZhciBwMSA9ICc8JyArIHRhZztcbiAgaWYgKGF0dHJpYnV0ZSAhPT0gJycpIHAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgdG9TdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3Rvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanNcIikuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXCIpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanNcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1wiKTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanNcIik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcIik7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3RvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3Rvci5qc1wiKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXCIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanNcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qc1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1wdXJlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1wiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzXCIpO1xudmFyIEl0ZXJhdG9yc0NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qc1wiKTtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XG5cbiAgLy8gZml4IG5hdGl2ZVxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICBpZiAoIUlTX1BVUkUgJiYgZ2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlKSAhPT0gSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmIChJU19QVVJFKSBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmF0aXZlSXRlcmF0b3IuY2FsbCh0aGlzKTsgfTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoKCFJU19QVVJFIHx8IEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SLCBkZWZhdWx0SXRlcmF0b3IpO1xuICB9XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgcmVkZWZpbmUoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XG4gIH1cblxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3BhdGggKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzXCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZC5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKS5mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHZhciBTeW1ib2wgPSBwYXRoLlN5bWJvbCB8fCAocGF0aC5TeW1ib2wgPSB7fSk7XG4gIGlmICghaGFzKFN5bWJvbCwgTkFNRSkpIGRlZmluZVByb3BlcnR5KFN5bWJvbCwgTkFNRSwge1xuICAgIHZhbHVlOiB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYoTkFNRSlcbiAgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQuanNcIik7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbC5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIHZlcnNpb24gPSBtYXRjaFswXSA8IDQgPyAxIDogbWF0Y2hbMF0gKyBtYXRjaFsxXTtcbn0gZWxzZSBpZiAodXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uICYmICt2ZXJzaW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIikuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanNcIik7XG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzXCIpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzXCIpO1xudmFyIGlzRm9yY2VkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qc1wiKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsW1RBUkdFVF0gfHwgc2V0R2xvYmFsKFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMubm9UYXJnZXRHZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICByZWRlZmluZSh0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWZ1bmN0aW9uLmpzXCIpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQpO1xuICAgIH07XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09ICdmdW5jdGlvbicgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSkgOiBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcIik7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwodG9PYmplY3QoaXQpLCBrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qc1wiKTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aWVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcIik7XG5cbnZhciBzcGxpdCA9ICcnLnNwbGl0O1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdC5jYWxsKGl0LCAnJykgOiBPYmplY3QoaXQpO1xufSA6IE9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG52YXIgc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qc1wiKTtcblxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcbiAgaWYgKFxuICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuICAgIHNldFByb3RvdHlwZU9mICYmXG4gICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xuICAgIHR5cGVvZiAoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpID09ICdmdW5jdGlvbicgJiZcbiAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcbiAgICBpc09iamVjdChOZXdUYXJnZXRQcm90b3R5cGUgPSBOZXdUYXJnZXQucHJvdG90eXBlKSAmJlxuICAgIE5ld1RhcmdldFByb3RvdHlwZSAhPT0gV3JhcHBlci5wcm90b3R5cGVcbiAgKSBzZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcbiAgcmV0dXJuICR0aGlzO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzXCIpO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnRvU3RyaW5nO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAodHlwZW9mIHN0b3JlLmluc3BlY3RTb3VyY2UgIT0gJ2Z1bmN0aW9uJykge1xuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcC5qc1wiKTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzXCIpO1xudmFyIG9iamVjdEhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qc1wiKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLWtleSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanNcIik7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRkZW4ta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXCIpO1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIHZhciB3bWdldCA9IHN0b3JlLmdldDtcbiAgdmFyIHdtaGFzID0gc3RvcmUuaGFzO1xuICB2YXIgd21zZXQgPSBzdG9yZS5zZXQ7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMuY2FsbChzdG9yZSwgaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldC5jYWxsKHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0LmNhbGwoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKG9iamVjdEhhcyhpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qc1wiKTtcblxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNsYXNzb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanNcIik7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xuICByZXR1cm4gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QoaXQpIGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xudmFyIGdldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanNcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanNcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihnZXRQcm90b3R5cGVPZihhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9O1xuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5cbmlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5pZiAoKCFJU19QVVJFIHx8IE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkge1xuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSxcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SU1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBWOF9WRVJTSU9OID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3Rpbmdcbm1vZHVsZS5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiAmJiBWOF9WRVJTSU9OIDwgNDE7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzXCIpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlKFdlYWtNYXApKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtYXNzaWduLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xudmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanNcIik7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qc1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcIik7XG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzXCIpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWFzc2lnbiAtLSBzYWZlXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHNob3VsZCBoYXZlIGNvcnJlY3Qgb3JkZXIgb2Ygb3BlcmF0aW9ucyAoRWRnZSBidWcpXG4gIGlmIChERVNDUklQVE9SUyAmJiAkYXNzaWduKHsgYjogMSB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgJ2InLCB7XG4gICAgICAgIHZhbHVlOiAzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgeyBiOiAyIH0pKS5iICE9PSAxKSByZXR1cm4gdHJ1ZTtcbiAgLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1zeW1ib2wgLS0gc2FmZVxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gb2JqZWN0S2V5cyhTKS5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoUywga2V5KSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcIik7XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanNcIik7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanNcIik7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRkZW4ta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXCIpO1xudmFyIGh0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaHRtbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2h0bWwuanNcIik7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanNcIik7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXCIpO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmIChpZnJhbWUuc3R5bGUpIHtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICAgIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICAgIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICAgIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gICAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbiAgfVxufTtcblxuLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuLy8gYXZvaWQgSUUgR0MgYnVnXG52YXIgYWN0aXZlWERvY3VtZW50O1xudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogaWdub3JlICovIH1cbiAgTnVsbFByb3RvT2JqZWN0ID0gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudCA/XG4gICAgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIDogLy8gb2xkIElFXG4gICAgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKCkgfHxcbiAgICBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCIpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiKTtcbnZhciBvYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanNcIik7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIFByb3BlcnRpZXNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCIpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanNcIik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXCIpO1xudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzXCIpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXCIpO1xudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzXCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1wiKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZSAqL1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXCIpO1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanNcIikuZjtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5TmFtZXMoaXQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XSdcbiAgICA/IGdldFdpbmRvd05hbWVzKGl0KVxuICAgIDogJGdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1wiKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qc1wiKTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1wiKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLWtleSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanNcIik7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qc1wiKTtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcIik7XG52YXIgaW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzXCIpLmluZGV4T2Y7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRkZW4ta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzKGhpZGRlbktleXMsIGtleSkgJiYgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5pbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1wiKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qc1wiKTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcIik7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUuanNcIik7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbiAgICBzZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQ7XG4gICAgc2V0dGVyLmNhbGwodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0KE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIuY2FsbChPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qc1wiKTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzXCIpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8ge30udG9TdHJpbmcgOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGlucHV0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanNcIik7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiKTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qc1wiKTtcbnZhciBpbnNwZWN0U291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanNcIik7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzXCIpO1xuXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgdW5zYWZlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy51bnNhZmUgOiBmYWxzZTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMuZW51bWVyYWJsZSA6IGZhbHNlO1xuICB2YXIgbm9UYXJnZXRHZXQgPSBvcHRpb25zID8gISFvcHRpb25zLm5vVGFyZ2V0R2V0IDogZmFsc2U7XG4gIHZhciBzdGF0ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgJiYgIWhhcyh2YWx1ZSwgJ25hbWUnKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIGtleSk7XG4gICAgfVxuICAgIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpO1xuICAgIGlmICghc3RhdGUuc291cmNlKSB7XG4gICAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBrZXkgOiAnJyk7XG4gICAgfVxuICB9XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIHNldEdsb2JhbChrZXksIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xuICAgIHNpbXBsZSA9IHRydWU7XG4gIH1cbiAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KE8sIGtleSwgdmFsdWUpO1xuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZmxhZ3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXCIpO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbCwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWxba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCIpLmY7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1wiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICAgIGRlZmluZVByb3BlcnR5KGl0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzXCIpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy91aWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanNcIik7XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBzZXRHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanNcIik7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanNcIik7XG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzXCIpO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMTYuMCcsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAyMSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1odG1sLWZvcmNlZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLWh0bWwtZm9yY2VkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcblxuLy8gY2hlY2sgdGhlIGV4aXN0ZW5jZSBvZiBhIG1ldGhvZCwgbG93ZXJjYXNlXG4vLyBvZiBhIHRhZyBhbmQgZXNjYXBpbmcgcXVvdGVzIGluIGFyZ3VtZW50c1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgcmV0dXJuIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGVzdCA9ICcnW01FVEhPRF9OQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbnRlZ2VyICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qc1wiKTtcbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanNcIik7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcIik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBzaXplID0gUy5sZW5ndGg7XG4gICAgdmFyIGZpcnN0LCBzZWNvbmQ7XG4gICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBzaXplKSByZXR1cm4gQ09OVkVSVF9UT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBmaXJzdCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gICAgcmV0dXJuIGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZVxuICAgICAgfHwgKHNlY29uZCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcbiAgICAgICAgPyBDT05WRVJUX1RPX1NUUklORyA/IFMuY2hhckF0KHBvc2l0aW9uKSA6IGZpcnN0XG4gICAgICAgIDogQ09OVkVSVF9UT19TVFJJTkcgPyBTLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcIik7XG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXCIpO1xudmFyIHdoaXRlc3BhY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3doaXRlc3BhY2VzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2hpdGVzcGFjZXMuanNcIik7XG5cbnZhciB3aGl0ZXNwYWNlID0gJ1snICsgd2hpdGVzcGFjZXMgKyAnXSc7XG52YXIgbHRyaW0gPSBSZWdFeHAoJ14nICsgd2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyokJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbSwgdHJpbVN0YXJ0LCB0cmltRW5kLCB0cmltTGVmdCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gICAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltTGVmdCwgdHJpbVN0YXJ0IH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltZW5kXG4gIGVuZDogY3JlYXRlTWV0aG9kKDIpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgdHJpbTogY3JlYXRlTWV0aG9kKDMpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW50ZWdlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXIuanNcIik7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBUb0ludGVnZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc05hTihhcmd1bWVudCA9ICthcmd1bWVudCkgPyAwIDogKGFyZ3VtZW50ID4gMCA/IGZsb29yIDogY2VpbCkoYXJndW1lbnQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbnRlZ2VyICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qc1wiKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXIoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qc1wiKTtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanNcIik7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUuanNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG5cbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGlucHV0W1RPX1BSSU1JVElWRV07XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QocmVzdWx0KSB8fCBpc1N5bWJvbChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcmltaXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanNcIik7XG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzXCIpO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IFN0cmluZyhrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc1N5bWJvbChhcmd1bWVudCkpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcblxuZXhwb3J0cy5mID0gd2VsbEtub3duU3ltYm9sO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCIpO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1wiKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdWlkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXCIpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanNcIik7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qc1wiKTtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXMoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXMoU3ltYm9sLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vLyBhIHN0cmluZyBvZiBhbGwgdmFsaWQgdW5pY29kZSB3aGl0ZXNwYWNlc1xubW9kdWxlLmV4cG9ydHMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDInICtcbiAgJ1xcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qc1wiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qc1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanNcIik7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanNcIik7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0LmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xudmFyIFY4X1ZFUlNJT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbi5qc1wiKTtcblxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gd2VsbEtub3duU3ltYm9sKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjtcbnZhciBNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQgPSAnTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkJztcblxuLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4vLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgPSBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBhcnJheVtJU19DT05DQVRfU1BSRUFEQUJMRV0gPSBmYWxzZTtcbiAgcmV0dXJuIGFycmF5LmNvbmNhdCgpWzBdICE9PSBhcnJheTtcbn0pO1xuXG52YXIgU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnY29uY2F0Jyk7XG5cbnZhciBpc0NvbmNhdFNwcmVhZGFibGUgPSBmdW5jdGlvbiAoTykge1xuICBpZiAoIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzcHJlYWRhYmxlID0gT1tJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gIHJldHVybiBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KE8pO1xufTtcblxudmFyIEZPUkNFRCA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFTUEVDSUVTX1NVUFBPUlQ7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQGlzQ29uY2F0U3ByZWFkYWJsZSBhbmQgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhcmcpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgaSwgaywgbGVuZ3RoLCBsZW4sIEU7XG4gICAgZm9yIChpID0gLTEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgRSA9IGkgPT09IC0xID8gTyA6IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChpc0NvbmNhdFNwcmVhZGFibGUoRSkpIHtcbiAgICAgICAgbGVuID0gdG9MZW5ndGgoRS5sZW5ndGgpO1xuICAgICAgICBpZiAobiArIGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93IFR5cGVFcnJvcihNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQpO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyssIG4rKykgaWYgKGsgaW4gRSkgY3JlYXRlUHJvcGVydHkoQSwgbiwgRVtrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobiA+PSBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkoQSwgbisrLCBFKTtcbiAgICAgIH1cbiAgICB9XG4gICAgQS5sZW5ndGggPSBuO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qc1wiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzXCIpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1wiKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanNcIik7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBpbmRleCwgZG9uZTogZmFsc2UgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXCIpO1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0LmpzXCIpO1xuXG52YXIgbmF0aXZlSm9pbiA9IFtdLmpvaW47XG5cbnZhciBFUzNfU1RSSU5HUyA9IEluZGV4ZWRPYmplY3QgIT0gT2JqZWN0O1xudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdqb2luJywgJywnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5qb2luYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmpvaW5cbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEVTM19TVFJJTkdTIHx8ICFTVFJJQ1RfTUVUSE9EIH0sIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbmF0aXZlSm9pbi5jYWxsKHRvSW5kZXhlZE9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciAkbWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qc1wiKS5tYXA7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0LmpzXCIpO1xuXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ21hcCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB9LCB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanNcIik7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanNcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanNcIik7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnc2xpY2UnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciBuYXRpdmVTbGljZSA9IFtdLnNsaWNlO1xudmFyIG1heCA9IE1hdGgubWF4O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNsaWNlXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB9LCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICAgIC8vIGlubGluZSBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBmb3IgdXNhZ2UgbmF0aXZlIGBBcnJheSNzbGljZWAgd2hlcmUgaXQncyBwb3NzaWJsZVxuICAgIHZhciBDb25zdHJ1Y3RvciwgcmVzdWx0LCBuO1xuICAgIGlmIChpc0FycmF5KE8pKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IE8uY29uc3RydWN0b3I7XG4gICAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiBDb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgaXNBcnJheShDb25zdHJ1Y3Rvci5wcm90b3R5cGUpKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3JbU1BFQ0lFU107XG4gICAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gbnVsbCkgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IgPT09IEFycmF5IHx8IENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVNsaWNlLmNhbGwoTywgaywgZmluKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ID0gbmV3IChDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDb25zdHJ1Y3RvcikobWF4KGZpbiAtIGssIDApKTtcbiAgICBmb3IgKG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgaWYgKGsgaW4gTykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCIpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCIpLmY7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nID0gRnVuY3Rpb25Qcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIEZ1bmN0aW9uIGluc3RhbmNlcyBgLm5hbWVgIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLWluc3RhbmNlcy1uYW1lXG5pZiAoREVTQ1JJUFRPUlMgJiYgIShOQU1FIGluIEZ1bmN0aW9uUHJvdG90eXBlKSkge1xuICBkZWZpbmVQcm9wZXJ0eShGdW5jdGlvblByb3RvdHlwZSwgTkFNRSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nLmNhbGwodGhpcykubWF0Y2gobmFtZVJFKVsxXTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBpc0ZvcmNlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1mb3JjZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanNcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVkZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWRlZmluZS5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qc1wiKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZC5qc1wiKTtcbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanNcIik7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXCIpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1wiKS5mO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKS5mO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCIpLmY7XG52YXIgdHJpbSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zdHJpbmctdHJpbSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy10cmltLmpzXCIpLnRyaW07XG5cbnZhciBOVU1CRVIgPSAnTnVtYmVyJztcbnZhciBOYXRpdmVOdW1iZXIgPSBnbG9iYWxbTlVNQkVSXTtcbnZhciBOdW1iZXJQcm90b3R5cGUgPSBOYXRpdmVOdW1iZXIucHJvdG90eXBlO1xuXG4vLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbnZhciBCUk9LRU5fQ0xBU1NPRiA9IGNsYXNzb2YoY3JlYXRlKE51bWJlclByb3RvdHlwZSkpID09IE5VTUJFUjtcblxuLy8gYFRvTnVtYmVyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9udW1iZXJcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNTeW1ib2woYXJndW1lbnQpKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgbnVtYmVyJyk7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnbnVtYmVyJyk7XG4gIHZhciBmaXJzdCwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlLCBkaWdpdHMsIGxlbmd0aCwgaW5kZXgsIGNvZGU7XG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gdHJpbShpdCk7XG4gICAgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KSB7XG4gICAgICB0aGlyZCA9IGl0LmNoYXJDb2RlQXQoMik7XG4gICAgICBpZiAodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApIHJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSA0OCkge1xuICAgICAgc3dpdGNoIChpdC5jaGFyQ29kZUF0KDEpKSB7XG4gICAgICAgIGNhc2UgNjY6IGNhc2UgOTg6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCBvZiAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OTogY2FzZSAxMTE6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCBvZiAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBkaWdpdHMgPSBpdC5zbGljZSgyKTtcbiAgICAgIGxlbmd0aCA9IGRpZ2l0cy5sZW5ndGg7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpIHJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbi8vIGBOdW1iZXJgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci1jb25zdHJ1Y3RvclxuaWYgKGlzRm9yY2VkKE5VTUJFUiwgIU5hdGl2ZU51bWJlcignIDBvMScpIHx8ICFOYXRpdmVOdW1iZXIoJzBiMScpIHx8IE5hdGl2ZU51bWJlcignKzB4MScpKSkge1xuICB2YXIgTnVtYmVyV3JhcHBlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSkge1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlO1xuICAgIHZhciBkdW1teSA9IHRoaXM7XG4gICAgcmV0dXJuIGR1bW15IGluc3RhbmNlb2YgTnVtYmVyV3JhcHBlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NMQVNTT0YgPyBmYWlscyhmdW5jdGlvbiAoKSB7IE51bWJlclByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZHVtbXkpOyB9KSA6IGNsYXNzb2YoZHVtbXkpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgTmF0aXZlTnVtYmVyKHRvTnVtYmVyKGl0KSksIGR1bW15LCBOdW1iZXJXcmFwcGVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IERFU0NSSVBUT1JTID8gZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVOdW1iZXIpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVMyMDE1IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVMyMDE1IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlciwnICtcbiAgICAvLyBFU05leHRcbiAgICAnZnJvbVN0cmluZyxyYW5nZSdcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXMoTmF0aXZlTnVtYmVyLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKE51bWJlcldyYXBwZXIsIGtleSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5hdGl2ZU51bWJlciwga2V5KSk7XG4gICAgfVxuICB9XG4gIE51bWJlcldyYXBwZXIucHJvdG90eXBlID0gTnVtYmVyUHJvdG90eXBlO1xuICBOdW1iZXJQcm90b3R5cGUuY29uc3RydWN0b3IgPSBOdW1iZXJXcmFwcGVyO1xuICByZWRlZmluZShnbG9iYWwsIE5VTUJFUiwgTnVtYmVyV3JhcHBlcik7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcIik7XG52YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1hc3NpZ24gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtYXNzaWduLmpzXCIpO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtYXNzaWduIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xuICBhc3NpZ246IGFzc2lnblxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1wiKTtcbnZhciBuYXRpdmVLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUtleXMoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyB9LCB7XG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyh0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanNcIik7XG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanNcIik7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKCFUT19TVFJJTkdfVEFHX1NVUFBPUlQpIHtcbiAgcmVkZWZpbmUoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgdG9TdHJpbmcsIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiKTtcbnZhciAkdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG52YXIgZmxhZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzXCIpO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG5hdGl2ZVRvU3RyaW5nID0gUmVnRXhwUHJvdG90eXBlW1RPX1NUUklOR107XG5cbnZhciBOT1RfR0VORVJJQyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbnZhciBJTkNPUlJFQ1RfTkFNRSA9IG5hdGl2ZVRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICByZWRlZmluZShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgdmFyIHAgPSAkdG9TdHJpbmcoUi5zb3VyY2UpO1xuICAgIHZhciByZiA9IFIuZmxhZ3M7XG4gICAgdmFyIGYgPSAkdG9TdHJpbmcocmYgPT09IHVuZGVmaW5lZCAmJiBSIGluc3RhbmNlb2YgUmVnRXhwICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUpID8gZmxhZ3MuY2FsbChSKSA6IHJmKTtcbiAgICByZXR1cm4gJy8nICsgcCArICcvJyArIGY7XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNoYXJBdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qc1wiKS5jaGFyQXQ7XG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXCIpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1wiKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanNcIik7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogdG9TdHJpbmcoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pO1xuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5saW5rLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmxpbmsuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciBjcmVhdGVIVE1MID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1odG1sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWh0bWwuanNcIik7XG52YXIgZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zdHJpbmctaHRtbC1mb3JjZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctaHRtbC1mb3JjZWQuanNcIik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmxpbmtgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmxpbmtcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdIVE1MTWV0aG9kKCdsaW5rJykgfSwge1xuICBsaW5rOiBmdW5jdGlvbiBsaW5rKHVybCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBgU3ltYm9sLnByb3RvdHlwZS5kZXNjcmlwdGlvbmAgZ2V0dGVyXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXCIpO1xudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKS5mO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzXCIpO1xuXG52YXIgTmF0aXZlU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcblxuaWYgKERFU0NSSVBUT1JTICYmIHR5cGVvZiBOYXRpdmVTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiAoISgnZGVzY3JpcHRpb24nIGluIE5hdGl2ZVN5bWJvbC5wcm90b3R5cGUpIHx8XG4gIC8vIFNhZmFyaSAxMiBidWdcbiAgTmF0aXZlU3ltYm9sKCkuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZFxuKSkge1xuICB2YXIgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlID0ge307XG4gIC8vIHdyYXAgU3ltYm9sIGNvbnN0cnVjdG9yIGZvciBjb3JyZWN0IHdvcmsgd2l0aCB1bmRlZmluZWQgZGVzY3JpcHRpb25cbiAgdmFyIFN5bWJvbFdyYXBwZXIgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcyBpbnN0YW5jZW9mIFN5bWJvbFdyYXBwZXJcbiAgICAgID8gbmV3IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbilcbiAgICAgIC8vIGluIEVkZ2UgMTMsIFN0cmluZyhTeW1ib2wodW5kZWZpbmVkKSkgPT09ICdTeW1ib2wodW5kZWZpbmVkKSdcbiAgICAgIDogZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/IE5hdGl2ZVN5bWJvbCgpIDogTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICBpZiAoZGVzY3JpcHRpb24gPT09ICcnKSBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmVbcmVzdWx0XSA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhTeW1ib2xXcmFwcGVyLCBOYXRpdmVTeW1ib2wpO1xuICB2YXIgc3ltYm9sUHJvdG90eXBlID0gU3ltYm9sV3JhcHBlci5wcm90b3R5cGUgPSBOYXRpdmVTeW1ib2wucHJvdG90eXBlO1xuICBzeW1ib2xQcm90b3R5cGUuY29uc3RydWN0b3IgPSBTeW1ib2xXcmFwcGVyO1xuXG4gIHZhciBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIG5hdGl2ZSA9IFN0cmluZyhOYXRpdmVTeW1ib2woJ3Rlc3QnKSkgPT0gJ1N5bWJvbCh0ZXN0KSc7XG4gIHZhciByZWdleHAgPSAvXlN5bWJvbFxcKCguKilcXClbXildKyQvO1xuICBkZWZpbmVQcm9wZXJ0eShzeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBzeW1ib2wgPSBpc09iamVjdCh0aGlzKSA/IHRoaXMudmFsdWVPZigpIDogdGhpcztcbiAgICAgIHZhciBzdHJpbmcgPSBzeW1ib2xUb1N0cmluZy5jYWxsKHN5bWJvbCk7XG4gICAgICBpZiAoaGFzKEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSwgc3ltYm9sKSkgcmV0dXJuICcnO1xuICAgICAgdmFyIGRlc2MgPSBuYXRpdmUgPyBzdHJpbmcuc2xpY2UoNywgLTEpIDogc3RyaW5nLnJlcGxhY2UocmVnZXhwLCAnJDEnKTtcbiAgICAgIHJldHVybiBkZXNjID09PSAnJyA/IHVuZGVmaW5lZCA6IGRlc2M7XG4gICAgfVxuICB9KTtcblxuICAkKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgIFN5bWJvbDogU3ltYm9sV3JhcHBlclxuICB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG5cbi8vIGBTeW1ib2wuaXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5pdGVyYXRvclxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanNcIik7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1wdXJlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1wiKTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCIpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qc1wiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcIik7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcIik7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanNcIik7XG52YXIgJHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qc1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKTtcbnZhciBuYXRpdmVPYmplY3RDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanNcIik7XG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3Qta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXCIpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbC5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanNcIik7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXCIpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCIpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanNcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzXCIpO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcIik7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXCIpO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qc1wiKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdWlkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQuanNcIik7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzXCIpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1wiKTtcbnZhciAkZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanNcIikuZm9yRWFjaDtcblxudmFyIEhJRERFTiA9IHNoYXJlZEtleSgnaGlkZGVuJyk7XG52YXIgU1lNQk9MID0gJ1N5bWJvbCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1lNQk9MKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkc3RyaW5naWZ5ID0gZ2V0QnVpbHRJbignSlNPTicsICdzdHJpbmdpZnknKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N0cmluZy10by1zeW1ib2wtcmVnaXN0cnknKTtcbnZhciBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBVU0VfU0VUVEVSID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdENyZWF0ZShuYXRpdmVEZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoTywgUCwgQXR0cmlidXRlcykge1xuICB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIFApO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcikgZGVsZXRlIE9iamVjdFByb3RvdHlwZVtQXTtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIE8gIT09IE9iamVjdFByb3RvdHlwZSkge1xuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZSwgUCwgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcik7XG4gIH1cbn0gOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHNldEludGVybmFsU3RhdGUoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFERVNDUklQVE9SUykgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5ID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghQXR0cmlidXRlcy5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhPLCBISURERU4pKSBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBISURERU4sIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB7fSkpO1xuICAgICAgT1tISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKE8sIEhJRERFTikgJiYgT1tISURERU5dW2tleV0pIE9bSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBBdHRyaWJ1dGVzID0gbmF0aXZlT2JqZWN0Q3JlYXRlKEF0dHJpYnV0ZXMsIHsgZW51bWVyYWJsZTogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjcmlwdG9yKE8sIGtleSwgQXR0cmlidXRlcyk7XG4gIH0gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIGtleSwgQXR0cmlidXRlcyk7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBwcm9wZXJ0aWVzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMocHJvcGVydGllcykuY29uY2F0KCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMocHJvcGVydGllcykpO1xuICAkZm9yRWFjaChrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFERVNDUklQVE9SUyB8fCAkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChwcm9wZXJ0aWVzLCBrZXkpKSAkZGVmaW5lUHJvcGVydHkoTywga2V5LCBwcm9wZXJ0aWVzW2tleV0pO1xuICB9KTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyBuYXRpdmVPYmplY3RDcmVhdGUoTykgOiAkZGVmaW5lUHJvcGVydGllcyhuYXRpdmVPYmplY3RDcmVhdGUoTyksIFByb3BlcnRpZXMpO1xufTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIFAgPSB0b1Byb3BlcnR5S2V5KFYpO1xuICB2YXIgZW51bWVyYWJsZSA9IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGhpcywgUCk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUgJiYgaGFzKEFsbFN5bWJvbHMsIFApICYmICFoYXMoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVudW1lcmFibGUgfHwgIWhhcyh0aGlzLCBQKSB8fCAhaGFzKEFsbFN5bWJvbHMsIFApIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtQXSA/IGVudW1lcmFibGUgOiB0cnVlO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICB2YXIgaXQgPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIHZhciBrZXkgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIGRlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG4gIGlmIChkZXNjcmlwdG9yICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIHtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG4gIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhoaWRkZW5LZXlzLCBrZXkpKSByZXN1bHQucHVzaChrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGU7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXMoT2JqZWN0UHJvdG90eXBlLCBrZXkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLWNvbnN0cnVjdG9yXG5pZiAoIU5BVElWRV9TWU1CT0wpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gIWFyZ3VtZW50cy5sZW5ndGggfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAkdG9TdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgdGFnID0gdWlkKGRlc2NyaXB0aW9uKTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlKSBzZXR0ZXIuY2FsbChPYmplY3RQcm90b3R5cGVTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2NyaXB0b3IodGhpcywgdGFnLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBVU0VfU0VUVEVSKSBzZXRTeW1ib2xEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBzZXR0ZXIgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnLCBkZXNjcmlwdGlvbik7XG4gIH07XG5cbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS50YWc7XG4gIH0pO1xuXG4gIHJlZGVmaW5lKCRTeW1ib2wsICd3aXRob3V0U2V0dGVyJywgZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHdyYXAodWlkKGRlc2NyaXB0aW9uKSwgZGVzY3JpcHRpb24pO1xuICB9KTtcblxuICBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gJGRlZmluZVByb3BlcnR5O1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZiA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdlbGxLbm93blN5bWJvbChuYW1lKSwgbmFtZSk7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9uXG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoJFN5bWJvbFtQUk9UT1RZUEVdLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5kZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIUlTX1BVUkUpIHtcbiAgICAgIHJlZGVmaW5lKE9iamVjdFByb3RvdHlwZSwgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cbn1cblxuJCh7IGdsb2JhbDogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIU5BVElWRV9TWU1CT0wgfSwge1xuICBTeW1ib2w6ICRTeW1ib2xcbn0pO1xuXG4kZm9yRWFjaChvYmplY3RLZXlzKFdlbGxLbm93blN5bWJvbHNTdG9yZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlZmluZVdlbGxLbm93blN5bWJvbChuYW1lKTtcbn0pO1xuXG4kKHsgdGFyZ2V0OiBTWU1CT0wsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICAvLyBgU3ltYm9sLmZvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmZvclxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzdHJpbmcgPSAkdG9TdHJpbmcoa2V5KTtcbiAgICBpZiAoaGFzKFN0cmluZ1RvU3ltYm9sUmVnaXN0cnksIHN0cmluZykpIHJldHVybiBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ107XG4gICAgdmFyIHN5bWJvbCA9ICRTeW1ib2woc3RyaW5nKTtcbiAgICBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ10gPSBzeW1ib2w7XG4gICAgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1ib2xdID0gc3RyaW5nO1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH0sXG4gIC8vIGBTeW1ib2wua2V5Rm9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sJyk7XG4gICAgaWYgKGhhcyhTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5LCBzeW0pKSByZXR1cm4gU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1dO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gZmFsc2U7IH1cbn0pO1xuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvclxufSk7XG5cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogZmFpbHMoZnVuY3Rpb24gKCkgeyBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZigxKTsgfSkgfSwge1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2QgYmVoYXZpb3Igd2l0aCBzeW1ib2xzXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG5pZiAoJHN0cmluZ2lmeSkge1xuICB2YXIgRk9SQ0VEX0pTT05fU1RSSU5HSUZZID0gIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzeW1ib2wgPSAkU3ltYm9sKCk7XG4gICAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgICByZXR1cm4gJHN0cmluZ2lmeShbc3ltYm9sXSkgIT0gJ1tudWxsXSdcbiAgICAgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgICAgfHwgJHN0cmluZ2lmeSh7IGE6IHN5bWJvbCB9KSAhPSAne30nXG4gICAgICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICAgICAgfHwgJHN0cmluZ2lmeShPYmplY3Qoc3ltYm9sKSkgIT0gJ3t9JztcbiAgfSk7XG5cbiAgJCh7IHRhcmdldDogJ0pTT04nLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9KU09OX1NUUklOR0lGWSB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgICB2YXIgaW5kZXggPSAxO1xuICAgICAgdmFyICRyZXBsYWNlcjtcbiAgICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaW5kZXgpIGFyZ3MucHVzaChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgICAgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgICAgcmV0dXJuICRzdHJpbmdpZnkuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmlmICghJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0pIHtcbiAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG59XG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCBTWU1CT0wpO1xuXG5oaWRkZW5LZXlzW0hJRERFTl0gPSB0cnVlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgRE9NSXRlcmFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzXCIpO1xudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qc1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzXCIpO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlICYmIENvbGxlY3Rpb25Qcm90b3R5cGUuZm9yRWFjaCAhPT0gZm9yRWFjaCkgdHJ5IHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgJ2ZvckVhY2gnLCBmb3JFYWNoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggPSBmb3JFYWNoO1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBET01JdGVyYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMuanNcIik7XG52YXIgQXJyYXlJdGVyYXRvck1ldGhvZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHXSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgfVxuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgdjQuMi44KzFlNjhkY2U2XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0IHRydWUgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdDA7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG5cbnZhciBfaXNBcnJheSA9IHZvaWQgMDtcbmlmIChBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB2b2lkIDA7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB2b2lkIDA7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdmVydHggPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpLnJlcXVpcmUoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHZvaWQgMDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIFwiZnVuY3Rpb25cIiA9PT0gJ2Z1bmN0aW9uJykge1xuICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnR4KCk7XG59IGVsc2Uge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmIChjaGlsZFtQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFrZVByb21pc2UoY2hpbGQpO1xuICB9XG5cbiAgdmFyIF9zdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cblxuICBpZiAoX3N0YXRlKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW19zdGF0ZSAtIDFdO1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrKF9zdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUkMShvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBQUk9NSVNFX0lEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbmZ1bmN0aW9uIHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xufVxuXG5mdW5jdGlvbiBjYW5ub3RSZXR1cm5Pd24oKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiQkMSwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4kJDEuY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbiQkMSkge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiQkMSwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkMSA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUkMSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJDEpKSB7XG4gICAgICBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciB0aGVuJCQxID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICB0aGVuJCQxID0gdmFsdWUudGhlbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgdGhlbiQkMSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdm9pZCAwLFxuICAgICAgZXJyb3IgPSB2b2lkIDAsXG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICBlcnJvciA9IGU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzdWNjZWVkZWQgPT09IGZhbHNlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgdHJ5IHtcbiAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGUpO1xuICB9XG59XG5cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gIHJldHVybiBpZCsrO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gIHByb21pc2VbUFJPTUlTRV9JRF0gPSBpZCsrO1xuICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufVxuXG52YXIgRW51bWVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gICAgaWYgKCF0aGlzLnByb21pc2VbUFJPTUlTRV9JRF0pIHtcbiAgICAgIG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgICAgICB0aGlzLl9lbnVtZXJhdGUoaW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgIH1cbiAgfVxuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbiBfZW51bWVyYXRlKGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uIF9lYWNoRW50cnkoZW50cnksIGkpIHtcbiAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgdmFyIHJlc29sdmUkJDEgPSBjLnJlc29sdmU7XG5cblxuICAgIGlmIChyZXNvbHZlJCQxID09PSByZXNvbHZlJDEpIHtcbiAgICAgIHZhciBfdGhlbiA9IHZvaWQgMDtcbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoZW4gPSBlbnRyeS50aGVuO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgX3RoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkMSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlJCQxKGVudHJ5KTtcbiAgICAgICAgfSksIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkMShlbnRyeSksIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gX3NldHRsZWRBdChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuXG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKSB7XG4gICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEVudW1lcmF0b3I7XG59KCk7XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbChlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvcih0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0JDEocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuXG52YXIgUHJvbWlzZSQxID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICAgIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICB9KTtcbiAgYGBgXG4gICBDaGFpbmluZ1xuICAtLS0tLS0tLVxuICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiB1c2VyLm5hbWU7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICB9KTtcbiAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gIH0pO1xuICBgYGBcbiAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIEFzc2ltaWxhdGlvblxuICAtLS0tLS0tLS0tLS1cbiAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICB9KTtcbiAgYGBgXG4gICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIFNpbXBsZSBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCByZXN1bHQ7XG4gICB0cnkge1xuICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBzdWNjZXNzXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gZmFpbHVyZVxuICB9KTtcbiAgYGBgXG4gICBBZHZhbmNlZCBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCBhdXRob3IsIGJvb2tzO1xuICAgdHJ5IHtcbiAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICAgfVxuICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgIH1cbiAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgfVxuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kQXV0aG9yKCkuXG4gICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAvLyBmb3VuZCBib29rc1xuICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgIEBtZXRob2QgdGhlblxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuICAvKipcbiAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBgYGBqc1xuICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICB9XG4gIC8vIHN5bmNocm9ub3VzXG4gIHRyeSB7XG4gIGZpbmRBdXRob3IoKTtcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfVxuICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gIEBtZXRob2QgY2F0Y2hcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICBgZmluYWxseWAgd2lsbCBiZSBpbnZva2VkIHJlZ2FyZGxlc3Mgb2YgdGhlIHByb21pc2UncyBmYXRlIGp1c3QgYXMgbmF0aXZlXG4gICAgdHJ5L2NhdGNoL2ZpbmFsbHkgYmVoYXZlc1xuICBcbiAgICBTeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXV0aG9yKCk7XG4gICAgfVxuICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZpbmRBdXRob3IoKTsgLy8gc3VjY2VlZCBvciBmYWlsXG4gICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBhbHdheXMgcnVuc1xuICAgICAgLy8gZG9lc24ndCBhZmZlY3QgdGhlIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgQXN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpe1xuICAgICAgLy8gYXV0aG9yIHdhcyBlaXRoZXIgZm91bmQsIG9yIG5vdFxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGZpbmFsbHlcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgfTtcblxuICByZXR1cm4gUHJvbWlzZTtcbn0oKTtcblxuUHJvbWlzZSQxLnByb3RvdHlwZS50aGVuID0gdGhlbjtcblByb21pc2UkMS5hbGwgPSBhbGw7XG5Qcm9taXNlJDEucmFjZSA9IHJhY2U7XG5Qcm9taXNlJDEucmVzb2x2ZSA9IHJlc29sdmUkMTtcblByb21pc2UkMS5yZWplY3QgPSByZWplY3QkMTtcblByb21pc2UkMS5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZSQxLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UkMS5fYXNhcCA9IGFzYXA7XG5cbi8qZ2xvYmFsIHNlbGYqL1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIHZhciBsb2NhbCA9IHZvaWQgMDtcblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IHNlbGY7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICBpZiAoUCkge1xuICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBwcm9taXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNpbGVudGx5IGlnbm9yZWRcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZVRvU3RyaW5nID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxvY2FsLlByb21pc2UgPSBQcm9taXNlJDE7XG59XG5cbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UkMS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuUHJvbWlzZSQxLlByb21pc2UgPSBQcm9taXNlJDE7XG5cbnJldHVybiBQcm9taXNlJDE7XG5cbn0pKSk7XG5cblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXBcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJodG1sMmNhbnZhc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIFwiaHRtbDJjYW52YXNcIiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9odG1sMmNhbnZhc19fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJqc3BkZlwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIFwianNwZGZcIiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9qc3BkZl9fO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsgfVxuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpbiBzdHJpY3QgbW9kZS5cbiFmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiO1xuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfd29ya2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3dvcmtlci5qcyAqLyBcIi4vc3JjL3dvcmtlci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGx1Z2luX2pzcGRmX3BsdWdpbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wbHVnaW4vanNwZGYtcGx1Z2luLmpzICovIFwiLi9zcmMvcGx1Z2luL2pzcGRmLXBsdWdpbi5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGx1Z2luX3BhZ2VicmVha3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGx1Z2luL3BhZ2VicmVha3MuanMgKi8gXCIuL3NyYy9wbHVnaW4vcGFnZWJyZWFrcy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGx1Z2luX2h5cGVybGlua3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGx1Z2luL2h5cGVybGlua3MuanMgKi8gXCIuL3NyYy9wbHVnaW4vaHlwZXJsaW5rcy5qc1wiKTtcblxuXG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIFBERiBmcm9tIGFuIEhUTUwgZWxlbWVudCBvciBzdHJpbmcgdXNpbmcgaHRtbDJjYW52YXMgYW5kIGpzUERGLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIGVsZW1lbnQgb3IgSFRNTCBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBBbiBvYmplY3Qgb2Ygb3B0aW9uYWwgc2V0dGluZ3M6ICdtYXJnaW4nLCAnZmlsZW5hbWUnLFxuICogICAgJ2ltYWdlJyAoJ3R5cGUnIGFuZCAncXVhbGl0eScpLCBhbmQgJ2h0bWwyY2FudmFzJyAvICdqc3BkZicsIHdoaWNoIGFyZVxuICogICAgc2VudCBhcyBzZXR0aW5ncyB0byB0aGVpciBjb3JyZXNwb25kaW5nIGZ1bmN0aW9ucy5cbiAqL1xuXG52YXIgaHRtbDJwZGYgPSBmdW5jdGlvbiBodG1sMnBkZihzcmMsIG9wdCkge1xuICAvLyBDcmVhdGUgYSBuZXcgd29ya2VyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIHZhciB3b3JrZXIgPSBuZXcgaHRtbDJwZGYuV29ya2VyKG9wdCk7XG5cbiAgaWYgKHNyYykge1xuICAgIC8vIElmIHNyYyBpcyBzcGVjaWZpZWQsIHBlcmZvcm0gdGhlIHRyYWRpdGlvbmFsICdzaW1wbGUnIG9wZXJhdGlvbi5cbiAgICByZXR1cm4gd29ya2VyLmZyb20oc3JjKS5zYXZlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIHdvcmtlciBmb3IgbmV3IFByb21pc2UtYmFzZWQgb3BlcmF0aW9uLlxuICAgIHJldHVybiB3b3JrZXI7XG4gIH1cbn07XG5cbmh0bWwycGRmLldvcmtlciA9IF93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5kZWZhdWx0OyAvLyBFeHBvc2UgdGhlIGh0bWwycGRmIGZ1bmN0aW9uLlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGh0bWwycGRmKTtcbn0oKTtcbl9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfZXhwb3J0c19fLmRlZmF1bHQ7XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsInNlbGYiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pzcGRmX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2h0bWwyY2FudmFzX18iLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsInIiLCJjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0IiwibiIsImNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfbGlua19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19saW5rX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCIsIl93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsIl91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwibGlua0luZm8iLCJvcmlnIiwidG9Db250YWluZXIiLCJkZWZhdWx0IiwicHJvdG90eXBlIiwidG9QZGYiLCJjYWxsIiwidGhlbiIsInRvQ29udGFpbmVyX2h5cGVybGluayIsIm9wdCIsImVuYWJsZUxpbmtzIiwiY29udGFpbmVyIiwicHJvcCIsImxpbmtzIiwicXVlcnlTZWxlY3RvckFsbCIsImNvbnRhaW5lclJlY3QiLCJ1bml0Q29udmVydCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VTaXplIiwiayIsIkFycmF5IiwiZm9yRWFjaCIsImxpbmsiLCJjbGllbnRSZWN0cyIsImdldENsaWVudFJlY3RzIiwiaSIsImxlbmd0aCIsImNsaWVudFJlY3QiLCJsZWZ0IiwidG9wIiwicGFnZSIsIk1hdGgiLCJmbG9vciIsImlubmVyIiwiaGVpZ2h0IiwibWFyZ2luIiwicHVzaCIsInRvUGRmX2h5cGVybGluayIsImwiLCJwZGYiLCJzZXRQYWdlIiwid2lkdGgiLCJ1cmwiLCJocmVmIiwiblBhZ2VzIiwiaW50ZXJuYWwiLCJnZXROdW1iZXJPZlBhZ2VzIiwiY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2Rlc2NyaXB0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2Rlc2NyaXB0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19hcnJheV9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fIiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyIsImNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyIsImNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCIsImpzcGRmX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18iLCJqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fX2RlZmF1bHQiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsImpzUERGIiwiZ2V0UGFnZVNpemUiLCJvcmllbnRhdGlvbiIsInVuaXQiLCJmb3JtYXQiLCJvcHRpb25zIiwidG9Mb3dlckNhc2UiLCJmb3JtYXRfYXNfc3RyaW5nIiwicGFnZUZvcm1hdHMiLCJoYXNPd25Qcm9wZXJ0eSIsInBhZ2VIZWlnaHQiLCJwYWdlV2lkdGgiLCJlcnIiLCJFcnJvciIsInRtcCIsImluZm8iLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19hcnJheV9zbGljZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X3NsaWNlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19hcnJheV9qb2luX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfam9pbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18iLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2tleXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0IiwiX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fIiwiX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18iLCJ0ZW1wbGF0ZSIsInBhZ2VicmVhayIsIm1vZGUiLCJiZWZvcmUiLCJhZnRlciIsImF2b2lkIiwidG9Db250YWluZXJfcGFnZWJyZWFrIiwicHhQYWdlSGVpZ2h0IiwicHgiLCJtb2RlU3JjIiwiY29uY2F0IiwiYXZvaWRBbGwiLCJpbmRleE9mIiwiY3NzIiwibGVnYWN5Iiwic2VsZWN0Iiwia2V5IiwiYWxsIiwic2xpY2UiLCJqb2luIiwibGVnYWN5RWxzIiwiZWxzIiwicGFnZWJyZWFrX2xvb3AiLCJlbCIsInJ1bGVzIiwic3R5bGUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiYnJlYWtPcHQiLCJhdm9pZE9wdCIsImJyZWFrQmVmb3JlIiwicGFnZUJyZWFrQmVmb3JlIiwiYnJlYWtBZnRlciIsInBhZ2VCcmVha0FmdGVyIiwiYnJlYWtJbnNpZGUiLCJwYWdlQnJlYWtJbnNpZGUiLCJPYmplY3QiLCJrZXlzIiwic3RhcnRQYWdlIiwiZW5kUGFnZSIsImJvdHRvbSIsImFicyIsInBhZCIsImNyZWF0ZUVsZW1lbnQiLCJkaXNwbGF5IiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsIm5leHRTaWJsaW5nIiwiZCIsIm9ialR5cGUiLCJjbG9uZU5vZGUiLCJ0b1B4IiwiY29yZV9qc19tb2R1bGVzX2VzX251bWJlcl9jb25zdHJ1Y3Rvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiY29yZV9qc19tb2R1bGVzX2VzX251bWJlcl9jb25zdHJ1Y3Rvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsImNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyIsImNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyIsImNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18iLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fIiwiY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fIiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX19kZWZhdWx0IiwidHlwZSIsIlN0cmluZyIsIk51bWJlciIsIkZ1bmN0aW9uIiwibm9kZVR5cGUiLCJ0YWdOYW1lIiwiZG9jdW1lbnQiLCJjbGFzc05hbWUiLCJpbm5lckhUTUwiLCJzY3JpcHRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJyZW1vdmVDaGlsZCIsIm5vZGUiLCJqYXZhc2NyaXB0RW5hYmxlZCIsImNsb25lIiwiY3JlYXRlVGV4dE5vZGUiLCJub2RlVmFsdWUiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJub2RlTmFtZSIsImFwcGVuZENoaWxkIiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInZhbHVlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJuZXdPYmoiLCJ2YWwiLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2Fzc2lnbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9hc3NpZ25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X21hcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X21hcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2tleXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsImNvcmVfanNfbW9kdWxlc19lc19vYmplY3Rfa2V5c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18iLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfcmVnZXhwX3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fIiwiY29yZV9qc19tb2R1bGVzX2VzX3JlZ2V4cF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX2Z1bmN0aW9uX25hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyIsImNvcmVfanNfbW9kdWxlc19lc19mdW5jdGlvbl9uYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18iLCJjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fX2RlZmF1bHQiLCJqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fIiwianNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX19kZWZhdWx0IiwiaHRtbDJjYW52YXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyIsImh0bWwyY2FudmFzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19fZGVmYXVsdCIsIl91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyIsImVzNl9wcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fIiwiZXM2X3Byb21pc2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19fZGVmYXVsdCIsIlByb21pc2UiLCJXb3JrZXIiLCJhc3NpZ24iLCJjb252ZXJ0IiwicmVzb2x2ZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInNldFByb2dyZXNzIiwic2V0IiwiY3JlYXRlIiwicHJvbWlzZSIsImluaGVyaXQiLCJfX3Byb3RvX18iLCJzcmMiLCJvdmVybGF5IiwiY2FudmFzIiwiaW1nIiwicHJvZ3Jlc3MiLCJzdGF0ZSIsInN0YWNrIiwiZmlsZW5hbWUiLCJpbWFnZSIsInF1YWxpdHkiLCJodG1sMmNhbnZhcyIsImZyb20iLCJnZXRUeXBlIiwiZnJvbV9tYWluIiwiZXJyb3IiLCJ0byIsInRhcmdldCIsInRvQ2FudmFzIiwidG9JbWciLCJwcmVyZXFzIiwiY2hlY2tTcmMiLCJjaGVja1BhZ2VTaXplIiwic2V0UGFnZVNpemUiLCJ0aGVuTGlzdCIsInRvQ29udGFpbmVyX21haW4iLCJvdmVybGF5Q1NTIiwicG9zaXRpb24iLCJvdmVyZmxvdyIsInpJbmRleCIsInJpZ2h0IiwiYmFja2dyb3VuZENvbG9yIiwiY29udGFpbmVyQ1NTIiwib3BhY2l0eSIsInNvdXJjZSIsImJvZHkiLCJjaGVja0NvbnRhaW5lciIsImNvbnRhaW5zIiwidG9DYW52YXNfbWFpbiIsIm9ucmVuZGVyZWQiLCJ0b0NhbnZhc19wb3N0Iiwib25SZW5kZXJlZCIsImNoZWNrQ2FudmFzIiwidG9JbWdfbWFpbiIsImltZ0RhdGEiLCJ0b0RhdGFVUkwiLCJ0b1BkZl9tYWluIiwicHhGdWxsSGVpZ2h0IiwicmF0aW8iLCJjZWlsIiwicGFnZUNhbnZhcyIsInBhZ2VDdHgiLCJ3IiwiaCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiYWRkUGFnZSIsImFkZEltYWdlIiwib3V0cHV0Iiwib3V0cHV0SW1nIiwib3V0cHV0UGRmIiwiY2hlY2tQZGYiLCJvdXRwdXRQZGZfbWFpbiIsImNoZWNrSW1nIiwib3V0cHV0SW1nX21haW4iLCJ1bmRlZmluZWQiLCJsb2NhdGlvbiIsInNhdmUiLCJzYXZlX21haW4iLCJmbnMiLCJtYXAiLCJzZXRNYXJnaW4iLCJiaW5kIiwic2V0X2pzUERGIiwic2V0X3Byb3AiLCJzZXRfb3B0Iiwic2V0X21haW4iLCJnZXQiLCJjYmsiLCJnZXRfbWFpbiIsInNldE1hcmdpbl9tYWluIiwic2V0UGFnZVNpemVfbWFpbiIsInVwZGF0ZVByb2dyZXNzIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwidGhlbkNvcmUiLCJ0aGVuX21haW4iLCJ0aGVuX3ByZSIsInRoZW5fcG9zdCIsInRoZW5CYXNlIiwiaXNOYXRpdmUiLCJ0b1N0cmluZyIsIm5hbWUiLCJzZWxmUHJvbWlzZSIsInJldHVyblZhbCIsInRoZW5FeHRlcm5hbCIsInRoZW5MaXN0X2ZvckVhY2giLCJmbiIsImNhdGNoRXh0ZXJuYWwiLCJtc2ciLCJlcnJvcl9tYWluIiwidXNpbmciLCJzYXZlQXMiLCJleHBvcnQiLCJydW4iLCJpdCIsIlR5cGVFcnJvciIsIl9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cyIsImlzT2JqZWN0Iiwid2VsbEtub3duU3ltYm9sIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUiLCJVTlNDT1BBQkxFUyIsIkFycmF5UHJvdG90eXBlIiwiZiIsImNvbmZpZ3VyYWJsZSIsIiRmb3JFYWNoIiwiYXJyYXlNZXRob2RJc1N0cmljdCIsIlNUUklDVF9NRVRIT0QiLCJjYWxsYmFja2ZuIiwiYXJndW1lbnRzIiwidG9JbmRleGVkT2JqZWN0IiwidG9MZW5ndGgiLCJ0b0Fic29sdXRlSW5kZXgiLCJjcmVhdGVNZXRob2QiLCJJU19JTkNMVURFUyIsIiR0aGlzIiwiZnJvbUluZGV4IiwiTyIsImluZGV4IiwiaW5jbHVkZXMiLCJJbmRleGVkT2JqZWN0IiwidG9PYmplY3QiLCJhcnJheVNwZWNpZXNDcmVhdGUiLCJUWVBFIiwiSVNfTUFQIiwiSVNfRklMVEVSIiwiSVNfU09NRSIsIklTX0VWRVJZIiwiSVNfRklORF9JTkRFWCIsIklTX0ZJTFRFUl9SRUpFQ1QiLCJOT19IT0xFUyIsInRoYXQiLCJzcGVjaWZpY0NyZWF0ZSIsImJvdW5kRnVuY3Rpb24iLCJyZXN1bHQiLCJmaWx0ZXIiLCJzb21lIiwiZXZlcnkiLCJmaW5kIiwiZmluZEluZGV4IiwiZmlsdGVyUmVqZWN0IiwiZmFpbHMiLCJWOF9WRVJTSU9OIiwiU1BFQ0lFUyIsIk1FVEhPRF9OQU1FIiwiYXJyYXkiLCJmb28iLCJCb29sZWFuIiwiYXJndW1lbnQiLCJtZXRob2QiLCJpc0FycmF5Iiwib3JpZ2luYWxBcnJheSIsIkMiLCJhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciIsIlRPX1NUUklOR19UQUdfU1VQUE9SVCIsImNsYXNzb2ZSYXciLCJUT19TVFJJTkdfVEFHIiwiQ09SUkVDVF9BUkdVTUVOVFMiLCJ0cnlHZXQiLCJ0YWciLCJjYWxsZWUiLCJoYXMiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlIiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJGIiwiZ2V0UHJvdG90eXBlT2YiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlIiwicXVvdCIsInN0cmluZyIsImF0dHJpYnV0ZSIsIlMiLCJwMSIsInJlcGxhY2UiLCJJdGVyYXRvclByb3RvdHlwZSIsImNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciIsInNldFRvU3RyaW5nVGFnIiwiSXRlcmF0b3JzIiwicmV0dXJuVGhpcyIsIkl0ZXJhdG9yQ29uc3RydWN0b3IiLCJOQU1FIiwibmV4dCIsIkRFU0NSSVBUT1JTIiwib2JqZWN0IiwiYml0bWFwIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwidG9Qcm9wZXJ0eUtleSIsInByb3BlcnR5S2V5IiwiJCIsImNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IiLCJzZXRQcm90b3R5cGVPZiIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSIsInJlZGVmaW5lIiwiSVNfUFVSRSIsIkl0ZXJhdG9yc0NvcmUiLCJCVUdHWV9TQUZBUklfSVRFUkFUT1JTIiwiSVRFUkFUT1IiLCJLRVlTIiwiVkFMVUVTIiwiRU5UUklFUyIsIkl0ZXJhYmxlIiwiREVGQVVMVCIsIklTX1NFVCIsIkZPUkNFRCIsImdldEl0ZXJhdGlvbk1ldGhvZCIsIktJTkQiLCJkZWZhdWx0SXRlcmF0b3IiLCJJdGVyYWJsZVByb3RvdHlwZSIsInZhbHVlcyIsImVudHJpZXMiLCJJTkNPUlJFQ1RfVkFMVUVTX05BTUUiLCJuYXRpdmVJdGVyYXRvciIsImFueU5hdGl2ZUl0ZXJhdG9yIiwiQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlIiwibWV0aG9kcyIsIktFWSIsInByb3RvIiwiZm9yY2VkIiwicGF0aCIsIndyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUiLCJnbG9iYWwiLCJFWElTVFMiLCJDU1NSdWxlTGlzdCIsIkNTU1N0eWxlRGVjbGFyYXRpb24iLCJDU1NWYWx1ZUxpc3QiLCJDbGllbnRSZWN0TGlzdCIsIkRPTVJlY3RMaXN0IiwiRE9NU3RyaW5nTGlzdCIsIkRPTVRva2VuTGlzdCIsIkRhdGFUcmFuc2Zlckl0ZW1MaXN0IiwiRmlsZUxpc3QiLCJIVE1MQWxsQ29sbGVjdGlvbiIsIkhUTUxDb2xsZWN0aW9uIiwiSFRNTEZvcm1FbGVtZW50IiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJNZWRpYUxpc3QiLCJNaW1lVHlwZUFycmF5IiwiTmFtZWROb2RlTWFwIiwiTm9kZUxpc3QiLCJQYWludFJlcXVlc3RMaXN0IiwiUGx1Z2luIiwiUGx1Z2luQXJyYXkiLCJTVkdMZW5ndGhMaXN0IiwiU1ZHTnVtYmVyTGlzdCIsIlNWR1BhdGhTZWdMaXN0IiwiU1ZHUG9pbnRMaXN0IiwiU1ZHU3RyaW5nTGlzdCIsIlNWR1RyYW5zZm9ybUxpc3QiLCJTb3VyY2VCdWZmZXJMaXN0IiwiU3R5bGVTaGVldExpc3QiLCJUZXh0VHJhY2tDdWVMaXN0IiwiVGV4dFRyYWNrTGlzdCIsIlRvdWNoTGlzdCIsImdldEJ1aWx0SW4iLCJ1c2VyQWdlbnQiLCJwcm9jZXNzIiwiRGVubyIsInZlcnNpb25zIiwidmVyc2lvbiIsInY4IiwibWF0Y2giLCJzcGxpdCIsInNldEdsb2JhbCIsImNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMiLCJpc0ZvcmNlZCIsIlRBUkdFVCIsIkdMT0JBTCIsIlNUQVRJQyIsInN0YXQiLCJ0YXJnZXRQcm9wZXJ0eSIsInNvdXJjZVByb3BlcnR5IiwiZGVzY3JpcHRvciIsIm5vVGFyZ2V0R2V0Iiwic2hhbSIsImV4ZWMiLCJhRnVuY3Rpb24iLCJhIiwiYiIsImMiLCJhcHBseSIsInZhcmlhYmxlIiwibmFtZXNwYWNlIiwiY2hlY2siLCJnbG9iYWxUaGlzIiwiaGFzT3duIiwiY2xhc3NvZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZHVtbXkiLCJXcmFwcGVyIiwiTmV3VGFyZ2V0IiwiTmV3VGFyZ2V0UHJvdG90eXBlIiwic3RvcmUiLCJmdW5jdGlvblRvU3RyaW5nIiwiaW5zcGVjdFNvdXJjZSIsIk5BVElWRV9XRUFLX01BUCIsIm9iamVjdEhhcyIsInNoYXJlZCIsInNoYXJlZEtleSIsImhpZGRlbktleXMiLCJPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCIsIldlYWtNYXAiLCJlbmZvcmNlIiwiZ2V0dGVyRm9yIiwid21nZXQiLCJ3bWhhcyIsIndtc2V0IiwibWV0YWRhdGEiLCJmYWNhZGUiLCJTVEFURSIsImFyZyIsInJlcGxhY2VtZW50IiwiZmVhdHVyZSIsImRldGVjdGlvbiIsImRhdGEiLCJub3JtYWxpemUiLCJQT0xZRklMTCIsIk5BVElWRSIsIlVTRV9TWU1CT0xfQVNfVUlEIiwiJFN5bWJvbCIsIlByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSIsImFycmF5SXRlcmF0b3IiLCJORVdfSVRFUkFUT1JfUFJPVE9UWVBFIiwidGVzdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbCIsIm9iamVjdEtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSIsIiRhc3NpZ24iLCJBIiwiQiIsImFscGhhYmV0IiwiY2hyIiwiVCIsImFyZ3VtZW50c0xlbmd0aCIsImoiLCJhbk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJlbnVtQnVnS2V5cyIsImh0bWwiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQiLCJHVCIsIkxUIiwiUFJPVE9UWVBFIiwiU0NSSVBUIiwiSUVfUFJPVE8iLCJFbXB0eUNvbnN0cnVjdG9yIiwic2NyaXB0VGFnIiwiY29udGVudCIsIk51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgiLCJhY3RpdmVYRG9jdW1lbnQiLCJ3cml0ZSIsImNsb3NlIiwidGVtcCIsInBhcmVudFdpbmRvdyIsIk51bGxQcm90b09iamVjdFZpYUlGcmFtZSIsImlmcmFtZSIsIkpTIiwiaWZyYW1lRG9jdW1lbnQiLCJjb250ZW50V2luZG93Iiwib3BlbiIsIk51bGxQcm90b09iamVjdCIsIkFjdGl2ZVhPYmplY3QiLCJkb21haW4iLCJQcm9wZXJ0aWVzIiwiSUU4X0RPTV9ERUZJTkUiLCIkZGVmaW5lUHJvcGVydHkiLCJQIiwiQXR0cmlidXRlcyIsIiRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCIkZ2V0T3duUHJvcGVydHlOYW1lcyIsIndpbmRvd05hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldFdpbmRvd05hbWVzIiwiaW50ZXJuYWxPYmplY3RLZXlzIiwiQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSIiwiT2JqZWN0UHJvdG90eXBlIiwibmFtZXMiLCIkcHJvcGVydHlJc0VudW1lcmFibGUiLCJOQVNIT1JOX0JVRyIsIlYiLCJhUG9zc2libGVQcm90b3R5cGUiLCJDT1JSRUNUX1NFVFRFUiIsInNldHRlciIsImlucHV0IiwicHJlZiIsInZhbHVlT2YiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlIiwiSW50ZXJuYWxTdGF0ZU1vZHVsZSIsImdldEludGVybmFsU3RhdGUiLCJlbmZvcmNlSW50ZXJuYWxTdGF0ZSIsIlRFTVBMQVRFIiwidW5zYWZlIiwic2ltcGxlIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsImRvdEFsbCIsInVuaWNvZGUiLCJzdGlja3kiLCJUQUciLCJ1aWQiLCJTSEFSRUQiLCJjb3B5cmlnaHQiLCJ0b0ludGVnZXIiLCJDT05WRVJUX1RPX1NUUklORyIsInBvcyIsInNpemUiLCJmaXJzdCIsInNlY29uZCIsImNoYXJDb2RlQXQiLCJjaGFyQXQiLCJjb2RlQXQiLCJ3aGl0ZXNwYWNlcyIsIndoaXRlc3BhY2UiLCJsdHJpbSIsIlJlZ0V4cCIsInJ0cmltIiwic3RhcnQiLCJlbmQiLCJ0cmltIiwibWF4IiwibWluIiwiaW50ZWdlciIsImlzTmFOIiwiaXNTeW1ib2wiLCJvcmRpbmFyeVRvUHJpbWl0aXZlIiwiVE9fUFJJTUlUSVZFIiwiZXhvdGljVG9QcmltIiwidG9QcmltaXRpdmUiLCJpZCIsInBvc3RmaXgiLCJyYW5kb20iLCJOQVRJVkVfU1lNQk9MIiwiV2VsbEtub3duU3ltYm9sc1N0b3JlIiwiY3JlYXRlV2VsbEtub3duU3ltYm9sIiwid2l0aG91dFNldHRlciIsImNyZWF0ZVByb3BlcnR5IiwiYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCIsIklTX0NPTkNBVF9TUFJFQURBQkxFIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCIsIklTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQiLCJTUEVDSUVTX1NVUFBPUlQiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJzcHJlYWRhYmxlIiwibGVuIiwiRSIsImFkZFRvVW5zY29wYWJsZXMiLCJkZWZpbmVJdGVyYXRvciIsIkFSUkFZX0lURVJBVE9SIiwic2V0SW50ZXJuYWxTdGF0ZSIsIml0ZXJhdGVkIiwia2luZCIsImRvbmUiLCJBcmd1bWVudHMiLCJuYXRpdmVKb2luIiwiRVMzX1NUUklOR1MiLCJzZXBhcmF0b3IiLCIkbWFwIiwiSEFTX1NQRUNJRVNfU1VQUE9SVCIsIm5hdGl2ZVNsaWNlIiwiZmluIiwiQ29uc3RydWN0b3IiLCJGdW5jdGlvblByb3RvdHlwZSIsIkZ1bmN0aW9uUHJvdG90eXBlVG9TdHJpbmciLCJuYW1lUkUiLCJpbmhlcml0SWZSZXF1aXJlZCIsIk5VTUJFUiIsIk5hdGl2ZU51bWJlciIsIk51bWJlclByb3RvdHlwZSIsIkJST0tFTl9DTEFTU09GIiwidG9OdW1iZXIiLCJ0aGlyZCIsInJhZGl4IiwibWF4Q29kZSIsImRpZ2l0cyIsImNvZGUiLCJOYU4iLCJwYXJzZUludCIsIk51bWJlcldyYXBwZXIiLCJuYXRpdmVLZXlzIiwiRkFJTFNfT05fUFJJTUlUSVZFUyIsIiR0b1N0cmluZyIsImZsYWdzIiwiVE9fU1RSSU5HIiwiUmVnRXhwUHJvdG90eXBlIiwibmF0aXZlVG9TdHJpbmciLCJOT1RfR0VORVJJQyIsIklOQ09SUkVDVF9OQU1FIiwiUiIsInAiLCJyZiIsIlNUUklOR19JVEVSQVRPUiIsInBvaW50IiwiY3JlYXRlSFRNTCIsImZvcmNlZFN0cmluZ0hUTUxNZXRob2QiLCJOYXRpdmVTeW1ib2wiLCJkZXNjcmlwdGlvbiIsIkVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSIsIlN5bWJvbFdyYXBwZXIiLCJzeW1ib2xQcm90b3R5cGUiLCJzeW1ib2xUb1N0cmluZyIsIm5hdGl2ZSIsInJlZ2V4cCIsImRlc2MiLCJkZWZpbmVXZWxsS25vd25TeW1ib2wiLCJuYXRpdmVPYmplY3RDcmVhdGUiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwiLCJISURERU4iLCJTWU1CT0wiLCIkc3RyaW5naWZ5IiwibmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwibmF0aXZlRGVmaW5lUHJvcGVydHkiLCJuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzIiwibmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUiLCJBbGxTeW1ib2xzIiwiT2JqZWN0UHJvdG90eXBlU3ltYm9scyIsIlN0cmluZ1RvU3ltYm9sUmVnaXN0cnkiLCJTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5IiwiUU9iamVjdCIsIlVTRV9TRVRURVIiLCJmaW5kQ2hpbGQiLCJzZXRTeW1ib2xEZXNjcmlwdG9yIiwiT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciIsIndyYXAiLCIkZGVmaW5lUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCIkZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiJGNyZWF0ZSIsIklTX09CSkVDVF9QUk9UT1RZUEUiLCJrZXlGb3IiLCJzeW0iLCJ1c2VTZXR0ZXIiLCJ1c2VTaW1wbGUiLCJGT1JDRURfSlNPTl9TVFJJTkdJRlkiLCJyZXBsYWNlciIsInNwYWNlIiwiYXJncyIsIiRyZXBsYWNlciIsIkRPTUl0ZXJhYmxlcyIsIkNPTExFQ1RJT05fTkFNRSIsIkNvbGxlY3Rpb24iLCJDb2xsZWN0aW9uUHJvdG90eXBlIiwiQXJyYXlJdGVyYXRvck1ldGhvZHMiLCJBcnJheVZhbHVlcyIsIm9iamVjdE9yRnVuY3Rpb24iLCJ4IiwiaXNGdW5jdGlvbiIsIl9pc0FycmF5IiwidmVydHhOZXh0IiwiY3VzdG9tU2NoZWR1bGVyRm4iLCJhc2FwIiwiY2FsbGJhY2siLCJxdWV1ZSIsImZsdXNoIiwic2NoZWR1bGVGbHVzaCIsInNldFNjaGVkdWxlciIsInNjaGVkdWxlRm4iLCJzZXRBc2FwIiwiYXNhcEZuIiwiYnJvd3NlcldpbmRvdyIsImJyb3dzZXJHbG9iYWwiLCJCcm93c2VyTXV0YXRpb25PYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwiaXNOb2RlIiwiaXNXb3JrZXIiLCJVaW50OENsYW1wZWRBcnJheSIsImltcG9ydFNjcmlwdHMiLCJNZXNzYWdlQ2hhbm5lbCIsInVzZU5leHRUaWNrIiwibmV4dFRpY2siLCJ1c2VWZXJ0eFRpbWVyIiwidXNlU2V0VGltZW91dCIsInVzZU11dGF0aW9uT2JzZXJ2ZXIiLCJpdGVyYXRpb25zIiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInVzZU1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQxIiwib25tZXNzYWdlIiwicG9ydDIiLCJwb3N0TWVzc2FnZSIsImdsb2JhbFNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXR0ZW1wdFZlcnR4IiwidmVydHgiLCJydW5Pbkxvb3AiLCJydW5PbkNvbnRleHQiLCJlIiwib25GdWxmaWxsbWVudCIsIm9uUmVqZWN0aW9uIiwicGFyZW50Iiwibm9vcCIsIlBST01JU0VfSUQiLCJtYWtlUHJvbWlzZSIsIl9zdGF0ZSIsImludm9rZUNhbGxiYWNrIiwiX3Jlc3VsdCIsInN1YnNjcmliZSIsInJlc29sdmUkMSIsInN1YnN0cmluZyIsIlBFTkRJTkciLCJGVUxGSUxMRUQiLCJSRUpFQ1RFRCIsInNlbGZGdWxmaWxsbWVudCIsImNhbm5vdFJldHVybk93biIsInRyeVRoZW4iLCJ0aGVuJCQxIiwiZnVsZmlsbG1lbnRIYW5kbGVyIiwicmVqZWN0aW9uSGFuZGxlciIsImhhbmRsZUZvcmVpZ25UaGVuYWJsZSIsInRoZW5hYmxlIiwic2VhbGVkIiwiZnVsZmlsbCIsInJlYXNvbiIsInJlamVjdCIsIl9sYWJlbCIsImhhbmRsZU93blRoZW5hYmxlIiwiaGFuZGxlTWF5YmVUaGVuYWJsZSIsIm1heWJlVGhlbmFibGUiLCJwdWJsaXNoUmVqZWN0aW9uIiwiX29uZXJyb3IiLCJwdWJsaXNoIiwiX3N1YnNjcmliZXJzIiwic3Vic2NyaWJlcnMiLCJzZXR0bGVkIiwiZGV0YWlsIiwiaGFzQ2FsbGJhY2siLCJzdWNjZWVkZWQiLCJpbml0aWFsaXplUHJvbWlzZSIsInJlc29sdmVyIiwicmVzb2x2ZVByb21pc2UiLCJyZWplY3RQcm9taXNlIiwibmV4dElkIiwidmFsaWRhdGlvbkVycm9yIiwiRW51bWVyYXRvciIsIl9pbnN0YW5jZUNvbnN0cnVjdG9yIiwiX3JlbWFpbmluZyIsIl9lbnVtZXJhdGUiLCJfZWFjaEVudHJ5IiwiZW50cnkiLCJyZXNvbHZlJCQxIiwiX3RoZW4iLCJkaWRFcnJvciIsIl9zZXR0bGVkQXQiLCJQcm9taXNlJDEiLCJfd2lsbFNldHRsZUF0IiwiZW51bWVyYXRvciIsInJhY2UiLCJfIiwicmVqZWN0JDEiLCJuZWVkc1Jlc29sdmVyIiwibmVlZHNOZXciLCJjYXRjaCIsIl9jYXRjaCIsImZpbmFsbHkiLCJfZmluYWxseSIsIl9zZXRTY2hlZHVsZXIiLCJfc2V0QXNhcCIsIl9hc2FwIiwicG9seWZpbGwiLCJsb2NhbCIsInByb21pc2VUb1N0cmluZyIsImNhc3QiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsImdldHRlciIsIl9fZXNNb2R1bGUiLCJkZWZpbml0aW9uIiwibyIsInRvU3RyaW5nVGFnIiwiX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiX3BsdWdpbl9qc3BkZl9wbHVnaW5fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsIl9wbHVnaW5fcGFnZWJyZWFrc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fIiwiX3BsdWdpbl9oeXBlcmxpbmtzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJodG1sMnBkZiIsIndvcmtlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html2pdf.js/dist/html2pdf.js\n");

/***/ })

};
;